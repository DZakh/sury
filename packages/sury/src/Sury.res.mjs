// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_List from "rescript/lib/es6/Belt_List.js";
import * as JSONSchema from "./JSONSchema.res.mjs";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";
import * as Primitive_exceptions from "rescript/lib/es6/Primitive_exceptions.js";

let immutableEmpty = {};

let immutableEmpty$1 = [];

function capitalize(string) {
  return string.slice(0, 1).toUpperCase() + string.slice(1);
}

let copy = ((d) => ({...d}));

function fromString(string) {
  let _idx = 0;
  while (true) {
    let idx = _idx;
    let match = string[idx];
    if (match === undefined) {
      return "\"" + string + "\"";
    }
    switch (match) {
      case "\"" :
      case "\n" :
        return JSON.stringify(string);
      default:
        _idx = idx + 1 | 0;
        continue;
    }
  };
}

function toArray(path) {
  if (path === "") {
    return [];
  } else {
    return JSON.parse(path.split("\"][\"").join("\",\""));
  }
}

function fromLocation(location) {
  return "[" + fromString(location) + "]";
}

function fromArray(array) {
  let len = array.length;
  if (len !== 1) {
    if (len !== 0) {
      return "[" + array.map(fromString).join("][") + "]";
    } else {
      return "";
    }
  } else {
    return "[" + fromString(array[0]) + "]";
  }
}

function concat(path, concatedPath) {
  return path + concatedPath;
}

let vendor = "sury";

let s = Symbol(vendor);

let itemSymbol = Symbol(vendor + ":item");

let $$Error = /* @__PURE__ */Primitive_exceptions.create("Sury.Error");

let isLiteral = (s => "const" in s);

function isOptional(schema) {
  let match = schema.type;
  switch (match) {
    case "undefined" :
      return true;
    case "union" :
      return schema.has["undefined"];
    default:
      return false;
  }
}

let globalConfig = {
  d: undefined,
  a: "strip",
  n: false
};

class SuryError extends Error {
  constructor(code, flag, path) {
    super();
    this.flag = flag;
    this.code = code;
    this.path = path;
  }
}

var d = Object.defineProperty, p = SuryError.prototype;
d(p, 'message', {
  get() {
      return message(this);
  },
})
d(p, 'reason', {
  get() {
      return reason(this);
  }
})
d(p, 'name', {value: 'SuryError'})
d(p, 's', {value: s})
d(p, '_1', {
  get() {
    return this
  },
});
d(p, 'RE_EXN_ID', {
  value: $$Error,
});

var Schema = function(type) {this.type=type}, sp = Object.create(null);
d(sp, 'with', {
  get() {
    return (fn, ...args) => fn(this, ...args)
  },
});
// Also has ~standard below
Schema.prototype = sp;
;

function getOrRethrow(exn) {
  if ((exn&&exn.s===s)) {
    return exn;
  }
  throw exn;
}

let shakenRef = "as";

let shakenTraps = {
  get: (target, prop) => {
    let l = target[shakenRef];
    if (l === undefined) {
      return target[prop];
    }
    if (prop === shakenRef) {
      return target[prop];
    }
    let l$1 = Primitive_option.valFromOption(l);
    let message = "Schema S." + l$1 + " is not enabled. To start using it, add S.enable" + capitalize(l$1) + "() at the project root.";
    throw new Error("[Sury] " + message);
  }
};

function shaken(apiName) {
  let mut = new Schema("never");
  mut[shakenRef] = apiName;
  return new Proxy(mut, shakenTraps);
}

let unknown = new Schema("unknown");

let bool = new Schema("boolean");

let symbol = new Schema("symbol");

let string = new Schema("string");

let int = new Schema("number");

int.format = "int32";

let float = new Schema("number");

let bigint = new Schema("bigint");

let unit = new Schema("undefined");

unit.const = (void 0);

function has(acc, flag) {
  return (acc & flag) !== 0;
}

let flags = {
    unknown: 1,
    string: 2,
    number: 4,
    boolean: 8,
    undefined: 16,
    null: 32,
    object: 64,
    array: 128,
    union: 256,
    ref: 512,
    bigint: 1024,
    nan: 2048,
    "function": 4096,
    instance: 8192,
    never: 16384,
    symbol: 32768,
  };

let copyWithoutCache = ((schema) => {
  let c = new Schema(schema.type)
  for (let k in schema) {
    if (k > "a" || k === "$ref" || k === "$defs") {
      c[k] = schema[k]
    }
  }
  return c
});

function updateOutput(schema, fn) {
  let root = copyWithoutCache(schema);
  let mut = root;
  while (mut.to) {
    let next = copyWithoutCache(mut.to);
    mut.to = next;
    mut = next;
  };
  fn(mut);
  return root;
}

let resetCacheInPlace = ((schema) => {
  for (let k in schema) {
    if (Number(k[0])) {
      delete schema[k];
    }
  }
});

function stringify(unknown) {
  let tagFlag = flags[typeof unknown];
  if (tagFlag & 16) {
    return "undefined";
  }
  if (!(tagFlag & 64)) {
    if (tagFlag & 2) {
      return "\"" + unknown + "\"";
    } else if (tagFlag & 1024) {
      return unknown + "n";
    } else {
      return unknown.toString();
    }
  }
  if (unknown === null) {
    return "null";
  }
  if (Array.isArray(unknown)) {
    let string = "[";
    for (let i = 0, i_finish = unknown.length; i < i_finish; ++i) {
      if (i !== 0) {
        string = string + ", ";
      }
      string = string + stringify(unknown[i]);
    }
    return string + "]";
  }
  if (unknown.constructor !== Object) {
    return Object.prototype.toString.call(unknown);
  }
  let keys = Object.keys(unknown);
  let string$1 = "{ ";
  for (let i$1 = 0, i_finish$1 = keys.length; i$1 < i_finish$1; ++i$1) {
    let key = keys[i$1];
    let value = unknown[key];
    string$1 = string$1 + key + ": " + stringify(value) + "; ";
  }
  return string$1 + "}";
}

function toExpression(schema) {
  let tag = schema.type;
  let $$const = schema.const;
  let name = schema.name;
  if (name !== undefined) {
    return name;
  }
  if ($$const !== undefined) {
    return stringify($$const);
  }
  let format = schema.format;
  let anyOf = schema.anyOf;
  if (anyOf !== undefined) {
    return anyOf.map(toExpression).join(" | ");
  }
  if (format !== undefined) {
    return format;
  }
  switch (tag) {
    case "nan" :
      return "NaN";
    case "object" :
      let additionalItems = schema.additionalItems;
      let properties = schema.properties;
      let locations = Object.keys(properties);
      if (locations.length === 0) {
        if (typeof additionalItems === "object") {
          return "{ [key: string]: " + toExpression(additionalItems) + "; }";
        } else {
          return "{}";
        }
      } else {
        return "{ " + locations.map(location => location + ": " + toExpression(properties[location]) + ";").join(" ") + " }";
      }
    default:
      if (schema.b) {
        return tag;
      }
      switch (tag) {
        case "instance" :
          return schema.class.name;
        case "array" :
          let additionalItems$1 = schema.additionalItems;
          let items = schema.items;
          if (typeof additionalItems$1 !== "object") {
            return "[" + items.map(item => toExpression(item.schema)).join(", ") + "]";
          }
          let itemName = toExpression(additionalItems$1);
          return (
            additionalItems$1.type === "union" ? "(" + itemName + ")" : itemName
          ) + "[]";
        default:
          return tag;
      }
  }
}

let value = SuryError;

function constructor(prim0, prim1, prim2) {
  return new SuryError(prim0, prim1, prim2);
}

function reason(error, nestedLevelOpt) {
  let nestedLevel = nestedLevelOpt !== undefined ? nestedLevelOpt : 0;
  let reason$1 = error.code;
  if (typeof reason$1 !== "object") {
    return "Encountered unexpected async transform or refine. Use parseAsyncOrThrow operation instead";
  }
  switch (reason$1.TAG) {
    case "OperationFailed" :
      return reason$1._0;
    case "InvalidOperation" :
      return reason$1.description;
    case "InvalidType" :
      let unionErrors = reason$1.unionErrors;
      let m = "Expected " + toExpression(reason$1.expected) + ", received " + stringify(reason$1.received);
      if (unionErrors !== undefined) {
        let lineBreak = "\n" + " ".repeat((nestedLevel << 1));
        let reasonsDict = {};
        for (let idx = 0, idx_finish = unionErrors.length; idx < idx_finish; ++idx) {
          let error$1 = unionErrors[idx];
          let reason$2 = reason(error$1, nestedLevel + 1);
          let nonEmptyPath = error$1.path;
          let location = nonEmptyPath === "" ? "" : "At " + nonEmptyPath + ": ";
          let line = "- " + location + reason$2;
          if (!reasonsDict[line]) {
            reasonsDict[line] = 1;
            m = m + lineBreak + line;
          }
          
        }
      }
      return m;
    case "UnsupportedTransformation" :
      return "Unsupported transformation from " + toExpression(reason$1.from) + " to " + toExpression(reason$1.to);
    case "ExcessField" :
      return "Unrecognized key \"" + reason$1._0 + "\"";
    case "InvalidJsonSchema" :
      return toExpression(reason$1._0) + " is not valid JSON";
  }
}

function reason$1(error) {
  return reason(error, undefined);
}

function message(error) {
  let op = error.flag;
  let text = "Failed ";
  if (op & 2) {
    text = text + "async ";
  }
  text = text + (
    op & 1 ? (
        op & 4 ? "asserting" : "parsing"
      ) : "converting"
  );
  if (op & 8) {
    text = text + " to JSON" + (
      op & 16 ? " string" : ""
    );
  }
  let nonEmptyPath = error.path;
  let tmp = nonEmptyPath === "" ? "" : " at " + nonEmptyPath;
  return text + tmp + ": " + reason(error, undefined);
}

let ErrorClass = {
  value: value,
  constructor: constructor,
  reason: reason$1,
  message: message
};

function embed(b, value) {
  let e = b.g.e;
  let l = e.length;
  e[l] = value;
  return "e[" + l + "]";
}

function inlineConst(b, schema) {
  let tagFlag = flags[schema.type];
  let $$const = schema.const;
  if (tagFlag & 16) {
    return "void 0";
  } else if (tagFlag & 2) {
    return fromString($$const);
  } else if (tagFlag & 1024) {
    return $$const + "n";
  } else if (tagFlag & 45056) {
    return embed(b, schema.const);
  } else {
    return $$const;
  }
}

function inlineLocation(b, location) {
  let key = "\"" + location + "\"";
  let i = b.g[key];
  if (i !== undefined) {
    return i;
  }
  let inlinedLocation = fromString(location);
  b.g[key] = inlinedLocation;
  return inlinedLocation;
}

function secondAllocate(v) {
  let b = this;
  b.l = b.l + "," + v;
}

function initialAllocate(v) {
  let b = this;
  b.l = v;
  b.a = secondAllocate;
}

function rootScope(flag, defs) {
  let global = {
    c: "",
    l: "",
    a: initialAllocate,
    v: -1,
    o: flag,
    f: "",
    e: [],
    d: defs
  };
  global.g = global;
  return global;
}

function allocateScope(b) {
  ((delete b.a));
  let varsAllocation = b.l;
  if (varsAllocation === "") {
    return b.f + b.c;
  } else {
    return b.f + "let " + varsAllocation + ";" + b.c;
  }
}

function varWithoutAllocation(global) {
  let newCounter = global.v + 1;
  global.v = newCounter;
  return "v" + newCounter;
}

function _var(_b) {
  return this.i;
}

function _notVar(b) {
  let val = this;
  let v = varWithoutAllocation(b.g);
  let i = val.i;
  if (i === "") {
    val.b.a(v);
  } else if (b.a !== (void 0)) {
    b.a(v + "=" + i);
  } else {
    b.c = b.c + (v + "=" + i + ";");
    b.g.a(v);
  }
  val.v = _var;
  val.i = v;
  return v;
}

function allocateVal(b, schema) {
  let v = varWithoutAllocation(b.g);
  b.a(v);
  return {
    b: b,
    v: _var,
    i: v,
    f: 0,
    type: schema.type
  };
}

function val(b, initial, schema) {
  return {
    b: b,
    v: _notVar,
    i: initial,
    f: 0,
    type: schema.type
  };
}

function constVal(b, schema) {
  return {
    b: b,
    v: _notVar,
    i: inlineConst(b, schema),
    f: 0,
    type: schema.type,
    const: schema.const
  };
}

function asyncVal(b, initial) {
  return {
    b: b,
    v: _notVar,
    i: initial,
    f: 2,
    type: "unknown"
  };
}

function objectJoin(inlinedLocation, value) {
  return inlinedLocation + ":" + value + ",";
}

function arrayJoin(_inlinedLocation, value) {
  return value + ",";
}

function make(b, isArray) {
  return {
    b: b,
    v: _notVar,
    i: "",
    f: 0,
    type: isArray ? "array" : "object",
    properties: {},
    additionalItems: "strict",
    j: isArray ? arrayJoin : objectJoin,
    c: 0,
    r: ""
  };
}

function add(objectVal, location, val) {
  let inlinedLocation = inlineLocation(objectVal.b, location);
  objectVal.properties[location] = val;
  if (val.f & 2) {
    objectVal.r = objectVal.r + val.i + ",";
    objectVal.i = objectVal.i + objectVal.j(inlinedLocation, "a[" + (objectVal.c++) + "]");
  } else {
    objectVal.i = objectVal.i + objectVal.j(inlinedLocation, val.i);
  }
}

function merge(target, subObjectVal) {
  let locations = Object.keys(subObjectVal.properties);
  for (let idx = 0, idx_finish = locations.length; idx < idx_finish; ++idx) {
    let location = locations[idx];
    add(target, location, subObjectVal.properties[location]);
  }
}

function complete(objectVal, isArray) {
  objectVal.i = isArray ? "[" + objectVal.i + "]" : "{" + objectVal.i + "}";
  if (objectVal.c) {
    objectVal.f = objectVal.f | 2;
    objectVal.i = "Promise.all([" + objectVal.r + "]).then(a=>(" + objectVal.i + "))";
  }
  objectVal.additionalItems = "strict";
  return objectVal;
}

function addKey(b, input, key, val) {
  return input.v(b) + "[" + key + "]=" + val.i;
}

function set(b, input, val) {
  if (input === val) {
    return "";
  }
  let inputVar = input.v(b);
  let match = input.f & 2;
  let match$1 = val.f & 2;
  if (match) {
    if (!match$1) {
      return inputVar + "=Promise.resolve(" + val.i + ")";
    }
    
  } else if (match$1) {
    input.f = input.f | 2;
    return inputVar + "=" + val.i;
  }
  return inputVar + "=" + val.i;
}

function get(b, targetVal, location) {
  let properties = targetVal.properties;
  let val = properties[location];
  if (val !== undefined) {
    return val;
  }
  let schema = targetVal.additionalItems;
  let schema$1;
  if (schema === "strip" || schema === "strict") {
    if (schema === "strip") {
      throw new Error("[Sury] The schema doesn't have additional items");
    }
    throw new Error("[Sury] The schema doesn't have additional items");
  } else {
    schema$1 = schema;
  }
  let val$1 = {
    b: b,
    v: _notVar,
    i: targetVal.v(b) + ("[" + fromString(location) + "]"),
    f: 0,
    type: schema$1.type
  };
  properties[location] = val$1;
  return val$1;
}

function setInlined(b, input, inlined) {
  return input.v(b) + "=" + inlined;
}

function map(inlinedFn, input) {
  return {
    b: input.b,
    v: _notVar,
    i: inlinedFn + "(" + input.i + ")",
    f: 0,
    type: "unknown"
  };
}

function transform(b, input, operation) {
  if (!(input.f & 2)) {
    return operation(b, input);
  }
  let bb = {
    c: "",
    l: "",
    a: initialAllocate,
    f: "",
    g: b.g
  };
  let operationInput = {
    b: b,
    v: _var,
    i: varWithoutAllocation(bb.g),
    f: 0,
    type: "unknown"
  };
  let operationOutputVal = operation(bb, operationInput);
  let operationCode = allocateScope(bb);
  return asyncVal(input.b, input.i + ".then(" + operationInput.v(b) + "=>{" + operationCode + "return " + operationOutputVal.i + "})");
}

function $$throw(b, code, path) {
  throw new SuryError(code, b.g.o, path);
}

function embedSyncOperation(b, input, fn) {
  if (input.f & 2) {
    return asyncVal(input.b, input.i + ".then(" + embed(b, fn) + ")");
  } else {
    return map(embed(b, fn), input);
  }
}

function failWithArg(b, path, fn, arg) {
  return embed(b, arg => $$throw(b, fn(arg), path)) + "(" + arg + ")";
}

function fail(b, message, path) {
  return embed(b, () => $$throw(b, {
    TAG: "OperationFailed",
    _0: message
  }, path)) + "()";
}

function effectCtx(b, selfSchema, path) {
  return {
    schema: selfSchema,
    fail: (message, customPathOpt) => {
      let customPath = customPathOpt !== undefined ? customPathOpt : "";
      return $$throw(b, {
        TAG: "OperationFailed",
        _0: message
      }, path + customPath);
    }
  };
}

function invalidOperation(b, path, description) {
  return $$throw(b, {
    TAG: "InvalidOperation",
    description: description
  }, path);
}

function withPathPrepend(b, input, path, maybeDynamicLocationVar, appendSafe, fn) {
  if (path === "" && maybeDynamicLocationVar === undefined) {
    return fn(b, input, path);
  }
  try {
    let $$catch = (b, errorVar) => {
      b.c = errorVar + ".path=" + fromString(path) + "+" + (
        maybeDynamicLocationVar !== undefined ? "'[\"'+" + maybeDynamicLocationVar + "+'\"]'+" : ""
      ) + errorVar + ".path";
    };
    let fn$1 = b => fn(b, input, "");
    let prevCode = b.c;
    b.c = "";
    let errorVar = varWithoutAllocation(b.g);
    let maybeResolveVal = $$catch(b, errorVar);
    let catchCode = "if(" + (errorVar + "&&" + errorVar + ".s===s") + "){" + b.c;
    b.c = "";
    let bb = {
      c: "",
      l: "",
      a: initialAllocate,
      f: "",
      g: b.g
    };
    let fnOutput = fn$1(bb);
    b.c = b.c + allocateScope(bb);
    let isNoop = fnOutput.i === input.i && b.c === "";
    if (appendSafe !== undefined) {
      appendSafe(b, fnOutput);
    }
    if (isNoop) {
      return fnOutput;
    }
    let isAsync = fnOutput.f & 2;
    let output = input === fnOutput ? input : (
        appendSafe !== undefined ? fnOutput : ({
            b: b,
            v: _notVar,
            i: "",
            f: isAsync ? 2 : 0,
            type: "unknown"
          })
      );
    let catchCode$1 = maybeResolveVal !== undefined ? catchLocation => catchCode + (
        catchLocation === 1 ? "return " + maybeResolveVal.i : set(b, output, maybeResolveVal)
      ) + ("}else{throw " + errorVar + "}") : param => catchCode + "}throw " + errorVar;
    b.c = prevCode + ("try{" + b.c + (
      isAsync ? setInlined(b, output, fnOutput.i + ".catch(" + errorVar + "=>{" + catchCode$1(1) + "})") : set(b, output, fnOutput)
    ) + "}catch(" + errorVar + "){" + catchCode$1(0) + "}");
    return output;
  } catch (exn) {
    let error = getOrRethrow(exn);
    throw new SuryError(error.code, error.flag, path + "[]" + error.path);
  }
}

function validation(b, inputVar, schema, negative) {
  let eq = negative ? "!==" : "===";
  let and_ = negative ? "||" : "&&";
  let exp = negative ? "!" : "";
  let tag = schema.type;
  let tagFlag = flags[tag];
  if (tagFlag & 2048) {
    return exp + ("Number.isNaN(" + inputVar + ")");
  }
  if (isLiteral(schema)) {
    return inputVar + eq + inlineConst(b, schema);
  }
  if (tagFlag & 4) {
    return "typeof " + inputVar + eq + "\"" + tag + "\"";
  }
  if (tagFlag & 64) {
    return "typeof " + inputVar + eq + "\"" + tag + "\"" + and_ + exp + inputVar;
  }
  if (tagFlag & 128) {
    return exp + "Array.isArray(" + inputVar + ")";
  }
  if (!(tagFlag & 8192)) {
    return "typeof " + inputVar + eq + "\"" + tag + "\"";
  }
  let c = inputVar + " instanceof " + embed(b, schema.class);
  if (negative) {
    return "!(" + c + ")";
  } else {
    return c;
  }
}

function refinement(b, inputVar, schema, negative) {
  let eq = negative ? "!==" : "===";
  let and_ = negative ? "||" : "&&";
  let not_ = negative ? "" : "!";
  let lt = negative ? ">" : "<";
  let gt = negative ? "<" : ">";
  let match = schema.type;
  let tag;
  let exit = 0;
  let match$1 = schema.const;
  if (match$1 !== undefined) {
    return "";
  }
  let match$2 = schema.format;
  if (match$2 !== undefined) {
    switch (match$2) {
      case "int32" :
        return and_ + inputVar + lt + "2147483647" + and_ + inputVar + gt + "-2147483648" + and_ + inputVar + "%1" + eq + "0";
      case "port" :
      case "json" :
        exit = 2;
        break;
    }
  } else {
    exit = 2;
  }
  if (exit === 2) {
    switch (match) {
      case "number" :
        if (globalConfig.n) {
          return "";
        } else {
          return and_ + not_ + "Number.isNaN(" + inputVar + ")";
        }
      case "array" :
      case "object" :
        tag = match;
        break;
      default:
        return "";
    }
  }
  let additionalItems = schema.additionalItems;
  let items = schema.items;
  let length = items.length;
  let code = tag === "array" ? (
      additionalItems === "strip" || additionalItems === "strict" ? (
          additionalItems === "strip" ? and_ + inputVar + ".length" + gt + length : and_ + inputVar + ".length" + eq + length
        ) : ""
    ) : (
      additionalItems === "strip" ? "" : and_ + not_ + "Array.isArray(" + inputVar + ")"
    );
  for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
    let match$3 = items[idx];
    let location = match$3.location;
    let item = match$3.schema;
    let itemCode;
    if (isLiteral(item) || schema.unnest) {
      let inlinedLocation = inlineLocation(b, location);
      itemCode = validation(b, inputVar + ("[" + inlinedLocation + "]"), item, negative);
    } else if (item.items) {
      let inlinedLocation$1 = inlineLocation(b, location);
      let inputVar$1 = inputVar + ("[" + inlinedLocation$1 + "]");
      itemCode = validation(b, inputVar$1, item, negative) + refinement(b, inputVar$1, item, negative);
    } else {
      itemCode = "";
    }
    if (itemCode !== "") {
      code = code + and_ + itemCode;
    }
    
  }
  return code;
}

function makeRefinedOf(b, input, schema) {
  let mut = {
    b: b,
    v: input.v,
    i: input.i,
    f: input.f,
    type: schema.type
  };
  let loop = (mut, schema) => {
    if (isLiteral(schema)) {
      mut.const = schema.const;
    }
    let items = schema.items;
    if (items === undefined) {
      return;
    }
    let properties = {};
    items.forEach(item => {
      let schema = item.schema;
      let isConst = isLiteral(schema);
      if (!(isConst || schema.items)) {
        return;
      }
      let tmp;
      if (isConst) {
        tmp = inlineConst(b, schema);
      } else {
        let inlinedLocation = inlineLocation(b, item.location);
        tmp = mut.v(b) + ("[" + inlinedLocation + "]");
      }
      let mut$1 = {
        b: mut.b,
        v: _notVar,
        i: tmp,
        f: 0,
        type: schema.type
      };
      loop(mut$1, schema);
      properties[item.location] = mut$1;
    });
    mut.properties = properties;
    mut.additionalItems = unknown;
  };
  loop(mut, schema);
  return mut;
}

function typeFilterCode(b, schema, input, path) {
  if (schema.noValidation || flags[schema.type] & 17153) {
    return "";
  }
  let inputVar = input.v(b);
  return "if(" + validation(b, inputVar, schema, true) + refinement(b, inputVar, schema, true) + "){" + failWithArg(b, path, input => ({
    TAG: "InvalidType",
    expected: schema,
    received: input
  }), inputVar) + "}";
}

function unsupportedTransform(b, from, target, path) {
  return $$throw(b, {
    TAG: "UnsupportedTransformation",
    from: from,
    to: target
  }, path);
}

function noopOperation(i) {
  return i;
}

function setHas(has, tag) {
  has[tag === "union" || tag === "ref" ? "unknown" : tag] = true;
}

let jsonName = "JSON";

function inputToString(b, input) {
  return val(b, "\"\"+" + input.i, string);
}

function parse(prevB, schema, inputArg, path) {
  let b = {
    c: "",
    l: "",
    a: initialAllocate,
    f: "",
    g: prevB.g
  };
  if (schema.$defs) {
    b.g.d = schema.$defs;
  }
  let input = inputArg;
  let isFromLiteral = isLiteral(input);
  let isSchemaLiteral = isLiteral(schema);
  let isSameTag = input.type === schema.type;
  let schemaTagFlag = flags[schema.type];
  let inputTagFlag = flags[input.type];
  let isUnsupported = false;
  if (!(schemaTagFlag & 257 || schema.format === "json")) {
    if (schema.name === jsonName && !(inputTagFlag & 1)) {
      if (!(inputTagFlag & 14)) {
        if (inputTagFlag & 1024) {
          input = inputToString(b, input);
        } else {
          isUnsupported = true;
        }
      }
      
    } else if (isSchemaLiteral) {
      if (isFromLiteral) {
        if (input.const !== schema.const) {
          input = constVal(b, schema);
        }
        
      } else if (inputTagFlag & 2 && schemaTagFlag & 3132) {
        let inputVar = input.v(b);
        b.f = schema.noValidation ? "" : input.i + "===\"" + schema.const + "\"||" + failWithArg(b, path, input => ({
            TAG: "InvalidType",
            expected: schema,
            received: input
          }), inputVar) + ";";
        input = constVal(b, schema);
      } else if (schema.noValidation) {
        input = constVal(b, schema);
      } else {
        b.f = typeFilterCode(prevB, schema, input, path);
        input.type = schema.type;
        input.const = schema.const;
      }
    } else if (isFromLiteral && !isSchemaLiteral) {
      if (!isSameTag) {
        if (schemaTagFlag & 2 && inputTagFlag & 3132) {
          let $$const = (""+input.const);
          input = {
            b: b,
            v: _notVar,
            i: "\"" + $$const + "\"",
            f: 0,
            type: "string",
            const: $$const
          };
        } else {
          isUnsupported = true;
        }
      }
      
    } else if (inputTagFlag & 1) {
      let ref = schema.$ref;
      if (ref !== undefined) {
        let defs = b.g.d;
        let identifier = ref.slice(8);
        let def = defs[identifier];
        let flag = schema.noValidation ? (b.g.o | 1) ^ 1 : b.g.o;
        let fn = def[flag];
        let recOperation;
        if (fn !== undefined) {
          let fn$1 = Primitive_option.valFromOption(fn);
          recOperation = fn$1 === 0 ? embed(b, def) + ("[" + flag + "]") : embed(b, fn$1);
        } else {
          def[flag] = 0;
          let fn$2 = internalCompile(def, flag, b.g.d);
          def[flag] = fn$2;
          recOperation = embed(b, fn$2);
        }
        input = withPathPrepend(b, input, path, undefined, undefined, (param, input, param$1) => {
          let output = map(recOperation, input);
          if (def.isAsync === undefined) {
            let defsMut = copy(defs);
            defsMut[identifier] = unknown;
            isAsyncInternal(def, defsMut);
          }
          if (def.isAsync) {
            output.f = output.f | 2;
          }
          return output;
        });
        input.v(b);
      } else {
        if (b.g.o & 1) {
          b.f = typeFilterCode(prevB, schema, input, path);
        }
        let refined = makeRefinedOf(b, input, schema);
        input.type = refined.type;
        input.i = refined.i;
        input.v = refined.v;
        input.additionalItems = refined.additionalItems;
        input.properties = refined.properties;
        if (isLiteral(refined)) {
          input.const = refined.const;
        }
        
      }
    } else if (schemaTagFlag & 2 && inputTagFlag & 1036) {
      input = inputToString(b, input);
    } else if (!isSameTag) {
      if (inputTagFlag & 2) {
        let inputVar$1 = input.v(b);
        if (schemaTagFlag & 8) {
          let output = allocateVal(b, schema);
          b.c = b.c + ("(" + output.i + "=" + inputVar$1 + "===\"true\")||" + inputVar$1 + "===\"false\"||" + failWithArg(b, path, input => ({
            TAG: "InvalidType",
            expected: schema,
            received: input
          }), inputVar$1) + ";");
          input = output;
        } else if (schemaTagFlag & 4) {
          let output$1 = val(b, "+" + inputVar$1, schema);
          let outputVar = output$1.v(b);
          let match = schema.format;
          b.c = b.c + (
            match !== undefined ? "(" + refinement(b, outputVar, schema, true).slice(2) + ")" : "Number.isNaN(" + outputVar + ")"
          ) + ("&&" + failWithArg(b, path, input => ({
            TAG: "InvalidType",
            expected: schema,
            received: input
          }), inputVar$1) + ";");
          input = output$1;
        } else if (schemaTagFlag & 1024) {
          let output$2 = allocateVal(b, schema);
          b.c = b.c + ("try{" + output$2.i + "=BigInt(" + inputVar$1 + ")}catch(_){" + failWithArg(b, path, input => ({
            TAG: "InvalidType",
            expected: schema,
            received: input
          }), inputVar$1) + "}");
          input = output$2;
        } else {
          isUnsupported = true;
        }
      } else if (inputTagFlag & 4 && schemaTagFlag & 1024) {
        input = val(b, "BigInt(" + input.i + ")", schema);
      } else {
        isUnsupported = true;
      }
    }
    
  }
  if (isUnsupported) {
    unsupportedTransform(b, input, schema, path);
  }
  let refiner = schema.refiner;
  if (refiner !== undefined) {
    input = refiner(b, input, schema, path);
  }
  let to = schema.to;
  if (to !== undefined) {
    let parser = schema.parser;
    if (parser !== undefined) {
      input = parser(b, input, schema, path);
    }
    if (input.t !== true) {
      input = parse(b, to, input, path);
    }
    
  }
  prevB.c = prevB.c + allocateScope(b);
  return input;
}

function getOutputSchema(_schema) {
  while (true) {
    let schema = _schema;
    let to = schema.to;
    if (to === undefined) {
      return schema;
    }
    _schema = to;
    continue;
  };
}

function reverse(schema) {
  let reversedHead;
  let current = schema;
  while (current) {
    let mut = copyWithoutCache(current);
    let next = mut.to;
    let to = reversedHead;
    if (to !== undefined) {
      mut.to = to;
    } else {
      ((delete mut.to));
    }
    let parser = mut.parser;
    let serializer = mut.serializer;
    if (serializer !== undefined) {
      mut.parser = serializer;
    } else {
      ((delete mut.parser));
    }
    if (parser !== undefined) {
      mut.serializer = parser;
    } else {
      ((delete mut.serializer));
    }
    let fromDefault = mut.fromDefault;
    let $$default = mut.default;
    if ($$default !== undefined) {
      mut.fromDefault = $$default;
    } else {
      ((delete mut.fromDefault));
    }
    if (fromDefault !== undefined) {
      mut.default = fromDefault;
    } else {
      ((delete mut.default));
    }
    let items = mut.items;
    if (items !== undefined) {
      let properties = {};
      let newItems = new Array(items.length);
      for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
        let item = items[idx];
        let reversed_schema = reverse(item.schema);
        let reversed_location = item.location;
        let reversed = {
          schema: reversed_schema,
          location: reversed_location
        };
        if (item.r) {
          reversed.r = item.r;
        }
        properties[item.location] = reversed_schema;
        newItems[idx] = reversed;
      }
      mut.items = newItems;
      let match = mut.properties;
      if (match !== undefined) {
        mut.properties = properties;
      }
      
    }
    if (typeof mut.additionalItems === "object") {
      mut.additionalItems = reverse(mut.additionalItems);
    }
    let anyOf = mut.anyOf;
    if (anyOf !== undefined) {
      let has = {};
      let newAnyOf = [];
      for (let idx$1 = 0, idx_finish$1 = anyOf.length; idx$1 < idx_finish$1; ++idx$1) {
        let s = anyOf[idx$1];
        let reversed$1 = reverse(s);
        newAnyOf.push(reversed$1);
        setHas(has, reversed$1.type);
      }
      mut.has = has;
      mut.anyOf = newAnyOf;
    }
    let defs = mut.$defs;
    if (defs !== undefined) {
      let reversedDefs = {};
      for (let idx$2 = 0, idx_finish$2 = Object.keys(defs).length; idx$2 < idx_finish$2; ++idx$2) {
        let key = Object.keys(defs)[idx$2];
        reversedDefs[key] = reverse(defs[key]);
      }
      mut.$defs = reversedDefs;
    }
    reversedHead = mut;
    current = next;
  };
  return reversedHead;
}

function jsonableValidation(output, parent, path, flag) {
  let tagFlag = flags[output.type];
  if (tagFlag & 48129 || tagFlag & 16 && parent.type !== "object") {
    throw new SuryError({
      TAG: "InvalidJsonSchema",
      _0: parent
    }, flag, path);
  }
  if (tagFlag & 256) {
    output.anyOf.forEach(s => jsonableValidation(s, parent, path, flag));
    return;
  }
  if (!(tagFlag & 192)) {
    return;
  }
  let additionalItems = output.additionalItems;
  if (additionalItems === "strip" || additionalItems === "strict") {
    additionalItems === "strip";
  } else {
    jsonableValidation(additionalItems, parent, path, flag);
  }
  let p = output.properties;
  if (p !== undefined) {
    let keys = Object.keys(p);
    for (let idx = 0, idx_finish = keys.length; idx < idx_finish; ++idx) {
      let key = keys[idx];
      jsonableValidation(p[key], parent, path, flag);
    }
    return;
  }
  output.items.forEach(item => jsonableValidation(item.schema, output, path + ("[" + fromString(item.location) + "]"), flag));
}

function isAsyncInternal(schema, defs) {
  try {
    let b = rootScope(2, defs);
    let input = {
      b: b,
      v: _var,
      i: "i",
      f: 0,
      type: "unknown"
    };
    let output = parse(b, schema, input, "");
    let isAsync = has(output.f, 2);
    schema.isAsync = isAsync;
    return isAsync;
  } catch (exn) {
    getOrRethrow(exn);
    return false;
  }
}

function internalCompile(schema, flag, defs) {
  let b = rootScope(flag, defs);
  if (flag & 8) {
    let output = reverse(schema);
    jsonableValidation(output, output, "", flag);
  }
  let input = {
    b: b,
    v: _var,
    i: "i",
    f: 0,
    type: "unknown"
  };
  let schema$1 = flag & 4 ? updateOutput(schema, mut => {
      let t = new Schema(unit.type);
      t.const = unit.const;
      t.noValidation = true;
      mut.to = t;
    }) : schema;
  let output$1 = parse(b, schema$1, input, "");
  let code = allocateScope(b);
  let isAsync = has(output$1.f, 2);
  schema$1.isAsync = isAsync;
  if (code === "" && output$1 === input && !(flag & 18)) {
    return noopOperation;
  }
  let inlinedOutput = output$1.i;
  if (flag & 16) {
    inlinedOutput = "JSON.stringify(" + inlinedOutput + ")";
  }
  if (flag & 2 && !isAsync && !defs) {
    inlinedOutput = "Promise.resolve(" + inlinedOutput + ")";
  }
  let inlinedFunction = "i=>{" + code + "return " + inlinedOutput + "}";
  let ctxVarValue1 = b.g.e;
  return new Function("e", "s", "return " + inlinedFunction)(ctxVarValue1, s);
}

function operationFn(s, o) {
  if ((o in s)) {
    return (s[o]);
  }
  let f = internalCompile(o & 32 ? reverse(s) : s, o, 0);
  ((s[o] = f));
  return f;
}

d(sp, "~standard", {
  get: function () {
    let schema = this;
    return {
      version: 1,
      vendor: vendor,
      validate: input => {
        try {
          return {
            value: operationFn(schema, 1)(input)
          };
        } catch (exn) {
          let error = getOrRethrow(exn);
          return {
            issues: [{
                message: message(error),
                path: error.path === "" ? undefined : toArray(error.path)
              }]
          };
        }
      }
    };
  }
});

function compile(schema, input, output, mode, typeValidationOpt) {
  let typeValidation = typeValidationOpt !== undefined ? typeValidationOpt : true;
  let flag = 0;
  let exit = 0;
  switch (output) {
    case "Output" :
    case "Input" :
      exit = 1;
      break;
    case "Assert" :
      flag = flag | 4;
      break;
    case "Json" :
      flag = flag | 8;
      break;
    case "JsonString" :
      flag = flag | 24;
      break;
  }
  if (exit === 1 && output === input) {
    throw new Error("[Sury] Can't compile operation to converting value to self");
  }
  if (mode !== "Sync") {
    flag = flag | 2;
  }
  if (typeValidation) {
    flag = flag | 1;
  }
  if (input === "Output") {
    flag = flag | 32;
  }
  let fn = operationFn(schema, flag);
  if (input !== "JsonString") {
    return fn;
  }
  let flag$1 = flag;
  return jsonString => {
    try {
      return fn(JSON.parse(jsonString));
    } catch (exn) {
      throw new SuryError({
        TAG: "OperationFailed",
        _0: exn.message
      }, flag$1, "");
    }
  };
}

function parseOrThrow(any, schema) {
  return operationFn(schema, 1)(any);
}

function parseJsonStringOrThrow(jsonString, schema) {
  let tmp;
  try {
    tmp = JSON.parse(jsonString);
  } catch (exn) {
    throw new SuryError({
      TAG: "OperationFailed",
      _0: exn.message
    }, 1, "");
  }
  return parseOrThrow(tmp, schema);
}

function parseAsyncOrThrow(any, schema) {
  return operationFn(schema, 3)(any);
}

function convertOrThrow(input, schema) {
  return operationFn(schema, 0)(input);
}

function convertToJsonOrThrow(any, schema) {
  return operationFn(schema, 8)(any);
}

function convertToJsonStringOrThrow(input, schema) {
  return operationFn(schema, 24)(input);
}

function convertAsyncOrThrow(any, schema) {
  return operationFn(schema, 2)(any);
}

function reverseConvertOrThrow(value, schema) {
  return operationFn(schema, 32)(value);
}

function reverseConvertToJsonOrThrow(value, schema) {
  return operationFn(schema, 40)(value);
}

function reverseConvertToJsonStringOrThrow(value, schema, spaceOpt) {
  let space = spaceOpt !== undefined ? spaceOpt : 0;
  return JSON.stringify(reverseConvertToJsonOrThrow(value, schema), null, space);
}

function assertOrThrow(any, schema) {
  return operationFn(schema, 5)(any);
}

let $$null = new Schema("null");

$$null.const = null;

function parse$1(value) {
  if (value === null) {
    return $$null;
  }
  let $$typeof = typeof value;
  let schema;
  if ($$typeof === "object") {
    let i = new Schema("instance");
    i.class = value.constructor;
    schema = i;
  } else {
    schema = $$typeof === "undefined" ? unit : (
        $$typeof === "number" ? (
            Number.isNaN(value) ? new Schema("nan") : new Schema($$typeof)
          ) : new Schema($$typeof)
      );
  }
  schema.const = value;
  return schema;
}

function isAsync(schema) {
  let v = schema.isAsync;
  if (v !== undefined) {
    return v;
  } else {
    return isAsyncInternal(schema, 0);
  }
}

function wrapExnToFailure(exn) {
  if ((exn&&exn.s===s)) {
    return {
      success: false,
      error: exn
    };
  }
  throw exn;
}

function js_safe(fn) {
  try {
    return {
      success: true,
      value: fn()
    };
  } catch (exn) {
    return wrapExnToFailure(exn);
  }
}

function js_safeAsync(fn) {
  try {
    return fn().then(value => ({
      success: true,
      value: value
    }), wrapExnToFailure);
  } catch (exn) {
    return Promise.resolve(wrapExnToFailure(exn));
  }
}

function make$1(namespace, name) {
  return "m:" + namespace + ":" + name;
}

function internal(name) {
  return "m:" + name;
}

let Id = {
  make: make$1,
  internal: internal
};

function get$1(schema, id) {
  return schema[id];
}

function set$1(schema, id, metadata) {
  let mut = copyWithoutCache(schema);
  mut[id] = metadata;
  return mut;
}

let defsPath = "#/$defs/";

function recursive(name, fn) {
  let ref = defsPath + name;
  let refSchema = new Schema("ref");
  refSchema.$ref = ref;
  refSchema.name = name;
  let isNestedRec = globalConfig.d;
  if (!isNestedRec) {
    globalConfig.d = {};
  }
  let def = fn(refSchema);
  if (def.name) {
    refSchema.name = def.name;
  } else {
    def.name = name;
  }
  globalConfig.d[name] = def;
  if (isNestedRec) {
    return refSchema;
  }
  let schema = new Schema("ref");
  schema.name = def.name;
  schema.$ref = ref;
  schema.$defs = globalConfig.d;
  globalConfig.d = undefined;
  return schema;
}

function noValidation(schema, value) {
  let mut = copyWithoutCache(schema);
  mut.noValidation = value;
  return mut;
}

function internalRefine(schema, refiner) {
  return updateOutput(schema, mut => {
    let prevRefiner = mut.refiner;
    mut.refiner = (b, input, selfSchema, path) => transform(b, prevRefiner !== undefined ? prevRefiner(b, input, selfSchema, path) : input, (b, input) => {
      let rCode = refiner(b, input.v(b), selfSchema, path);
      b.c = b.c + rCode;
      return input;
    });
  });
}

function refine(schema, refiner) {
  return internalRefine(schema, (b, inputVar, selfSchema, path) => embed(b, refiner(effectCtx(b, selfSchema, path))) + "(" + inputVar + ");");
}

function addRefinement(schema, metadataId, refinement, refiner) {
  let refinements = schema[metadataId];
  return internalRefine(set$1(schema, metadataId, refinements !== undefined ? refinements.concat(refinement) : [refinement]), refiner);
}

function transform$1(schema, transformer) {
  return updateOutput(schema, mut => {
    mut.parser = (b, input, selfSchema, path) => {
      let match = transformer(effectCtx(b, selfSchema, path));
      let parser = match.p;
      if (parser !== undefined) {
        if (match.a !== undefined) {
          return invalidOperation(b, path, "The S.transform doesn't allow parser and asyncParser at the same time. Remove parser in favor of asyncParser");
        } else {
          return embedSyncOperation(b, input, parser);
        }
      }
      let asyncParser = match.a;
      if (asyncParser !== undefined) {
        if (!(b.g.o & 2)) {
          $$throw(b, "UnexpectedAsync", "");
        }
        let val = embedSyncOperation(b, input, asyncParser);
        val.f = val.f | 2;
        return val;
      } else if (match.s !== undefined) {
        return invalidOperation(b, path, "The S.transform parser is missing");
      } else {
        return input;
      }
    };
    let to = new Schema("unknown");
    mut.to = (to.serializer = (b, input, selfSchema, path) => {
      let match = transformer(effectCtx(b, selfSchema, path));
      let serializer = match.s;
      if (serializer !== undefined) {
        return embedSyncOperation(b, input, serializer);
      } else if (match.a !== undefined || match.p !== undefined) {
        return invalidOperation(b, path, "The S.transform serializer is missing");
      } else {
        return input;
      }
    }, to);
    ((delete mut.isAsync));
  });
}

let nullAsUnit = new Schema("null");

nullAsUnit.const = null;

nullAsUnit.to = unit;

function neverBuilder(b, input, selfSchema, path) {
  b.c = b.c + failWithArg(b, path, input => ({
    TAG: "InvalidType",
    expected: selfSchema,
    received: input
  }), input.i) + ";";
  return input;
}

let never = new Schema("never");

never.refiner = neverBuilder;

function getItemCode(b, schema, input, output, deopt, path) {
  try {
    let globalFlag = b.g.o;
    if (deopt) {
      b.g.o = globalFlag | 1;
    }
    let bb = {
      c: "",
      l: "",
      a: initialAllocate,
      f: "",
      g: b.g
    };
    let input$1 = deopt ? copy(input) : makeRefinedOf(bb, input, schema);
    let itemOutput = parse(bb, schema, input$1, path);
    if (itemOutput !== input$1) {
      itemOutput.b = bb;
      if (itemOutput.f & 2) {
        output.f = output.f | 2;
      }
      bb.c = bb.c + (output.v(b) + "=" + itemOutput.i);
    }
    b.g.o = globalFlag;
    return allocateScope(bb);
  } catch (exn) {
    return "throw " + embed(b, getOrRethrow(exn));
  }
}

function isPriority(tagFlag, byKey) {
  if (tagFlag & 8320 && byKey["object"]) {
    return true;
  } else if (tagFlag & 2048) {
    return byKey["number"];
  } else {
    return false;
  }
}

function isWiderUnionSchema(schemaAnyOf, inputAnyOf) {
  return inputAnyOf.every((inputSchema, idx) => {
    let schema = schemaAnyOf[idx];
    if (schema !== undefined && !(flags[inputSchema.type] & 9152) && inputSchema.type === schema.type) {
      return inputSchema.const === schema.const;
    } else {
      return false;
    }
  });
}

function refiner(b, input, selfSchema, path) {
  let schemas = selfSchema.anyOf;
  let inputAnyOf = input.anyOf;
  if (inputAnyOf !== undefined) {
    if (isWiderUnionSchema(schemas, inputAnyOf)) {
      return input;
    } else {
      return unsupportedTransform(b, input, selfSchema, path);
    }
  }
  let fail = caught => embed(b, function () {
    let args = arguments;
    return $$throw(b, {
      TAG: "InvalidType",
      expected: selfSchema,
      received: args[0],
      unionErrors: args.length > 1 ? Array.from(args).slice(1) : undefined
    }, path);
  }) + "(" + input.v(b) + caught + ")";
  let typeValidation = b.g.o & 1;
  let initialInline = input.i;
  let deoptIdx = -1;
  let lastIdx = schemas.length - 1 | 0;
  let byKey = {};
  let keys = [];
  for (let idx = 0; idx <= lastIdx; ++idx) {
    let target = selfSchema.to;
    let schema = target !== undefined && !selfSchema.parser && target.type !== "union" ? updateOutput(schemas[idx], mut => {
        mut.to = target;
      }) : schemas[idx];
    let tag = schema.type;
    let tagFlag = flags[tag];
    if (!(tagFlag & 16 && selfSchema["fromDefault"])) {
      if (tagFlag & 17153 || !(flags[input.type] & 1) && input.type !== tag) {
        deoptIdx = idx;
        byKey = {};
        keys = [];
      } else {
        let key = tagFlag & 8192 ? schema.class.name : tag;
        let arr = byKey[key];
        if (arr !== undefined) {
          if (!(tagFlag & 2096)) {
            arr.push(schema);
          }
          
        } else {
          if (isPriority(tagFlag, byKey)) {
            keys.unshift(key);
          } else {
            keys.push(key);
          }
          byKey[key] = [schema];
        }
      }
    }
    
  }
  let deoptIdx$1 = deoptIdx;
  let byKey$1 = byKey;
  let keys$1 = keys;
  let start = "";
  let end = "";
  let caught = "";
  let exit = false;
  if (deoptIdx$1 !== -1) {
    for (let idx$1 = 0; idx$1 <= deoptIdx$1; ++idx$1) {
      if (!exit) {
        let schema$1 = schemas[idx$1];
        let itemCode = getItemCode(b, schema$1, input, input, true, path);
        if (itemCode) {
          let errorVar = "e" + idx$1;
          start = start + ("try{" + itemCode + "}catch(" + errorVar + "){");
          end = "}" + end;
          caught = caught + "," + errorVar;
        } else {
          exit = true;
        }
      }
      
    }
  }
  if (!exit) {
    let nextElse = false;
    let noop = "";
    for (let idx$2 = 0, idx_finish = keys$1.length; idx$2 < idx_finish; ++idx$2) {
      let schemas$1 = byKey$1[keys$1[idx$2]];
      let isMultiple = schemas$1.length > 1;
      let firstSchema = schemas$1[0];
      let cond = 0;
      let body;
      if (isMultiple) {
        let inputVar = input.v(b);
        let itemStart = "";
        let itemEnd = "";
        let itemNextElse = false;
        let itemNoop = {
          contents: ""
        };
        let caught$1 = "";
        let byDiscriminant = {};
        let itemIdx = 0;
        let lastIdx$1 = schemas$1.length - 1 | 0;
        while (itemIdx <= lastIdx$1) {
          let schema$2 = schemas$1[itemIdx];
          let itemCond = (
            isLiteral(schema$2) ? validation(b, inputVar, schema$2, false) : ""
          ) + refinement(b, inputVar, schema$2, false).slice(2);
          let itemCode$1 = getItemCode(b, schema$2, input, input, false, path);
          if (itemCond) {
            if (itemCode$1) {
              let match = byDiscriminant[itemCond];
              if (match !== undefined) {
                if (typeof match === "string") {
                  byDiscriminant[itemCond] = [
                    match,
                    itemCode$1
                  ];
                } else {
                  match.push(itemCode$1);
                }
              } else {
                byDiscriminant[itemCond] = itemCode$1;
              }
            } else {
              itemNoop.contents = itemNoop.contents ? itemNoop.contents + "||" + itemCond : itemCond;
            }
          }
          if (!itemCond || itemIdx === lastIdx$1) {
            let accedDiscriminants = Object.keys(byDiscriminant);
            for (let idx$3 = 0, idx_finish$1 = accedDiscriminants.length; idx$3 < idx_finish$1; ++idx$3) {
              let discrim = accedDiscriminants[idx$3];
              let if_ = itemNextElse ? "else if" : "if";
              itemStart = itemStart + if_ + ("(" + discrim + "){");
              let code = byDiscriminant[discrim];
              if (typeof code === "string") {
                itemStart = itemStart + code + "}";
              } else {
                let caught$2 = "";
                for (let idx$4 = 0, idx_finish$2 = code.length; idx$4 < idx_finish$2; ++idx$4) {
                  let code$1 = code[idx$4];
                  let errorVar$1 = "e" + idx$4;
                  itemStart = itemStart + ("try{" + code$1 + "}catch(" + errorVar$1 + "){");
                  caught$2 = caught$2 + "," + errorVar$1;
                }
                itemStart = itemStart + fail(caught$2) + "}".repeat(code.length) + "}";
              }
              itemNextElse = true;
            }
            byDiscriminant = {};
          }
          if (!itemCond) {
            if (itemCode$1) {
              if (itemNoop.contents) {
                let if_$1 = itemNextElse ? "else if" : "if";
                itemStart = itemStart + if_$1 + ("(!(" + itemNoop.contents + ")){");
                itemEnd = "}" + itemEnd;
                itemNoop.contents = "";
                itemNextElse = false;
              }
              let errorVar$2 = "e" + itemIdx;
              itemStart = itemStart + ((
                itemNextElse ? "else{" : ""
              ) + "try{" + itemCode$1 + "}catch(" + errorVar$2 + "){");
              itemEnd = (
                itemNextElse ? "}" : ""
              ) + "}" + itemEnd;
              caught$1 = caught$1 + "," + errorVar$2;
              itemNextElse = false;
            } else {
              itemNoop.contents = "";
              itemIdx = lastIdx$1;
            }
          }
          itemIdx = itemIdx + 1;
        };
        cond = inputVar => validation(b, inputVar, {
          type: firstSchema.type,
          parser: 0
        }, false);
        if (itemNoop.contents) {
          if (itemStart) {
            if (typeValidation) {
              let if_$2 = itemNextElse ? "else if" : "if";
              itemStart = itemStart + if_$2 + ("(!(" + itemNoop.contents + ")){" + fail(caught$1) + "}");
            }
            
          } else {
            let condBefore = cond;
            cond = inputVar => condBefore(inputVar) + ("&&(" + itemNoop.contents + ")");
          }
        } else if (typeValidation && itemStart) {
          let errorCode = fail(caught$1);
          itemStart = itemStart + (
            itemNextElse ? "else{" + errorCode + "}" : errorCode
          );
        }
        body = itemStart + itemEnd;
      } else {
        cond = inputVar => validation(b, inputVar, firstSchema, false) + refinement(b, inputVar, firstSchema, false);
        body = getItemCode(b, firstSchema, input, input, false, path);
      }
      if (body || isPriority(flags[firstSchema.type], byKey$1)) {
        let if_$3 = nextElse ? "else if" : "if";
        start = start + if_$3 + ("(" + cond(input.v(b)) + "){" + body + "}");
        nextElse = true;
      } else if (typeValidation) {
        let cond$1 = cond(input.v(b));
        noop = noop ? noop + "||" + cond$1 : cond$1;
      }
      
    }
    if (typeValidation || deoptIdx$1 === lastIdx) {
      let errorCode$1 = fail(caught);
      let tmp;
      if (noop) {
        let if_$4 = nextElse ? "else if" : "if";
        tmp = if_$4 + ("(!(" + noop + ")){" + errorCode$1 + "}");
      } else {
        tmp = nextElse ? "else{" + errorCode$1 + "}" : errorCode$1;
      }
      start = start + tmp;
    }
    
  }
  b.c = b.c + start + end;
  let o = input.f & 2 ? asyncVal(b, "Promise.resolve(" + input.i + ")") : (
      input.v === _var ? (
          b.c === "" && input.b.c === "" && (input.b.l === input.i + "=" + initialInline || initialInline === "i") ? (input.b.l = "", input.b.a = initialAllocate, input.v = _notVar, input.i = initialInline, input) : copy(input)
        ) : input
    );
  o.anyOf = selfSchema.anyOf;
  let to = selfSchema.to;
  o.type = to !== undefined && to.type !== "union" ? (o.t = true, getOutputSchema(to).type) : "union";
  return o;
}

function factory(schemas) {
  let len = schemas.length;
  if (len === 1) {
    return schemas[0];
  }
  if (len !== 0) {
    let has = {};
    let anyOf = new Set();
    for (let idx = 0, idx_finish = schemas.length; idx < idx_finish; ++idx) {
      let schema = schemas[idx];
      if (schema.type === "union" && schema.to === undefined) {
        schema.anyOf.forEach(item => {
          anyOf.add(item);
        });
        Object.assign(has, schema.has);
      } else {
        anyOf.add(schema);
        setHas(has, schema.type);
      }
    }
    let mut = new Schema("union");
    mut.anyOf = Array.from(anyOf);
    mut.refiner = refiner;
    mut.has = has;
    return mut;
  }
  throw new Error("[Sury] S.union requires at least one item");
}

let nestedLoc = "BS_PRIVATE_NESTED_SOME_NONE";

function nestedNone() {
  let itemSchema = parse$1(0);
  let item = {
    schema: itemSchema,
    location: nestedLoc
  };
  let properties = {};
  properties[nestedLoc] = itemSchema;
  return {
    type: "object",
    serializer: (b, param, selfSchema, param$1) => constVal(b, selfSchema.to),
    additionalItems: "strip",
    items: [item],
    properties: properties
  };
}

function parser(b, param, selfSchema, param$1) {
  return val(b, "{" + nestedLoc + ":" + getOutputSchema(selfSchema).items[0].schema.const + "}", selfSchema.to);
}

function nestedOption(item) {
  return updateOutput(item, mut => {
    mut.to = nestedNone();
    mut.parser = parser;
  });
}

function factory$1(item, unitOpt) {
  let unit$1 = unitOpt !== undefined ? unitOpt : unit;
  let match = getOutputSchema(item);
  let match$1 = match.type;
  switch (match$1) {
    case "undefined" :
      return factory([
        unit$1,
        nestedOption(item)
      ]);
    case "union" :
      let has = match.has;
      let anyOf = match.anyOf;
      return updateOutput(item, mut => {
        let mutHas = copy(has);
        let newAnyOf = [];
        for (let idx = 0, idx_finish = anyOf.length; idx < idx_finish; ++idx) {
          let schema = anyOf[idx];
          let match = getOutputSchema(schema);
          let match$1 = match.type;
          let tmp;
          if (match$1 === "undefined") {
            mutHas[unit$1.type] = true;
            newAnyOf.push(unit$1);
            tmp = nestedOption(schema);
          } else {
            let properties = match.properties;
            if (properties !== undefined) {
              let nestedSchema = properties[nestedLoc];
              tmp = nestedSchema !== undefined ? updateOutput(schema, mut => {
                  let newItem_schema = {
                    type: nestedSchema.type,
                    parser: nestedSchema.parser,
                    const: nestedSchema.const + 1
                  };
                  let newItem = {
                    schema: newItem_schema,
                    location: nestedLoc
                  };
                  let properties = {};
                  properties[nestedLoc] = newItem_schema;
                  mut.items = [newItem];
                  mut.properties = properties;
                }) : schema;
            } else {
              tmp = schema;
            }
          }
          newAnyOf.push(tmp);
        }
        if (newAnyOf.length === anyOf.length) {
          mutHas[unit$1.type] = true;
          newAnyOf.push(unit$1);
        }
        mut.anyOf = newAnyOf;
        mut.has = mutHas;
      });
    default:
      return factory([
        item,
        unit$1
      ]);
  }
}

function getWithDefault(schema, $$default) {
  return updateOutput(schema, mut => {
    let anyOf = mut.anyOf;
    if (anyOf !== undefined) {
      let item;
      let itemOutputSchema;
      for (let idx = 0, idx_finish = anyOf.length; idx < idx_finish; ++idx) {
        let schema = anyOf[idx];
        let outputSchema = getOutputSchema(schema);
        let match = outputSchema.type;
        if (match !== "undefined") {
          let match$1 = item;
          if (match$1 !== undefined) {
            let message = "Can't set default for " + toExpression(mut);
            throw new Error("[Sury] " + message);
          }
          item = schema;
          itemOutputSchema = outputSchema;
        }
        
      }
      let s = item;
      let item$1;
      if (s !== undefined) {
        item$1 = s;
      } else {
        let message$1 = "Can't set default for " + toExpression(mut);
        throw new Error("[Sury] " + message$1);
      }
      mut.parser = (b, input, selfSchema, param) => transform(b, input, (b, input) => {
        let inputVar = input.v(b);
        let tmp;
        tmp = $$default.TAG === "Value" ? inlineConst(b, parse$1($$default._0)) : embed(b, $$default._0) + "()";
        return val(b, inputVar + "===void 0?" + tmp + ":" + inputVar, selfSchema.to);
      });
      let to = copyWithoutCache(itemOutputSchema);
      let refiner = to.refiner;
      if (refiner !== undefined) {
        to.serializer = refiner;
        ((delete to.refiner));
      } else {
        to.serializer = (_b, input, param, param$1) => input;
      }
      mut.to = to;
      if ($$default.TAG !== "Value") {
        return;
      }
      try {
        mut.default = operationFn(item$1, 32)($$default._0);
        return;
      } catch (exn) {
        return;
      }
    } else {
      let message$2 = "Can't set default for " + toExpression(mut);
      throw new Error("[Sury] " + message$2);
    }
  });
}

function getOr(schema, defalutValue) {
  return getWithDefault(schema, {
    TAG: "Value",
    _0: defalutValue
  });
}

function getOrWith(schema, defalutCb) {
  return getWithDefault(schema, {
    TAG: "Callback",
    _0: defalutCb
  });
}

let metadataId = "m:Array.refinements";

function refinements(schema) {
  let m = schema[metadataId];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

function arrayRefiner(b, input, selfSchema, path) {
  let item = selfSchema.additionalItems;
  let inputVar = input.v(b);
  let iteratorVar = varWithoutAllocation(b.g);
  let bb = {
    c: "",
    l: "",
    a: initialAllocate,
    f: "",
    g: b.g
  };
  let itemInput = val(bb, inputVar + "[" + iteratorVar + "]", unknown);
  let itemOutput = withPathPrepend(bb, itemInput, path, iteratorVar, undefined, (b, input, path) => parse(b, item, input, path));
  let itemCode = allocateScope(bb);
  let isTransformed = itemInput !== itemOutput;
  let output = isTransformed ? val(b, "new Array(" + inputVar + ".length)", selfSchema) : input;
  output.type = selfSchema.type;
  output.additionalItems = selfSchema.additionalItems;
  if (isTransformed || itemCode !== "") {
    b.c = b.c + ("for(let " + iteratorVar + "=0;" + iteratorVar + "<" + inputVar + ".length;++" + iteratorVar + "){" + itemCode + (
      isTransformed ? addKey(b, output, iteratorVar, itemOutput) : ""
    ) + "}");
  }
  if (itemOutput.f & 2) {
    return asyncVal(output.b, "Promise.all(" + output.i + ")");
  } else {
    return output;
  }
}

function factory$2(item) {
  let mut = new Schema("array");
  mut.additionalItems = item;
  mut.items = immutableEmpty$1;
  mut.refiner = arrayRefiner;
  return mut;
}

function setAdditionalItems(schema, additionalItems, deep) {
  let currentAdditionalItems = schema.additionalItems;
  if (currentAdditionalItems === undefined) {
    return schema;
  }
  let items = schema.items;
  if (currentAdditionalItems === additionalItems || typeof currentAdditionalItems === "object") {
    return schema;
  }
  let mut = copyWithoutCache(schema);
  mut.additionalItems = additionalItems;
  if (deep) {
    let newItems = [];
    let newProperties = {};
    for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
      let item = items[idx];
      let newSchema = setAdditionalItems(item.schema, additionalItems, deep);
      let newItem = newSchema === item.schema ? item : ({
          schema: newSchema,
          location: item.location
        });
      newProperties[item.location] = newSchema;
      newItems.push(newItem);
    }
    mut.items = newItems;
    mut.properties = newProperties;
  }
  return mut;
}

function strip(schema) {
  return setAdditionalItems(schema, "strip", false);
}

function deepStrip(schema) {
  return setAdditionalItems(schema, "strip", true);
}

function strict(schema) {
  return setAdditionalItems(schema, "strict", false);
}

function deepStrict(schema) {
  return setAdditionalItems(schema, "strict", true);
}

function dictRefiner(b, input, selfSchema, path) {
  let item = selfSchema.additionalItems;
  let inputVar = input.v(b);
  let keyVar = varWithoutAllocation(b.g);
  let bb = {
    c: "",
    l: "",
    a: initialAllocate,
    f: "",
    g: b.g
  };
  let itemInput = val(bb, inputVar + "[" + keyVar + "]", unknown);
  let itemOutput = withPathPrepend(bb, itemInput, path, keyVar, undefined, (b, input, path) => parse(b, item, input, path));
  let itemCode = allocateScope(bb);
  let isTransformed = itemInput !== itemOutput;
  let output = isTransformed ? val(b, "{}", selfSchema) : input;
  output.type = selfSchema.type;
  output.additionalItems = selfSchema.additionalItems;
  if (isTransformed || itemCode !== "") {
    b.c = b.c + ("for(let " + keyVar + " in " + inputVar + "){" + itemCode + (
      isTransformed ? addKey(b, output, keyVar, itemOutput) : ""
    ) + "}");
  }
  if (!(itemOutput.f & 2)) {
    return output;
  }
  let resolveVar = varWithoutAllocation(b.g);
  let rejectVar = varWithoutAllocation(b.g);
  let asyncParseResultVar = varWithoutAllocation(b.g);
  let counterVar = varWithoutAllocation(b.g);
  let outputVar = output.v(b);
  return asyncVal(b, "new Promise((" + resolveVar + "," + rejectVar + ")=>{let " + counterVar + "=Object.keys(" + outputVar + ").length;for(let " + keyVar + " in " + outputVar + "){" + outputVar + "[" + keyVar + "].then(" + asyncParseResultVar + "=>{" + outputVar + "[" + keyVar + "]=" + asyncParseResultVar + ";if(" + counterVar + "--===1){" + resolveVar + "(" + outputVar + ")}}," + rejectVar + ")}})");
}

function factory$3(item) {
  let mut = new Schema("object");
  mut.properties = immutableEmpty;
  mut.items = immutableEmpty$1;
  mut.additionalItems = item;
  mut.refiner = dictRefiner;
  return mut;
}

let Tuple = {};

let metadataId$1 = "m:String.refinements";

function refinements$1(schema) {
  let m = schema[metadataId$1];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

let cuidRegex = /^c[^\s-]{8,}$/i;

let uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;

let emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;

let datetimeRe = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/;

let json = shaken("json");

function enableJson() {
  if (!json[shakenRef]) {
    return;
  }
  ((delete json.as));
  let jsonRef = new Schema("ref");
  jsonRef.$ref = defsPath + jsonName;
  jsonRef.name = jsonName;
  json.type = jsonRef.type;
  json.$ref = jsonRef.$ref;
  json.name = jsonName;
  let defs = {};
  defs[jsonName] = {
    type: "union",
    refiner: refiner,
    name: jsonName,
    has: {
      string: true,
      boolean: true,
      number: true,
      null: true,
      object: true,
      array: true
    },
    anyOf: [
      string,
      bool,
      float,
      $$null,
      factory$3(jsonRef),
      factory$2(jsonRef)
    ]
  };
  json.$defs = defs;
}

let jsonString = shaken("jsonString");

function inlineJsonString(b, schema, selfSchema, path) {
  let tagFlag = flags[schema.type];
  let $$const = schema.const;
  if (tagFlag & 48) {
    return "\"null\"";
  } else if (tagFlag & 2) {
    return JSON.stringify(fromString($$const));
  } else if (tagFlag & 1024) {
    return "\"\\\"" + $$const + "\\\"\"";
  } else if (tagFlag & 12) {
    return "\"" + $$const + "\"";
  } else {
    return unsupportedTransform(b, schema, selfSchema, path);
  }
}

function enableJsonString() {
  if (jsonString[shakenRef]) {
    ((delete jsonString.as));
    jsonString.type = "string";
    jsonString.format = "json";
    jsonString.name = jsonName + " string";
    jsonString.refiner = (b, inputArg, selfSchema, path) => {
      let inputTagFlag = flags[inputArg.type];
      let input = inputArg;
      if (inputTagFlag & 1) {
        let to = selfSchema.to;
        if (to && isLiteral(to)) {
          let inputVar = input.v(b);
          b.f = inputVar + "===" + inlineJsonString(b, to, selfSchema, path) + "||" + failWithArg(b, path, input => ({
            TAG: "InvalidType",
            expected: to,
            received: input
          }), inputVar) + ";";
          input = constVal(b, to);
        } else if (!(to && to.format === "json")) {
          let inputVar$1 = input.v(b);
          let withTypeValidation = b.g.o & 1;
          if (withTypeValidation) {
            b.f = typeFilterCode(b, string, input, path);
          }
          if (to || withTypeValidation) {
            let tmp;
            if (to) {
              jsonableValidation(to, to, path, b.g.o);
              let targetVal = allocateVal(b, unknown);
              input = targetVal;
              tmp = targetVal.i + "=";
            } else {
              tmp = "";
            }
            b.c = b.c + ("try{" + tmp + "JSON.parse(" + inputVar$1 + ")}catch(t){" + failWithArg(b, path, input => ({
              TAG: "InvalidType",
              expected: selfSchema,
              received: input
            }), inputVar$1) + "}");
          }
          
        }
        
      } else {
        if (isLiteral(input)) {
          input = val(b, inlineJsonString(b, input, selfSchema, path), string);
        } else if (inputTagFlag & 2) {
          if (input.format !== "json") {
            input = val(b, "JSON.stringify(" + input.i + ")", string);
          }
          
        } else if (inputTagFlag & 12) {
          input = inputToString(b, input);
        } else if (inputTagFlag & 1024) {
          input = val(b, "\"\\\"\"+" + input.i + "+\"\\\"\"", string);
        } else if (inputTagFlag & 192) {
          jsonableValidation(input, input, path, b.g.o);
          let v = selfSchema.space;
          input = val(b, "JSON.stringify(" + input.i + (
            v !== undefined && v !== 0 ? ",null," + v : ""
          ) + ")", string);
        } else {
          unsupportedTransform(b, input, selfSchema, path);
        }
        input.format = "json";
      }
      return input;
    };
    return;
  }
  
}

function jsonStringWithSpace(space) {
  let mut = copyWithoutCache(jsonString);
  mut.space = space;
  return mut;
}

let metadataId$2 = "m:Int.refinements";

function refinements$2(schema) {
  let m = schema[metadataId$2];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

let metadataId$3 = "m:Float.refinements";

function refinements$3(schema) {
  let m = schema[metadataId$3];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

function to(from, target) {
  if (from === target) {
    return from;
  } else {
    return updateOutput(from, mut => {
      mut.to = target;
    });
  }
}

function list(schema) {
  return transform$1(factory$2(schema), param => ({
    p: Belt_List.fromArray,
    s: Belt_List.toArray
  }));
}

function instance(class_) {
  let mut = new Schema("instance");
  mut.class = class_;
  return mut;
}

function meta(schema, data) {
  let mut = copyWithoutCache(schema);
  let name = data.name;
  if (name !== undefined) {
    if (name === "") {
      mut.name = undefined;
    } else {
      mut.name = name;
    }
  }
  let title = data.title;
  if (title !== undefined) {
    if (title === "") {
      mut.title = undefined;
    } else {
      mut.title = title;
    }
  }
  let description = data.description;
  if (description !== undefined) {
    if (description === "") {
      mut.description = undefined;
    } else {
      mut.description = description;
    }
  }
  let deprecated = data.deprecated;
  if (deprecated !== undefined) {
    mut.deprecated = deprecated;
  }
  let examples = data.examples;
  if (examples !== undefined) {
    if (examples.length !== 0) {
      mut.examples = examples.map(operationFn(schema, 32));
    } else {
      mut.examples = undefined;
    }
  }
  return mut;
}

function getFullDitemPath(ditem) {
  switch (ditem.k) {
    case 0 :
      return "[" + fromString(ditem.location) + "]";
    case 1 :
      return getFullDitemPath(ditem.of) + ditem.p;
    case 2 :
      return ditem.p;
  }
}

function definitionToOutput(b, definition, getItemOutput, outputSchema) {
  if (isLiteral(outputSchema)) {
    return constVal(b, outputSchema);
  }
  let item = definition[itemSymbol];
  if (item !== undefined) {
    return getItemOutput(item);
  }
  let isArray = flags[outputSchema.type] & 128;
  let objectVal = make(b, isArray);
  outputSchema.items.forEach(item => add(objectVal, item.location, definitionToOutput(b, definition[item.location], getItemOutput, item.schema)));
  return complete(objectVal, isArray);
}

function objectStrictModeCheck(b, input, items, selfSchema, path) {
  if (!(selfSchema.type === "object" && selfSchema.additionalItems === "strict" && b.g.o & 1)) {
    return;
  }
  let key = allocateVal(b, unknown);
  let keyVar = key.i;
  b.c = b.c + ("for(" + keyVar + " in " + input.v(b) + "){if(");
  if (items.length !== 0) {
    for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
      let match = items[idx];
      if (idx !== 0) {
        b.c = b.c + "&&";
      }
      b.c = b.c + (keyVar + "!==" + inlineLocation(b, match.location));
    }
  } else {
    b.c = b.c + "true";
  }
  b.c = b.c + ("){" + failWithArg(b, path, exccessFieldName => ({
    TAG: "ExcessField",
    _0: exccessFieldName
  }), keyVar) + "}}");
}

function proxify(item) {
  return new Proxy(immutableEmpty, {
    get: (param, prop) => {
      if (prop === itemSymbol) {
        return item;
      }
      let inlinedLocation = fromString(prop);
      let targetReversed = getOutputSchema(item.schema);
      let items = targetReversed.items;
      let properties = targetReversed.properties;
      let maybeField;
      if (properties !== undefined) {
        maybeField = properties[prop];
      } else if (items !== undefined) {
        let i = items[prop];
        maybeField = i !== undefined ? i.schema : undefined;
      } else {
        maybeField = undefined;
      }
      if (maybeField === undefined) {
        let message = "Cannot read property " + inlinedLocation + " of " + toExpression(targetReversed);
        throw new Error("[Sury] " + message);
      }
      return proxify({
        k: 1,
        location: prop,
        schema: maybeField,
        of: item,
        p: "[" + inlinedLocation + "]"
      });
    }
  });
}

function schemaRefiner(b, input, selfSchema, path) {
  let additionalItems = selfSchema.additionalItems;
  let items = selfSchema.items;
  let isArray = flags[selfSchema.type] & 128;
  if (b.g.o & 64) {
    let objectVal = make(b, isArray);
    for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
      let match = items[idx];
      let location = match.location;
      add(objectVal, location, input.properties[location]);
    }
    return complete(objectVal, isArray);
  }
  let objectVal$1 = make(b, isArray);
  for (let idx$1 = 0, idx_finish$1 = items.length; idx$1 < idx_finish$1; ++idx$1) {
    let match$1 = items[idx$1];
    let location$1 = match$1.location;
    let itemInput = get(b, input, location$1);
    let inlinedLocation = inlineLocation(b, location$1);
    let path$1 = path + ("[" + inlinedLocation + "]");
    add(objectVal$1, location$1, parse(b, match$1.schema, itemInput, path$1));
  }
  objectStrictModeCheck(b, input, items, selfSchema, path);
  if ((additionalItems !== "strip" || b.g.o & 32) && items.every(item => objectVal$1.properties[item.location] === input.properties[item.location])) {
    input.additionalItems = "strip";
    return input;
  } else {
    return complete(objectVal$1, isArray);
  }
}

function definitionToRitem(definition, path, ritemsByItemPath) {
  if (typeof definition !== "object" || definition === null) {
    return {
      k: 1,
      p: path,
      s: copyWithoutCache(parse$1(definition))
    };
  }
  let item = definition[itemSymbol];
  if (item !== undefined) {
    let ritemSchema = copyWithoutCache(getOutputSchema(item.schema));
    ((delete ritemSchema.serializer));
    let ritem = {
      k: 0,
      p: path,
      s: ritemSchema
    };
    item.r = ritem;
    ritemsByItemPath[getFullDitemPath(item)] = ritem;
    return ritem;
  }
  if (Array.isArray(definition)) {
    let items = [];
    for (let idx = 0, idx_finish = definition.length; idx < idx_finish; ++idx) {
      let location = idx.toString();
      let inlinedLocation = "\"" + location + "\"";
      let ritem$1 = definitionToRitem(definition[idx], path + ("[" + inlinedLocation + "]"), ritemsByItemPath);
      let item_schema = ritem$1.s;
      let item$1 = {
        schema: item_schema,
        location: location
      };
      items[idx] = item$1;
    }
    let mut = new Schema("array");
    return {
      k: 2,
      p: path,
      s: (mut.items = items, mut.additionalItems = "strict", mut.serializer = neverBuilder, mut)
    };
  }
  let fieldNames = Object.keys(definition);
  let properties = {};
  let items$1 = [];
  for (let idx$1 = 0, idx_finish$1 = fieldNames.length; idx$1 < idx_finish$1; ++idx$1) {
    let location$1 = fieldNames[idx$1];
    let inlinedLocation$1 = fromString(location$1);
    let ritem$2 = definitionToRitem(definition[location$1], path + ("[" + inlinedLocation$1 + "]"), ritemsByItemPath);
    let item_schema$1 = ritem$2.s;
    let item$2 = {
      schema: item_schema$1,
      location: location$1
    };
    items$1[idx$1] = item$2;
    properties[location$1] = item_schema$1;
  }
  let mut$1 = new Schema("object");
  return {
    k: 2,
    p: path,
    s: (mut$1.items = items$1, mut$1.properties = properties, mut$1.additionalItems = globalConfig.a, mut$1.serializer = neverBuilder, mut$1)
  };
}

function definitionToSchema(definition) {
  if (typeof definition !== "object" || definition === null) {
    return parse$1(definition);
  }
  if (definition["~standard"]) {
    return definition;
  }
  if (Array.isArray(definition)) {
    for (let idx = 0, idx_finish = definition.length; idx < idx_finish; ++idx) {
      let schema = definitionToSchema(definition[idx]);
      let location = idx.toString();
      definition[idx] = {
        schema: schema,
        location: location
      };
    }
    let mut = new Schema("array");
    mut.items = definition;
    mut.additionalItems = "strict";
    mut.refiner = schemaRefiner;
    return mut;
  }
  let cnstr = definition.constructor;
  if (cnstr && cnstr !== Object) {
    return {
      type: "instance",
      const: definition,
      class: cnstr
    };
  }
  let fieldNames = Object.keys(definition);
  let length = fieldNames.length;
  let items = [];
  for (let idx$1 = 0; idx$1 < length; ++idx$1) {
    let location$1 = fieldNames[idx$1];
    let schema$1 = definitionToSchema(definition[location$1]);
    let item = {
      schema: schema$1,
      location: location$1
    };
    definition[location$1] = schema$1;
    items[idx$1] = item;
  }
  let mut$1 = new Schema("object");
  mut$1.items = items;
  mut$1.properties = definition;
  mut$1.additionalItems = globalConfig.a;
  mut$1.refiner = schemaRefiner;
  return mut$1;
}

function nested(fieldName) {
  let parentCtx = this;
  let cacheId = "~" + fieldName;
  let ctx = parentCtx[cacheId];
  if (ctx !== undefined) {
    return Primitive_option.valFromOption(ctx);
  }
  let schemas = [];
  let properties = {};
  let items = [];
  let schema = new Schema("object");
  schema.items = items;
  schema.properties = properties;
  schema.additionalItems = globalConfig.a;
  schema.refiner = schemaRefiner;
  let target = parentCtx.f(fieldName, schema)[itemSymbol];
  let field = (fieldName, schema) => {
    let inlinedLocation = fromString(fieldName);
    if (properties[fieldName]) {
      throw new Error("[Sury] " + ("The field " + inlinedLocation + " defined twice"));
    }
    let ditem_3 = "[" + inlinedLocation + "]";
    let ditem = {
      k: 1,
      location: fieldName,
      schema: schema,
      of: target,
      p: ditem_3
    };
    properties[fieldName] = schema;
    items.push(ditem);
    schemas.push(schema);
    return proxify(ditem);
  };
  let tag = (tag$1, asValue) => {
    field(tag$1, definitionToSchema(asValue));
  };
  let fieldOr = (fieldName, schema, or) => {
    let schema$1 = factory$1(schema, undefined);
    return field(fieldName, getWithDefault(schema$1, {
      TAG: "Value",
      _0: or
    }));
  };
  let flatten = schema => {
    let match = schema.type;
    if (match === "object") {
      let to = schema.to;
      let flattenedItems = schema.items;
      if (to) {
        let message = "Unsupported nested flatten for transformed object schema " + toExpression(schema);
        throw new Error("[Sury] " + message);
      }
      let result = {};
      for (let idx = 0, idx_finish = flattenedItems.length; idx < idx_finish; ++idx) {
        let item = flattenedItems[idx];
        result[item.location] = field(item.location, item.schema);
      }
      return result;
    }
    let message$1 = "Can't flatten " + toExpression(schema) + " schema";
    throw new Error("[Sury] " + message$1);
  };
  let ctx$1 = {
    field: field,
    f: field,
    fieldOr: fieldOr,
    tag: tag,
    nested: nested,
    flatten: flatten
  };
  parentCtx[cacheId] = ctx$1;
  return ctx$1;
}

function definitionToTarget(definition, to, flattened) {
  let ritemsByItemPath = {};
  let ritem = definitionToRitem(definition, "", ritemsByItemPath);
  let mut = ritem.s;
  ((delete mut.refiner));
  mut.serializer = (b, input, selfSchema, path) => {
    let getRitemInput = ritem => {
      let ritemPath = ritem.p;
      if (ritemPath === "") {
        return input;
      }
      let _input = input;
      let _locations = toArray(ritemPath);
      while (true) {
        let locations = _locations;
        let input$1 = _input;
        if (locations.length === 0) {
          return input$1;
        }
        let location = locations[0];
        _locations = locations.slice(1);
        _input = get(b, input$1, location);
        continue;
      };
    };
    let schemaToOutput = (schema, originalPath) => {
      let outputSchema = getOutputSchema(schema);
      if (isLiteral(outputSchema)) {
        return constVal(b, outputSchema);
      }
      if (isLiteral(schema)) {
        return parse(b, schema, constVal(b, schema), path);
      }
      let tag = outputSchema.type;
      let additionalItems = outputSchema.additionalItems;
      let items = outputSchema.items;
      if (items !== undefined && typeof additionalItems === "string") {
        let isArray = flags[tag] & 128;
        let objectVal = make(b, isArray);
        for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
          let item = items[idx];
          let inlinedLocation = inlineLocation(b, item.location);
          let itemPath = originalPath + ("[" + inlinedLocation + "]");
          let ritem = ritemsByItemPath[itemPath];
          let itemInput = ritem !== undefined ? parse(b, item.schema, getRitemInput(ritem), ritem.p) : schemaToOutput(item.schema, itemPath);
          add(objectVal, item.location, itemInput);
        }
        return complete(objectVal, isArray);
      }
      let tmp = originalPath === "" ? "Schema isn't registered" : "Schema for " + originalPath + " isn't registered";
      return invalidOperation(b, path, tmp);
    };
    let getItemOutput = (item, itemPath, shouldReverse) => {
      let ritem = item.r;
      if (ritem === undefined) {
        return schemaToOutput(item.schema, itemPath);
      }
      let targetSchema = shouldReverse ? reverse(item.schema) : (
          itemPath === "" ? getOutputSchema(item.schema) : item.schema
        );
      let itemInput = getRitemInput(ritem);
      let path$1 = path + ritem.p;
      return parse(b, targetSchema, itemInput, path$1);
    };
    if (to !== undefined) {
      return getItemOutput(to, "", false);
    }
    let originalSchema = selfSchema.to;
    objectStrictModeCheck(b, input, selfSchema.items, selfSchema, path);
    let isArray = originalSchema.type === "array";
    let items = originalSchema.items;
    let objectVal = make(b, isArray);
    if (flattened !== undefined) {
      for (let idx = 0, idx_finish = flattened.length; idx < idx_finish; ++idx) {
        merge(objectVal, getItemOutput(flattened[idx], "", true));
      }
    }
    for (let idx$1 = 0, idx_finish$1 = items.length; idx$1 < idx_finish$1; ++idx$1) {
      let item = items[idx$1];
      if (!objectVal.properties[item.location]) {
        let inlinedLocation = inlineLocation(b, item.location);
        add(objectVal, item.location, getItemOutput(item, "[" + inlinedLocation + "]", false));
      }
      
    }
    return complete(objectVal, isArray);
  };
  return mut;
}

function advancedBuilder(definition, flattened) {
  return (b, input, selfSchema, path) => {
    let isFlatten = b.g.o & 64;
    let outputs = isFlatten ? input.properties : ({});
    if (!isFlatten) {
      let items = selfSchema.items;
      for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
        let match = items[idx];
        let location = match.location;
        let itemInput = get(b, input, location);
        let inlinedLocation = inlineLocation(b, location);
        let path$1 = path + ("[" + inlinedLocation + "]");
        outputs[location] = parse(b, match.schema, itemInput, path$1);
      }
      objectStrictModeCheck(b, input, items, selfSchema, path);
    }
    if (flattened !== undefined) {
      let prevFlag = b.g.o;
      b.g.o = prevFlag | 64;
      for (let idx$1 = 0, idx_finish$1 = flattened.length; idx$1 < idx_finish$1; ++idx$1) {
        let item = flattened[idx$1];
        outputs[item.i] = parse(b, item.schema, input, path);
      }
      b.g.o = prevFlag;
    }
    let getItemOutput = item => {
      switch (item.k) {
        case 0 :
          return outputs[item.location];
        case 1 :
          return get(b, getItemOutput(item.of), item.location);
        case 2 :
          return outputs[item.i];
      }
    };
    return definitionToOutput(b, definition, getItemOutput, selfSchema.to);
  };
}

function shape(schema, definer) {
  return updateOutput(schema, mut => {
    let ditem = {
      k: 2,
      schema: schema,
      p: "",
      i: 0
    };
    let definition = definer(proxify(ditem));
    mut.parser = (b, input, selfSchema, param) => {
      let getItemOutput = item => {
        switch (item.k) {
          case 1 :
            return get(b, getItemOutput(item.of), item.location);
          case 0 :
          case 2 :
            return input;
        }
      };
      return definitionToOutput(b, definition, getItemOutput, selfSchema.to);
    };
    mut.to = definitionToTarget(definition, ditem, undefined);
  });
}

function object(definer) {
  let flattened = (void 0);
  let items = [];
  let properties = {};
  let flatten = schema => {
    let match = schema.type;
    if (match === "object") {
      let flattenedItems = schema.items;
      for (let idx = 0, idx_finish = flattenedItems.length; idx < idx_finish; ++idx) {
        let match$1 = flattenedItems[idx];
        let location = match$1.location;
        let flattenedSchema = match$1.schema;
        let schema$1 = properties[location];
        if (schema$1 !== undefined) {
          if (schema$1 !== flattenedSchema) {
            throw new Error("[Sury] " + ("The field \"" + location + "\" defined twice with incompatible schemas"));
          }
          
        } else {
          let item = {
            k: 0,
            schema: flattenedSchema,
            location: location
          };
          items.push(item);
          properties[location] = flattenedSchema;
        }
      }
      let f = (flattened || (flattened = []));
      let item_2 = f.length;
      let item$1 = {
        k: 2,
        schema: schema,
        p: "",
        i: item_2
      };
      f.push(item$1);
      return proxify(item$1);
    }
    let message = "The '" + toExpression(schema) + "' schema can't be flattened";
    throw new Error("[Sury] " + message);
  };
  let field = (fieldName, schema) => {
    if (properties[fieldName]) {
      throw new Error("[Sury] " + ("The field \"" + fieldName + "\" defined twice with incompatible schemas"));
    }
    let ditem = {
      k: 0,
      schema: schema,
      location: fieldName
    };
    properties[fieldName] = schema;
    items.push(ditem);
    return proxify(ditem);
  };
  let tag = (tag$1, asValue) => {
    field(tag$1, definitionToSchema(asValue));
  };
  let fieldOr = (fieldName, schema, or) => {
    let schema$1 = factory$1(schema, undefined);
    return field(fieldName, getWithDefault(schema$1, {
      TAG: "Value",
      _0: or
    }));
  };
  let ctx = {
    field: field,
    f: field,
    fieldOr: fieldOr,
    tag: tag,
    nested: nested,
    flatten: flatten
  };
  let definition = definer(ctx);
  let mut = new Schema("object");
  mut.items = items;
  mut.properties = properties;
  mut.additionalItems = globalConfig.a;
  mut.parser = advancedBuilder(definition, flattened);
  mut.to = definitionToTarget(definition, undefined, flattened);
  return mut;
}

function tuple(definer) {
  let items = [];
  let item = (idx, schema) => {
    let location = idx.toString();
    if (items[idx]) {
      throw new Error("[Sury] " + ("The item [" + location + "] is defined multiple times"));
    }
    let ditem = {
      k: 0,
      schema: schema,
      location: location
    };
    items[idx] = ditem;
    return proxify(ditem);
  };
  let tag = (idx, asValue) => {
    item(idx, definitionToSchema(asValue));
  };
  let ctx = {
    item: item,
    tag: tag
  };
  let definition = definer(ctx);
  for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
    if (!items[idx]) {
      let location = idx.toString();
      let ditem = {
        schema: unit,
        location: location
      };
      items[idx] = ditem;
    }
    
  }
  let mut = new Schema("array");
  mut.items = items;
  mut.additionalItems = "strict";
  mut.parser = advancedBuilder(definition, undefined);
  mut.to = definitionToTarget(definition, undefined, undefined);
  return mut;
}

function matches(schema) {
  return schema;
}

let ctx = {
  m: matches
};

function factory$4(definer) {
  return definitionToSchema(definer(ctx));
}

function factory$5(item) {
  return factory$1(item, nullAsUnit);
}

let js_schema = definitionToSchema;

function $$enum(values) {
  return factory(values.map(js_schema));
}

function unnestSerializer(b, input, selfSchema, path) {
  let schema = selfSchema.additionalItems;
  let items = schema.items;
  let inputVar = input.v(b);
  let iteratorVar = varWithoutAllocation(b.g);
  let outputVar = varWithoutAllocation(b.g);
  let bb = {
    c: "",
    l: "",
    a: initialAllocate,
    f: "",
    g: b.g
  };
  let itemInput = {
    b: bb,
    v: _var,
    i: inputVar + "[" + iteratorVar + "]",
    f: 0,
    type: "unknown"
  };
  let itemOutput = withPathPrepend(bb, itemInput, path, iteratorVar, (bb, output) => {
    let initialArraysCode = "";
    let settingCode = "";
    for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
      let toItem = items[idx];
      initialArraysCode = initialArraysCode + ("new Array(" + inputVar + ".length),");
      settingCode = settingCode + (outputVar + "[" + idx + "][" + iteratorVar + "]=" + get(b, output, toItem.location).i + ";");
    }
    b.a(outputVar + "=[" + initialArraysCode + "]");
    bb.c = bb.c + settingCode;
  }, (b, input, path) => parse(b, schema, input, path));
  let itemCode = allocateScope(bb);
  b.c = b.c + ("for(let " + iteratorVar + "=0;" + iteratorVar + "<" + inputVar + ".length;++" + iteratorVar + "){" + itemCode + "}");
  if (itemOutput.f & 2) {
    return {
      b: b,
      v: _notVar,
      i: "Promise.all(" + outputVar + ")",
      f: 2,
      type: "array"
    };
  } else {
    return {
      b: b,
      v: _var,
      i: outputVar,
      f: 0,
      type: "array"
    };
  }
}

function unnest(schema) {
  if (schema.type === "object") {
    let items = schema.items;
    if (items.length === 0) {
      throw new Error("[Sury] Invalid empty object for S.unnest schema.");
    }
    let mut = new Schema("array");
    mut.items = items.map((item, idx) => {
      let location = idx.toString();
      return {
        schema: factory$2(item.schema),
        location: location
      };
    });
    mut.additionalItems = "strict";
    mut.parser = (b, input, selfSchema, path) => {
      let inputVar = input.v(b);
      let iteratorVar = varWithoutAllocation(b.g);
      let bb = {
        c: "",
        l: "",
        a: initialAllocate,
        f: "",
        g: b.g
      };
      let itemInput = make(bb, false);
      let lengthCode = "";
      for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
        let item = items[idx];
        add(itemInput, item.location, val(bb, inputVar + "[" + idx + "][" + iteratorVar + "]", unknown));
        lengthCode = lengthCode + (inputVar + "[" + idx + "].length,");
      }
      let output = val(b, "new Array(Math.max(" + lengthCode + "))", selfSchema.to);
      let outputVar = output.v(b);
      let itemOutput = withPathPrepend(bb, complete(itemInput, false), path, iteratorVar, (bb, itemOutput) => {
        bb.c = bb.c + addKey(bb, output, iteratorVar, itemOutput) + ";";
      }, (b, input, path) => parse(b, schema, input, path));
      let itemCode = allocateScope(bb);
      b.c = b.c + ("for(let " + iteratorVar + "=0;" + iteratorVar + "<" + outputVar + ".length;++" + iteratorVar + "){" + itemCode + "}");
      if (itemOutput.f & 2) {
        return asyncVal(output.b, "Promise.all(" + output.i + ")");
      } else {
        return output;
      }
    };
    let to = new Schema("array");
    to.items = immutableEmpty$1;
    to.additionalItems = schema;
    to.serializer = unnestSerializer;
    mut.unnest = true;
    mut.to = to;
    return mut;
  }
  throw new Error("[Sury] S.unnest supports only object schemas.");
}

function option(item) {
  return factory$1(item, unit);
}

function tuple1(v0) {
  return tuple(s => s.item(0, v0));
}

function tuple2(v0, v1) {
  return definitionToSchema([
    v0,
    v1
  ]);
}

function tuple3(v0, v1, v2) {
  return definitionToSchema([
    v0,
    v1,
    v2
  ]);
}

function intMin(schema, minValue, maybeMessage) {
  let message = maybeMessage !== undefined ? maybeMessage : "Number must be greater than or equal to " + minValue;
  return addRefinement(schema, metadataId$2, {
    kind: {
      TAG: "Min",
      value: minValue
    },
    message: message
  }, (b, inputVar, param, path) => "if(" + inputVar + "<" + embed(b, minValue) + "){" + fail(b, message, path) + "}");
}

function intMax(schema, maxValue, maybeMessage) {
  let message = maybeMessage !== undefined ? maybeMessage : "Number must be lower than or equal to " + maxValue;
  return addRefinement(schema, metadataId$2, {
    kind: {
      TAG: "Max",
      value: maxValue
    },
    message: message
  }, (b, inputVar, param, path) => "if(" + inputVar + ">" + embed(b, maxValue) + "){" + fail(b, message, path) + "}");
}

function port(schema, message) {
  let mutStandard = internalRefine(schema, (b, inputVar, selfSchema, path) => inputVar + ">0&&" + inputVar + "<65536&&" + inputVar + "%1===0||" + (
    message !== undefined ? fail(b, message, path) : failWithArg(b, path, input => ({
        TAG: "InvalidType",
        expected: selfSchema,
        received: input
      }), inputVar)
  ) + ";");
  mutStandard.format = "port";
  reverse(mutStandard).format = "port";
  return mutStandard;
}

function floatMin(schema, minValue, maybeMessage) {
  let message = maybeMessage !== undefined ? maybeMessage : "Number must be greater than or equal to " + minValue;
  return addRefinement(schema, metadataId$3, {
    kind: {
      TAG: "Min",
      value: minValue
    },
    message: message
  }, (b, inputVar, param, path) => "if(" + inputVar + "<" + embed(b, minValue) + "){" + fail(b, message, path) + "}");
}

function floatMax(schema, maxValue, maybeMessage) {
  let message = maybeMessage !== undefined ? maybeMessage : "Number must be lower than or equal to " + maxValue;
  return addRefinement(schema, metadataId$3, {
    kind: {
      TAG: "Max",
      value: maxValue
    },
    message: message
  }, (b, inputVar, param, path) => "if(" + inputVar + ">" + embed(b, maxValue) + "){" + fail(b, message, path) + "}");
}

function arrayMinLength(schema, length, maybeMessage) {
  let message = maybeMessage !== undefined ? maybeMessage : "Array must be " + length + " or more items long";
  return addRefinement(schema, metadataId, {
    kind: {
      TAG: "Min",
      length: length
    },
    message: message
  }, (b, inputVar, param, path) => "if(" + inputVar + ".length<" + embed(b, length) + "){" + fail(b, message, path) + "}");
}

function arrayMaxLength(schema, length, maybeMessage) {
  let message = maybeMessage !== undefined ? maybeMessage : "Array must be " + length + " or fewer items long";
  return addRefinement(schema, metadataId, {
    kind: {
      TAG: "Max",
      length: length
    },
    message: message
  }, (b, inputVar, param, path) => "if(" + inputVar + ".length>" + embed(b, length) + "){" + fail(b, message, path) + "}");
}

function stringMinLength(schema, length, maybeMessage) {
  let message = maybeMessage !== undefined ? maybeMessage : "String must be " + length + " or more characters long";
  return addRefinement(schema, metadataId$1, {
    kind: {
      TAG: "Min",
      length: length
    },
    message: message
  }, (b, inputVar, param, path) => "if(" + inputVar + ".length<" + embed(b, length) + "){" + fail(b, message, path) + "}");
}

function stringMaxLength(schema, length, maybeMessage) {
  let message = maybeMessage !== undefined ? maybeMessage : "String must be " + length + " or fewer characters long";
  return addRefinement(schema, metadataId$1, {
    kind: {
      TAG: "Max",
      length: length
    },
    message: message
  }, (b, inputVar, param, path) => "if(" + inputVar + ".length>" + embed(b, length) + "){" + fail(b, message, path) + "}");
}

function email(schema, messageOpt) {
  let message = messageOpt !== undefined ? messageOpt : "Invalid email address";
  return addRefinement(schema, metadataId$1, {
    kind: "Email",
    message: message
  }, (b, inputVar, param, path) => "if(!" + embed(b, emailRegex) + ".test(" + inputVar + ")){" + fail(b, message, path) + "}");
}

function uuid(schema, messageOpt) {
  let message = messageOpt !== undefined ? messageOpt : "Invalid UUID";
  return addRefinement(schema, metadataId$1, {
    kind: "Uuid",
    message: message
  }, (b, inputVar, param, path) => "if(!" + embed(b, uuidRegex) + ".test(" + inputVar + ")){" + fail(b, message, path) + "}");
}

function cuid(schema, messageOpt) {
  let message = messageOpt !== undefined ? messageOpt : "Invalid CUID";
  return addRefinement(schema, metadataId$1, {
    kind: "Cuid",
    message: message
  }, (b, inputVar, param, path) => "if(!" + embed(b, cuidRegex) + ".test(" + inputVar + ")){" + fail(b, message, path) + "}");
}

function url(schema, messageOpt) {
  let message = messageOpt !== undefined ? messageOpt : "Invalid url";
  return addRefinement(schema, metadataId$1, {
    kind: "Url",
    message: message
  }, (b, inputVar, param, path) => "try{new URL(" + inputVar + ")}catch(_){" + fail(b, message, path) + "}");
}

function pattern(schema, re, messageOpt) {
  let message = messageOpt !== undefined ? messageOpt : "Invalid";
  return addRefinement(schema, metadataId$1, {
    kind: {
      TAG: "Pattern",
      re: re
    },
    message: message
  }, (b, inputVar, param, path) => (
    re.global ? embed(b, re) + ".lastIndex=0;" : ""
  ) + ("if(!" + embed(b, re) + ".test(" + inputVar + ")){" + fail(b, message, path) + "}"));
}

function datetime(schema, messageOpt) {
  let message = messageOpt !== undefined ? messageOpt : "Invalid datetime string! Expected UTC";
  let refinement = {
    kind: "Datetime",
    message: message
  };
  let refinements = schema[metadataId$1];
  return transform$1(set$1(schema, metadataId$1, refinements !== undefined ? refinements.concat(refinement) : [refinement]), s => ({
    p: string => {
      if (!datetimeRe.test(string)) {
        s.fail(message, undefined);
      }
      return new Date(string);
    },
    s: date => date.toISOString()
  }));
}

function trim(schema) {
  let transformer = string => string.trim();
  return transform$1(schema, param => ({
    p: transformer,
    s: transformer
  }));
}

function nullable(schema) {
  return factory([
    schema,
    unit,
    $$null
  ]);
}

function nullableAsOption(schema) {
  return factory([
    schema,
    unit,
    nullAsUnit
  ]);
}

function js_union(values) {
  return factory(values.map(definitionToSchema));
}

function js_transform(schema, maybeParser, maybeSerializer) {
  return transform$1(schema, s => ({
    p: maybeParser !== undefined ? v => maybeParser(v, s) : undefined,
    s: maybeSerializer !== undefined ? v => maybeSerializer(v, s) : undefined
  }));
}

function js_refine(schema, refiner) {
  return refine(schema, s => (v => refiner(v, s)));
}

function noop(a) {
  return a;
}

function js_asyncParserRefine(schema, refine) {
  return transform$1(schema, s => ({
    a: v => refine(v, s).then(() => v),
    s: noop
  }));
}

function js_optional(schema, maybeOr) {
  let schema$1 = factory([
    schema,
    unit
  ]);
  if (maybeOr === undefined) {
    return schema$1;
  }
  let or = Primitive_option.valFromOption(maybeOr);
  if (typeof or === "function") {
    return getWithDefault(schema$1, {
      TAG: "Callback",
      _0: or
    });
  } else {
    return getWithDefault(schema$1, {
      TAG: "Value",
      _0: or
    });
  }
}

function js_nullable(schema, maybeOr) {
  let schema$1 = factory([
    schema,
    nullAsUnit
  ]);
  if (maybeOr === undefined) {
    return schema$1;
  }
  let or = Primitive_option.valFromOption(maybeOr);
  if (typeof or === "function") {
    return getWithDefault(schema$1, {
      TAG: "Callback",
      _0: or
    });
  } else {
    return getWithDefault(schema$1, {
      TAG: "Value",
      _0: or
    });
  }
}

function js_merge(s1, s2) {
  let s;
  if (s1.type === "object" && s2.type === "object") {
    let additionalItems1 = s1.additionalItems;
    if (typeof additionalItems1 === "string" && typeof s2.additionalItems === "string" && !s1.to && !s2.to) {
      let items2 = s2.items;
      let items1 = s1.items;
      let properties = {};
      let locations = [];
      let items = [];
      for (let idx = 0, idx_finish = items1.length; idx < idx_finish; ++idx) {
        let item = items1[idx];
        locations.push(item.location);
        properties[item.location] = item.schema;
      }
      for (let idx$1 = 0, idx_finish$1 = items2.length; idx$1 < idx_finish$1; ++idx$1) {
        let item$1 = items2[idx$1];
        if (!properties[item$1.location]) {
          locations.push(item$1.location);
        }
        properties[item$1.location] = item$1.schema;
      }
      for (let idx$2 = 0, idx_finish$2 = locations.length; idx$2 < idx_finish$2; ++idx$2) {
        let location = locations[idx$2];
        items.push({
          schema: properties[location],
          location: location
        });
      }
      let mut = new Schema("object");
      mut.items = items;
      mut.properties = properties;
      mut.additionalItems = additionalItems1;
      mut.refiner = schemaRefiner;
      s = mut;
    } else {
      s = undefined;
    }
  } else {
    s = undefined;
  }
  if (s !== undefined) {
    return s;
  }
  throw new Error("[Sury] The merge supports only structured object schemas without transformations");
}

function global(override) {
  let defaultAdditionalItems = override.defaultAdditionalItems;
  globalConfig.a = defaultAdditionalItems !== undefined ? defaultAdditionalItems : "strip";
  let prevDisableNanNumberCheck = globalConfig.n;
  let disableNanNumberValidation = override.disableNanNumberValidation;
  globalConfig.n = disableNanNumberValidation !== undefined ? disableNanNumberValidation : false;
  if (prevDisableNanNumberCheck !== globalConfig.n) {
    return resetCacheInPlace(float);
  }
  
}

let jsonSchemaMetadataId = "m:JSONSchema";

function internalToJSONSchema(schema, defs) {
  let jsonSchema = {};
  switch (schema.type) {
    case "never" :
      jsonSchema.not = {};
      break;
    case "unknown" :
      break;
    case "string" :
      let $$const = schema.const;
      jsonSchema.type = "string";
      refinements$1(schema).forEach(refinement => {
        let match = refinement.kind;
        if (typeof match !== "object") {
          switch (match) {
            case "Email" :
              jsonSchema.format = "email";
              return;
            case "Uuid" :
              jsonSchema.format = "uuid";
              return;
            case "Cuid" :
              return;
            case "Url" :
              jsonSchema.format = "uri";
              return;
            case "Datetime" :
              jsonSchema.format = "date-time";
              return;
          }
        } else {
          switch (match.TAG) {
            case "Min" :
              jsonSchema.minLength = match.length;
              return;
            case "Max" :
              jsonSchema.maxLength = match.length;
              return;
            case "Length" :
              let length = match.length;
              jsonSchema.minLength = length;
              jsonSchema.maxLength = length;
              return;
            case "Pattern" :
              jsonSchema.pattern = String(match.re);
              return;
          }
        }
      });
      if ($$const !== undefined) {
        jsonSchema.const = $$const;
      }
      break;
    case "number" :
      let format = schema.format;
      let $$const$1 = schema.const;
      if (format !== undefined) {
        if (format === "int32") {
          jsonSchema.type = "integer";
          refinements$2(schema).forEach(refinement => {
            let match = refinement.kind;
            if (match.TAG === "Min") {
              jsonSchema.minimum = match.value;
            } else {
              jsonSchema.maximum = match.value;
            }
          });
        } else {
          jsonSchema.type = "integer";
          jsonSchema.maximum = 65535;
          jsonSchema.minimum = 0;
        }
      } else {
        jsonSchema.type = "number";
        refinements$3(schema).forEach(refinement => {
          let match = refinement.kind;
          if (match.TAG === "Min") {
            jsonSchema.minimum = match.value;
          } else {
            jsonSchema.maximum = match.value;
          }
        });
      }
      if ($$const$1 !== undefined) {
        jsonSchema.const = $$const$1;
      }
      break;
    case "boolean" :
      let $$const$2 = schema.const;
      jsonSchema.type = "boolean";
      if ($$const$2 !== undefined) {
        jsonSchema.const = $$const$2;
      }
      break;
    case "null" :
      jsonSchema.type = "null";
      break;
    case "array" :
      let additionalItems = schema.additionalItems;
      let exit = 0;
      if (additionalItems === "strip" || additionalItems === "strict") {
        exit = 1;
      } else {
        jsonSchema.items = internalToJSONSchema(additionalItems, defs);
        jsonSchema.type = "array";
        refinements(schema).forEach(refinement => {
          let match = refinement.kind;
          switch (match.TAG) {
            case "Min" :
              jsonSchema.minItems = match.length;
              return;
            case "Max" :
              jsonSchema.maxItems = match.length;
              return;
            case "Length" :
              let length = match.length;
              jsonSchema.maxItems = length;
              jsonSchema.minItems = length;
              return;
          }
        });
      }
      if (exit === 1) {
        let items = schema.items.map(item => (internalToJSONSchema(item.schema, defs)));
        let itemsNumber = items.length;
        jsonSchema.items = Primitive_option.some(items);
        jsonSchema.type = "array";
        jsonSchema.minItems = itemsNumber;
        jsonSchema.maxItems = itemsNumber;
      }
      break;
    case "object" :
      let additionalItems$1 = schema.additionalItems;
      let exit$1 = 0;
      if (additionalItems$1 === "strip" || additionalItems$1 === "strict") {
        exit$1 = 1;
      } else {
        jsonSchema.type = "object";
        jsonSchema.additionalProperties = internalToJSONSchema(additionalItems$1, defs);
      }
      if (exit$1 === 1) {
        let properties = {};
        let required = [];
        schema.items.forEach(item => {
          let fieldSchema = internalToJSONSchema(item.schema, defs);
          if (!isOptional(item.schema)) {
            required.push(item.location);
          }
          properties[item.location] = fieldSchema;
        });
        jsonSchema.type = "object";
        jsonSchema.properties = properties;
        let tmp;
        tmp = additionalItems$1 === "strip" || additionalItems$1 === "strict" ? additionalItems$1 === "strip" : true;
        jsonSchema.additionalProperties = tmp;
        if (required.length !== 0) {
          jsonSchema.required = required;
        }
        
      }
      break;
    case "union" :
      let literals = [];
      let items$1 = [];
      schema.anyOf.forEach(childSchema => {
        if (childSchema.type === "undefined") {
          return;
        }
        items$1.push(internalToJSONSchema(childSchema, defs));
        if (isLiteral(childSchema)) {
          literals.push(childSchema.const);
          return;
        }
        
      });
      let itemsNumber$1 = items$1.length;
      let $$default = schema.default;
      if ($$default !== undefined) {
        jsonSchema.default = Primitive_option.valFromOption($$default);
      }
      if (itemsNumber$1 === 1) {
        Object.assign(jsonSchema, items$1[0]);
      } else if (literals.length === itemsNumber$1) {
        jsonSchema.enum = literals;
      } else {
        jsonSchema.anyOf = items$1;
      }
      break;
    case "ref" :
      let ref = schema.$ref;
      if (ref === defsPath + jsonName) {
        
      } else {
        jsonSchema.$ref = ref;
      }
      break;
    default:
      throw new Error("[Sury] Unexpected schema type");
  }
  let m = schema.description;
  if (m !== undefined) {
    jsonSchema.description = m;
  }
  let m$1 = schema.title;
  if (m$1 !== undefined) {
    jsonSchema.title = m$1;
  }
  let deprecated = schema.deprecated;
  if (deprecated !== undefined) {
    jsonSchema.deprecated = deprecated;
  }
  let examples = schema.examples;
  if (examples !== undefined) {
    jsonSchema.examples = examples;
  }
  let schemaDefs = schema.$defs;
  if (schemaDefs !== undefined) {
    Object.assign(defs, schemaDefs);
  }
  let metadataRawSchema = schema[jsonSchemaMetadataId];
  if (metadataRawSchema !== undefined) {
    Object.assign(jsonSchema, metadataRawSchema);
  }
  return jsonSchema;
}

function toJSONSchema(schema) {
  jsonableValidation(schema, schema, "", 8);
  let defs = {};
  let jsonSchema = internalToJSONSchema(schema, defs);
  ((delete defs.JSON));
  let defsKeys = Object.keys(defs);
  if (defsKeys.length) {
    defsKeys.forEach(key => {
      defs[key] = internalToJSONSchema(defs[key], 0);
    });
    jsonSchema.$defs = defs;
  }
  return jsonSchema;
}

function extendJSONSchema(schema, jsonSchema) {
  let existingSchemaExtend = schema[jsonSchemaMetadataId];
  return set$1(schema, jsonSchemaMetadataId, existingSchemaExtend !== undefined ? Object.assign({}, existingSchemaExtend, jsonSchema) : jsonSchema);
}

let primitiveToSchema = parse$1;

function toIntSchema(jsonSchema) {
  let minimum = jsonSchema.minimum;
  let schema;
  if (minimum !== undefined) {
    schema = intMin(int, minimum | 0, undefined);
  } else {
    let exclusiveMinimum = jsonSchema.exclusiveMinimum;
    schema = exclusiveMinimum !== undefined ? intMin(int, exclusiveMinimum + 1 | 0, undefined) : int;
  }
  let maximum = jsonSchema.maximum;
  if (maximum !== undefined) {
    return intMax(schema, maximum | 0, undefined);
  }
  let exclusiveMinimum$1 = jsonSchema.exclusiveMinimum;
  if (exclusiveMinimum$1 !== undefined) {
    return intMax(schema, exclusiveMinimum$1 - 1 | 0, undefined);
  } else {
    return schema;
  }
}

function definitionToDefaultValue(definition) {
  if (typeof definition !== "object") {
    return;
  } else {
    return definition.default;
  }
}

function fromJSONSchema(jsonSchema) {
  let definitionToSchema$1 = definition => {
    if (typeof definition !== "object") {
      if (definition === false) {
        return never;
      } else {
        return json;
      }
    } else {
      return fromJSONSchema(definition);
    }
  };
  let type_ = jsonSchema.type;
  let schema;
  let exit = 0;
  let exit$1 = 0;
  if (jsonSchema.nullable) {
    schema = factory$5(fromJSONSchema(Object.assign({}, jsonSchema, {
      nullable: false
    })));
  } else if (type_ !== undefined) {
    let type_$1 = Primitive_option.valFromOption(type_);
    if (type_$1 === "object") {
      let properties = jsonSchema.properties;
      if (properties !== undefined) {
        let schema$1 = object(s => {
          let obj = {};
          Object.keys(properties).forEach(key => {
            let property = properties[key];
            let propertySchema = definitionToSchema$1(property);
            let r = jsonSchema.required;
            let propertySchema$1;
            let exit = 0;
            if (r !== undefined && r.includes(key)) {
              propertySchema$1 = propertySchema;
            } else {
              exit = 1;
            }
            if (exit === 1) {
              let defaultValue = definitionToDefaultValue(property);
              if (defaultValue !== undefined) {
                let schema = option(propertySchema);
                propertySchema$1 = getWithDefault(schema, {
                  TAG: "Value",
                  _0: defaultValue
                });
              } else {
                propertySchema$1 = option(propertySchema);
              }
            }
            obj[key] = s.f(key, propertySchema$1);
          });
          return obj;
        });
        let additionalProperties = jsonSchema.additionalProperties;
        schema = additionalProperties === false ? strict(schema$1) : schema$1;
      } else {
        let additionalProperties$1 = jsonSchema.additionalProperties;
        schema = additionalProperties$1 !== undefined ? (
            typeof additionalProperties$1 !== "object" ? (
                additionalProperties$1 === false ? strict(object(param => {})) : factory$3(json)
              ) : factory$3(fromJSONSchema(additionalProperties$1))
          ) : definitionToSchema();
      }
    } else if (type_$1 === "array") {
      let items = jsonSchema.items;
      let schema$2;
      if (items !== undefined) {
        let single = JSONSchema.Arrayable.classify(Primitive_option.valFromOption(items));
        if (single.TAG === "Single") {
          schema$2 = factory$2(definitionToSchema$1(single._0));
        } else {
          let array = single._0;
          schema$2 = tuple(s => array.map((d, idx) => s.item(idx, definitionToSchema$1(d))));
        }
      } else {
        schema$2 = factory$2(json);
      }
      let min = jsonSchema.minItems;
      let schema$3 = min !== undefined ? arrayMinLength(schema$2, min, undefined) : schema$2;
      let max = jsonSchema.maxItems;
      schema = max !== undefined ? arrayMaxLength(schema$3, max, undefined) : schema$3;
    } else {
      exit$1 = 2;
    }
  } else {
    exit$1 = 2;
  }
  if (exit$1 === 2) {
    let primitives = jsonSchema.enum;
    let definitions = jsonSchema.allOf;
    let definitions$1 = jsonSchema.anyOf;
    if (definitions$1 !== undefined) {
      let len = definitions$1.length;
      schema = len !== 1 ? (
          len !== 0 ? factory(definitions$1.map(definitionToSchema$1)) : json
        ) : definitionToSchema$1(definitions$1[0]);
    } else if (definitions !== undefined) {
      let len$1 = definitions.length;
      schema = len$1 !== 1 ? (
          len$1 !== 0 ? refine(json, s => (data => {
              definitions.forEach(d => {
                try {
                  return assertOrThrow(data, definitionToSchema$1(d));
                } catch (exn) {
                  return s.fail("Should pass for all schemas of the allOf property.", undefined);
                }
              });
            })) : json
        ) : definitionToSchema$1(definitions[0]);
    } else {
      let definitions$2 = jsonSchema.oneOf;
      if (definitions$2 !== undefined) {
        let len$2 = definitions$2.length;
        schema = len$2 !== 1 ? (
            len$2 !== 0 ? refine(json, s => (data => {
                let hasOneValidRef = {
                  contents: false
                };
                definitions$2.forEach(d => {
                  let passed;
                  try {
                    assertOrThrow(data, definitionToSchema$1(d));
                    passed = true;
                  } catch (exn) {
                    passed = false;
                  }
                  if (passed) {
                    if (hasOneValidRef.contents) {
                      s.fail("Should pass single schema according to the oneOf property.", undefined);
                    }
                    hasOneValidRef.contents = true;
                    return;
                  }
                  
                });
                if (!hasOneValidRef.contents) {
                  return s.fail("Should pass at least one schema according to the oneOf property.", undefined);
                }
                
              })) : json
          ) : definitionToSchema$1(definitions$2[0]);
      } else {
        let not = jsonSchema.not;
        if (not !== undefined) {
          schema = refine(json, s => (data => {
            let passed;
            try {
              assertOrThrow(data, definitionToSchema$1(not));
              passed = true;
            } catch (exn) {
              passed = false;
            }
            if (passed) {
              return s.fail("Should NOT be valid against schema in the not property.", undefined);
            }
            
          }));
        } else if (primitives !== undefined) {
          let len$3 = primitives.length;
          schema = len$3 !== 1 ? (
              len$3 !== 0 ? factory(primitives.map(primitiveToSchema)) : json
            ) : parse$1(primitives[0]);
        } else {
          let $$const = jsonSchema.const;
          if ($$const !== undefined) {
            schema = parse$1($$const);
          } else if (type_ !== undefined) {
            let type_$2 = Primitive_option.valFromOption(type_);
            let exit$2 = 0;
            let exit$3 = 0;
            if (Array.isArray(type_$2)) {
              schema = factory(type_$2.map(type_ => fromJSONSchema(Object.assign({}, jsonSchema, {
                type: Primitive_option.some(type_)
              }))));
            } else if (type_$2 === "string") {
              let p = jsonSchema.pattern;
              let schema$4 = p !== undefined ? pattern(string, new RegExp(p), undefined) : string;
              let minLength = jsonSchema.minLength;
              let schema$5 = minLength !== undefined ? stringMinLength(schema$4, minLength, undefined) : schema$4;
              let maxLength = jsonSchema.maxLength;
              let schema$6 = maxLength !== undefined ? stringMaxLength(schema$5, maxLength, undefined) : schema$5;
              switch (jsonSchema.format) {
                case "date-time" :
                  schema = datetime(schema$6, undefined);
                  break;
                case "email" :
                  schema = email(schema$6, undefined);
                  break;
                case "uri" :
                  schema = url(schema$6, undefined);
                  break;
                case "uuid" :
                  schema = uuid(schema$6, undefined);
                  break;
                default:
                  schema = schema$6;
              }
            } else if (type_$2 === "integer" || jsonSchema.format === "int64" && type_$2 === "number") {
              schema = toIntSchema(jsonSchema);
            } else {
              exit$3 = 4;
            }
            if (exit$3 === 4) {
              if (jsonSchema.multipleOf !== 1 || type_$2 !== "number") {
                exit$2 = 3;
              } else {
                schema = toIntSchema(jsonSchema);
              }
            }
            if (exit$2 === 3) {
              if (type_$2 === "number") {
                let minimum = jsonSchema.minimum;
                let schema$7;
                if (minimum !== undefined) {
                  schema$7 = floatMin(float, minimum, undefined);
                } else {
                  let exclusiveMinimum = jsonSchema.exclusiveMinimum;
                  schema$7 = exclusiveMinimum !== undefined ? floatMin(float, exclusiveMinimum + 1, undefined) : float;
                }
                let maximum = jsonSchema.maximum;
                if (maximum !== undefined) {
                  schema = floatMax(schema$7, maximum, undefined);
                } else {
                  let exclusiveMinimum$1 = jsonSchema.exclusiveMinimum;
                  schema = exclusiveMinimum$1 !== undefined ? floatMax(schema$7, exclusiveMinimum$1 - 1, undefined) : schema$7;
                }
              } else if (type_$2 === "boolean") {
                schema = bool;
              } else if (type_$2 === "null") {
                schema = js_schema(null);
              } else {
                exit = 1;
              }
            }
            
          } else {
            exit = 1;
          }
        }
      }
    }
  }
  if (exit === 1) {
    let if_ = jsonSchema.if;
    if (if_ !== undefined) {
      let then = jsonSchema.then;
      if (then !== undefined) {
        let else_ = jsonSchema.else;
        if (else_ !== undefined) {
          let ifSchema = definitionToSchema$1(if_);
          let thenSchema = definitionToSchema$1(then);
          let elseSchema = definitionToSchema$1(else_);
          schema = refine(json, param => (data => {
            let passed;
            try {
              assertOrThrow(data, ifSchema);
              passed = true;
            } catch (exn) {
              passed = false;
            }
            if (passed) {
              return assertOrThrow(data, thenSchema);
            } else {
              return assertOrThrow(data, elseSchema);
            }
          }));
        } else {
          schema = json;
        }
      } else {
        schema = json;
      }
    } else {
      schema = json;
    }
  }
  if (jsonSchema.description === undefined && jsonSchema.deprecated === undefined && jsonSchema.examples === undefined && jsonSchema.title === undefined) {
    return schema;
  }
  return meta(schema, {
    title: jsonSchema.title,
    description: jsonSchema.description,
    deprecated: jsonSchema.deprecated,
    examples: jsonSchema.examples
  });
}

function min(schema, minValue, maybeMessage) {
  switch (schema.type) {
    case "string" :
      return stringMinLength(schema, minValue, maybeMessage);
    case "number" :
      if (schema.format !== undefined) {
        return intMin(schema, minValue, maybeMessage);
      } else {
        return floatMin(schema, minValue, maybeMessage);
      }
    case "array" :
      return arrayMinLength(schema, minValue, maybeMessage);
    default:
      let message = "S.min is not supported for " + toExpression(schema) + " schema. Coerce the schema to string, number or array using S.to first.";
      throw new Error("[Sury] " + message);
  }
}

function max(schema, maxValue, maybeMessage) {
  switch (schema.type) {
    case "string" :
      return stringMaxLength(schema, maxValue, maybeMessage);
    case "number" :
      if (schema.format !== undefined) {
        return intMax(schema, maxValue, maybeMessage);
      } else {
        return floatMax(schema, maxValue, maybeMessage);
      }
    case "array" :
      return arrayMaxLength(schema, maxValue, maybeMessage);
    default:
      let message = "S.max is not supported for " + toExpression(schema) + " schema. Coerce the schema to string, number or array using S.to first.";
      throw new Error("[Sury] " + message);
  }
}

function length(schema, length$1, maybeMessage) {
  switch (schema.type) {
    case "string" :
      let message = maybeMessage !== undefined ? maybeMessage : "String must be exactly " + length$1 + " characters long";
      return addRefinement(schema, metadataId$1, {
        kind: {
          TAG: "Length",
          length: length$1
        },
        message: message
      }, (b, inputVar, param, path) => "if(" + inputVar + ".length!==" + embed(b, length$1) + "){" + fail(b, message, path) + "}");
    case "array" :
      let message$1 = maybeMessage !== undefined ? maybeMessage : "Array must be exactly " + length$1 + " items long";
      return addRefinement(schema, metadataId, {
        kind: {
          TAG: "Length",
          length: length$1
        },
        message: message$1
      }, (b, inputVar, param, path) => "if(" + inputVar + ".length!==" + embed(b, length$1) + "){" + fail(b, message$1, path) + "}");
    default:
      let message$2 = "S.length is not supported for " + toExpression(schema) + " schema. Coerce the schema to string or array using S.to first.";
      throw new Error("[Sury] " + message$2);
  }
}

let Path = {
  empty: "",
  dynamic: "[]",
  toArray: toArray,
  fromArray: fromArray,
  fromLocation: fromLocation,
  concat: concat
};

let Flag = {
  none: 0,
  typeValidation: 1,
  async: 2,
  assertOutput: 4,
  jsonableOutput: 8,
  jsonStringOutput: 16,
  reverse: 32,
  has: has
};

let literal = js_schema;

let array = factory$2;

let dict = factory$3;

let $$null$1 = factory$5;

let union = factory;

let parseJsonOrThrow = parseOrThrow;

let Schema$1 = {};

let schema = factory$4;

let $$Object = {};

let Option = {
  getOr: getOr,
  getOrWith: getOrWith
};

let String_Refinement = {};

let $$String$1 = {
  Refinement: String_Refinement,
  refinements: refinements$1
};

let Int_Refinement = {};

let Int = {
  Refinement: Int_Refinement,
  refinements: refinements$2
};

let Float_Refinement = {};

let Float = {
  Refinement: Float_Refinement,
  refinements: refinements$3
};

let Array_Refinement = {};

let $$Array$1 = {
  Refinement: Array_Refinement,
  refinements: refinements
};

let Metadata = {
  Id: Id,
  get: get$1,
  set: set$1
};

export {
  Path,
  $$Error,
  Flag,
  never,
  unknown,
  unit,
  nullAsUnit,
  string,
  bool,
  int,
  float,
  bigint,
  symbol,
  json,
  enableJson,
  jsonString,
  jsonStringWithSpace,
  enableJsonString,
  literal,
  array,
  unnest,
  list,
  instance,
  dict,
  option,
  $$null$1 as $$null,
  nullable,
  nullableAsOption,
  union,
  $$enum,
  meta,
  transform$1 as transform,
  refine,
  shape,
  to,
  compile,
  parseOrThrow,
  parseJsonOrThrow,
  parseJsonStringOrThrow,
  parseAsyncOrThrow,
  convertOrThrow,
  convertToJsonOrThrow,
  convertToJsonStringOrThrow,
  convertAsyncOrThrow,
  reverseConvertOrThrow,
  reverseConvertToJsonOrThrow,
  reverseConvertToJsonStringOrThrow,
  assertOrThrow,
  isAsync,
  recursive,
  noValidation,
  toExpression,
  Schema$1 as Schema,
  schema,
  $$Object,
  object,
  strip,
  deepStrip,
  strict,
  deepStrict,
  Tuple,
  tuple,
  tuple1,
  tuple2,
  tuple3,
  Option,
  $$String$1 as $$String,
  Int,
  Float,
  $$Array$1 as $$Array,
  Metadata,
  reverse,
  ErrorClass,
  min,
  floatMin,
  max,
  floatMax,
  length,
  port,
  email,
  uuid,
  cuid,
  url,
  pattern,
  datetime,
  trim,
  toJSONSchema,
  fromJSONSchema,
  extendJSONSchema,
  global,
  js_safe,
  js_safeAsync,
  js_union,
  js_optional,
  js_nullable,
  js_asyncParserRefine,
  js_refine,
  js_transform,
  js_schema,
  js_merge,
}
/* s Not a pure module */

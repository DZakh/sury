// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as JSONSchema from "./JSONSchema.res.mjs";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";

var immutableEmpty = {};

var immutableEmpty$1 = [];

function fromString(string) {
  var _idx = 0;
  while(true) {
    var idx = _idx;
    var match = string[idx];
    if (match === undefined) {
      return "\"" + string + "\"";
    }
    if (match === "\"") {
      return JSON.stringify(string);
    }
    _idx = idx + 1 | 0;
    continue ;
  };
}

function toArray(path) {
  if (path === "") {
    return [];
  } else {
    return JSON.parse(path.split("\"][\"").join("\",\""));
  }
}

function fromLocation($$location) {
  return "[" + fromString($$location) + "]";
}

function fromArray(array) {
  var len = array.length;
  if (len !== 1) {
    if (len !== 0) {
      return "[" + array.map(fromString).join("][") + "]";
    } else {
      return "";
    }
  }
  var $$location = array[0];
  return "[" + fromString($$location) + "]";
}

function concat(path, concatedPath) {
  return path + concatedPath;
}

var vendor = "sury";

var s = Symbol(vendor);

var itemSymbol = Symbol(vendor + ":item");

var $$Error = /* @__PURE__ */Caml_exceptions.create("Sury.Error");

var isLiteral = (s => "const" in s);

function isOptional(schema) {
  var match = schema.type;
  switch (match) {
    case "undefined" :
        return true;
    case "union" :
        return schema.has["undefined"];
    default:
      return false;
  }
}

var globalConfig = {
  r: 0,
  a: "strip",
  n: false
};

class SuryError extends Error {
  constructor(code, flag, path) {
    super();
    this.flag = flag;
    this.code = code;
    this.path = path;
  }
}

var d = Object.defineProperty, p = SuryError.prototype;
d(p, 'message', {
  get() {
      return message(this);
  }
})
d(p, 'reason', {
  get() {
      return reason(this);
  }
})
d(p, 'name', {value: 'SuryError'})
d(p, 's', {value: s})
d(p, '_1', {
  get() {
    return this
  },
});
d(p, 'RE_EXN_ID', {
  value: $$Error,
});

var Schema = function(opts) {
  for (let k in opts) {
    this[k] = opts[k]
  }
}, sp = Object.create(null);
d(sp, 'with', {
  get() {
    return (fn, ...args) => fn(this, ...args)
  },
});
// Also has ~standard below
Schema.prototype = sp;
;

function getOrRethrow(exn) {
  if ((exn&&exn.s===s)) {
    return exn;
  }
  throw exn;
}

function has(acc, flag) {
  return (acc & flag) !== 0;
}

var copy = ((schema) => {
  let c = new Schema()
  for (let k in schema) {
    if (k > "a") {
      c[k] = schema[k]
    }
  }
  return c
});

var mergeInPlace = ((target, schema) => {
  for (let k in schema) {
    if (k > "a") {
      target[k] = schema[k]
    }
  }
});

var resetOperationsCache = ((schema) => {
  for (let k in schema) {
    if (+k) {
      delete schema[k];
    }
  }
});

function stringify(unknown) {
  var typeOfValue = typeof unknown;
  if (typeOfValue === "number" || typeOfValue === "function" || typeOfValue === "boolean" || typeOfValue === "symbol") {
    return unknown.toString();
  }
  if (typeOfValue === "string") {
    return "\"" + unknown + "\"";
  }
  if (typeOfValue !== "object") {
    if (typeOfValue === "undefined") {
      return "undefined";
    } else {
      return unknown + "n";
    }
  }
  if (unknown === null) {
    return "null";
  }
  if (Array.isArray(unknown)) {
    var string = "[";
    for(var i = 0 ,i_finish = unknown.length; i < i_finish; ++i){
      if (i !== 0) {
        string = string + ", ";
      }
      string = string + stringify(unknown[i]);
    }
    return string + "]";
  }
  if (unknown.constructor !== Object) {
    return Object.prototype.toString.call(unknown);
  }
  var keys = Object.keys(unknown);
  var string$1 = "{ ";
  for(var i$1 = 0 ,i_finish$1 = keys.length; i$1 < i_finish$1; ++i$1){
    var key = keys[i$1];
    var value = unknown[key];
    string$1 = string$1 + key + ": " + stringify(value) + "; ";
  }
  return string$1 + "}";
}

function toExpression(schema) {
  var tag = schema.type;
  var $$const = schema.const;
  var name = schema.name;
  if (name !== undefined) {
    return name;
  }
  if ($$const !== undefined) {
    return stringify($$const);
  }
  var format = schema.format;
  var anyOf = schema.anyOf;
  if (anyOf !== undefined) {
    return anyOf.map(toExpression).join(" | ");
  }
  if (format !== undefined) {
    return format;
  }
  switch (tag) {
    case "nan" :
        return "NaN";
    case "instance" :
        return schema.class.name;
    case "array" :
        var additionalItems = schema.additionalItems;
        var items = schema.items;
        if (typeof additionalItems !== "object") {
          return "[" + items.map(function (item) {
                        return toExpression(item.schema);
                      }).join(", ") + "]";
        }
        var itemName = toExpression(additionalItems);
        return (
                additionalItems.type === "union" ? "(" + itemName + ")" : itemName
              ) + "[]";
    case "object" :
        var additionalItems$1 = schema.additionalItems;
        var items$1 = schema.items;
        if (items$1.length === 0) {
          if (typeof additionalItems$1 === "object") {
            return "{ [key: string]: " + toExpression(additionalItems$1) + "; }";
          } else {
            return "{}";
          }
        } else {
          return "{ " + items$1.map(function (item) {
                        return item.location + ": " + toExpression(item.schema) + ";";
                      }).join(" ") + " }";
        }
    default:
      return tag;
  }
}

var value = SuryError;

function constructor(prim0, prim1, prim2) {
  return new SuryError(prim0, prim1, prim2);
}

function reason(error, nestedLevelOpt) {
  var nestedLevel = nestedLevelOpt !== undefined ? nestedLevelOpt : 0;
  var reason$1 = error.code;
  if (typeof reason$1 !== "object") {
    return "Encountered unexpected async transform or refine. Use parseAsyncOrThrow operation instead";
  }
  switch (reason$1.TAG) {
    case "OperationFailed" :
        return reason$1._0;
    case "InvalidOperation" :
        return reason$1.description;
    case "InvalidType" :
        var unionErrors = reason$1.unionErrors;
        var m = "Expected " + toExpression(reason$1.expected) + ", received " + stringify(reason$1.received);
        if (unionErrors !== undefined) {
          var lineBreak = "\n" + " ".repeat((nestedLevel << 1));
          var reasonsDict = {};
          for(var idx = 0 ,idx_finish = unionErrors.length; idx < idx_finish; ++idx){
            var error$1 = unionErrors[idx];
            var reason$2 = reason(error$1, nestedLevel + 1);
            var nonEmptyPath = error$1.path;
            var $$location = nonEmptyPath === "" ? "" : "At " + nonEmptyPath + ": ";
            var line = "- " + $$location + reason$2;
            if (!reasonsDict[line]) {
              reasonsDict[line] = 1;
              m = m + lineBreak + line;
            }
            
          }
        }
        return m;
    case "ExcessField" :
        return "Unrecognized key \"" + reason$1._0 + "\"";
    case "InvalidJsonSchema" :
        return toExpression(reason$1._0) + " is not valid JSON";
    
  }
}

function reason$1(error) {
  return reason(error, undefined);
}

function message(error) {
  var op = error.flag;
  var text = "Failed ";
  if (op & 2) {
    text = text + "async ";
  }
  text = text + (
    op & 1 ? (
        op & 4 ? "asserting" : "parsing"
      ) : "converting"
  );
  if (op & 8) {
    text = text + " to JSON" + (
      op & 16 ? " string" : ""
    );
  }
  var nonEmptyPath = error.path;
  var tmp = nonEmptyPath === "" ? "" : " at " + nonEmptyPath;
  return text + tmp + ": " + reason(error, undefined);
}

var ErrorClass = {
  value: value,
  constructor: constructor,
  reason: reason$1,
  message: message
};

function embed(b, value) {
  var e = b.g.e;
  var l = e.length;
  e[l] = value;
  return "e[" + l + "]";
}

function inlineConst(b, schema) {
  var match = schema.type;
  switch (match) {
    case "string" :
        var $$const = schema.const;
        return fromString($$const);
    case "bigint" :
        var $$const$1 = schema.const;
        return $$const$1 + "n";
    case "undefined" :
        return "void 0";
    case "symbol" :
    case "function" :
    case "instance" :
        break;
    default:
      return schema.const;
  }
  var $$const$2 = schema.const;
  return embed(b, $$const$2);
}

function secondAllocate(v) {
  var b = this;
  b.l = b.l + "," + v;
}

function initialAllocate(v) {
  var b = this;
  b.l = v;
  b.a = secondAllocate;
}

function rootScope(flag) {
  var $$global = {
    c: "",
    l: "",
    a: initialAllocate,
    v: -1,
    o: flag,
    e: []
  };
  $$global.g = $$global;
  return $$global;
}

function allocateScope(b) {
  ((delete b.a));
  var varsAllocation = b.l;
  if (varsAllocation === "") {
    return b.c;
  } else {
    return "let " + varsAllocation + ";" + b.c;
  }
}

function varWithoutAllocation($$global) {
  var newCounter = $$global.v + 1;
  $$global.v = newCounter;
  return "v" + newCounter;
}

function _var(_b) {
  return this.i;
}

function _notVar(b) {
  var val = this;
  var v = varWithoutAllocation(b.g);
  var i = val.i;
  if (i === "") {
    val.b.a(v);
  } else if (val.b.a !== (void 0)) {
    val.b.a(v + "=" + i);
  } else {
    b.c = b.c + (v + "=" + i + ";");
    b.g.a(v);
  }
  val.v = _var;
  val.i = v;
  return v;
}

function allocateVal(b) {
  var v = varWithoutAllocation(b.g);
  b.a(v);
  return {
          b: b,
          v: _var,
          i: v,
          a: false
        };
}

function objectJoin(inlinedLocation, value) {
  return inlinedLocation + ":" + value + ",";
}

function arrayJoin(_inlinedLocation, value) {
  return value + ",";
}

function make(b, isArray) {
  return {
          b: b,
          v: _notVar,
          i: "",
          a: false,
          j: isArray ? arrayJoin : objectJoin,
          c: 0,
          p: ""
        };
}

function add(objectVal, inlinedLocation, val) {
  objectVal[inlinedLocation] = val;
  if (val.a) {
    objectVal.p = objectVal.p + val.i + ",";
    objectVal.i = objectVal.i + objectVal.j(inlinedLocation, "a[" + (objectVal.c++) + "]");
  } else {
    objectVal.i = objectVal.i + objectVal.j(inlinedLocation, val.i);
  }
}

function merge(target, subObjectVal) {
  var inlinedLocations = Object.keys(subObjectVal);
  for(var idx = 7 ,idx_finish = inlinedLocations.length; idx < idx_finish; ++idx){
    var inlinedLocation = inlinedLocations[idx];
    add(target, inlinedLocation, subObjectVal[inlinedLocation]);
  }
}

function complete(objectVal, isArray) {
  objectVal.i = isArray ? "[" + objectVal.i + "]" : "{" + objectVal.i + "}";
  if (objectVal.c) {
    objectVal.a = true;
    objectVal.i = "Promise.all([" + objectVal.p + "]).then(a=>(" + objectVal.i + "))";
  }
  return objectVal;
}

function addKey(b, input, key, val) {
  return input.v(b) + "[" + key + "]=" + val.i;
}

function set(b, input, val) {
  if (input === val) {
    return "";
  }
  var inputVar = input.v(b);
  var match = input.a;
  if (match) {
    var match$1 = val.a;
    if (!match$1) {
      return inputVar + "=Promise.resolve(" + val.i + ")";
    }
    
  } else {
    var match$2 = val.a;
    if (match$2) {
      input.a = true;
      return inputVar + "=" + val.i;
    }
    
  }
  return inputVar + "=" + val.i;
}

function get(b, targetVal, inlinedLocation) {
  var val = targetVal[inlinedLocation];
  if (val !== undefined) {
    return val;
  } else {
    return {
            b: b,
            v: _notVar,
            i: targetVal.v(b) + ("[" + inlinedLocation + "]"),
            a: false
          };
  }
}

function setInlined(b, input, inlined) {
  return input.v(b) + "=" + inlined;
}

function map(inlinedFn, input) {
  return {
          b: input.b,
          v: _notVar,
          i: inlinedFn + "(" + input.i + ")",
          a: false
        };
}

function transform(b, input, operation) {
  if (!input.a) {
    return operation(b, input);
  }
  var bb = {
    c: "",
    l: "",
    a: initialAllocate,
    g: b.g
  };
  var operationInput = {
    b: b,
    v: _var,
    i: varWithoutAllocation(bb.g),
    a: false
  };
  var operationOutputVal = operation(bb, operationInput);
  var operationCode = allocateScope(bb);
  return {
          b: input.b,
          v: _notVar,
          i: input.i + ".then(" + operationInput.v(b) + "=>{" + operationCode + "return " + operationOutputVal.i + "})",
          a: true
        };
}

function raise(b, code, path) {
  throw new SuryError(code, b.g.o, path);
}

function embedSyncOperation(b, input, fn) {
  if (input.a) {
    return {
            b: input.b,
            v: _notVar,
            i: input.i + ".then(" + embed(b, fn) + ")",
            a: true
          };
  } else {
    return map(embed(b, fn), input);
  }
}

function failWithArg(b, path, fn, arg) {
  return embed(b, (function (arg) {
                return raise(b, fn(arg), path);
              })) + "(" + arg + ")";
}

function fail(b, message, path) {
  return embed(b, (function () {
                return raise(b, {
                            TAG: "OperationFailed",
                            _0: message
                          }, path);
              })) + "()";
}

function effectCtx(b, selfSchema, path) {
  return {
          schema: selfSchema,
          fail: (function (message, customPathOpt) {
              var customPath = customPathOpt !== undefined ? customPathOpt : "";
              return raise(b, {
                          TAG: "OperationFailed",
                          _0: message
                        }, path + customPath);
            })
        };
}

function invalidOperation(b, path, description) {
  return raise(b, {
              TAG: "InvalidOperation",
              description: description
            }, path);
}

function withCatch(b, input, $$catch, appendSafe, fn) {
  var prevCode = b.c;
  b.c = "";
  var errorVar = varWithoutAllocation(b.g);
  var maybeResolveVal = $$catch(b, errorVar);
  var catchCode = "if(" + (errorVar + "&&" + errorVar + ".s===s") + "){" + b.c;
  b.c = "";
  var bb = {
    c: "",
    l: "",
    a: initialAllocate,
    g: b.g
  };
  var fnOutput = fn(bb);
  b.c = b.c + allocateScope(bb);
  var isNoop = fnOutput.i === input.i && b.c === "";
  if (appendSafe !== undefined) {
    appendSafe(b, fnOutput);
  }
  if (isNoop) {
    return fnOutput;
  }
  var isAsync = fnOutput.a;
  var output = input === fnOutput ? input : (
      appendSafe !== undefined ? fnOutput : ({
            b: b,
            v: _notVar,
            i: "",
            a: isAsync
          })
    );
  var catchCode$1 = maybeResolveVal !== undefined ? (function (catchLocation) {
        return catchCode + (
                catchLocation === 1 ? "return " + maybeResolveVal.i : set(b, output, maybeResolveVal)
              ) + ("}else{throw " + errorVar + "}");
      }) : (function (param) {
        return catchCode + "}throw " + errorVar;
      });
  b.c = prevCode + ("try{" + b.c + (
      isAsync ? setInlined(b, output, fnOutput.i + ".catch(" + errorVar + "=>{" + catchCode$1(1) + "})") : set(b, output, fnOutput)
    ) + "}catch(" + errorVar + "){" + catchCode$1(0) + "}");
  return output;
}

function withPathPrepend(b, input, path, maybeDynamicLocationVar, appendSafe, fn) {
  if (path === "" && maybeDynamicLocationVar === undefined) {
    return fn(b, input, path);
  }
  try {
    return withCatch(b, input, (function (b, errorVar) {
                  b.c = errorVar + ".path=" + fromString(path) + "+" + (
                    maybeDynamicLocationVar !== undefined ? "'[\"'+" + maybeDynamicLocationVar + "+'\"]'+" : ""
                  ) + errorVar + ".path";
                }), appendSafe, (function (b) {
                  return fn(b, input, "");
                }));
  }
  catch (exn){
    var error = getOrRethrow(exn);
    throw new SuryError(error.code, error.flag, path + "[]" + error.path);
  }
}

function validation(b, inputVar, schema, negative) {
  var eq = negative ? "!==" : "===";
  var and_ = negative ? "||" : "&&";
  var exp = negative ? "!" : "";
  var tag = schema.type;
  switch (tag) {
    case "null" :
        return inputVar + eq + "null";
    case "undefined" :
        return inputVar + eq + "void 0";
    case "nan" :
        return exp + ("Number.isNaN(" + inputVar + ")");
    default:
      var match = schema.const;
      if (match !== undefined) {
        return inputVar + eq + inlineConst(b, schema);
      }
      switch (tag) {
        case "instance" :
            var $$class = schema.class;
            var c = inputVar + " instanceof " + embed(b, $$class);
            if (negative) {
              return "!(" + c + ")";
            } else {
              return c;
            }
        case "array" :
            return exp + "Array.isArray(" + inputVar + ")";
        case "object" :
            return "typeof " + inputVar + eq + "\"" + tag + "\"" + and_ + exp + inputVar;
        default:
          return "typeof " + inputVar + eq + "\"" + tag + "\"";
      }
  }
}

function refinement(b, inputVar, schema, negative) {
  var eq = negative ? "!==" : "===";
  var and_ = negative ? "||" : "&&";
  var not_ = negative ? "" : "!";
  var lt = negative ? ">" : "<";
  var gt = negative ? "<" : ">";
  var match = schema.type;
  var tag;
  var exit = 0;
  var match$1 = schema.const;
  if (match$1 !== undefined) {
    return "";
  }
  var match$2 = schema.format;
  if (match$2 !== undefined) {
    if (match$2 === "int32") {
      return and_ + inputVar + lt + "2147483647" + and_ + inputVar + gt + "-2147483648" + and_ + inputVar + "%1" + eq + "0";
    }
    exit = 2;
  } else {
    exit = 2;
  }
  if (exit === 2) {
    switch (match) {
      case "number" :
          if (globalConfig.n) {
            return "";
          } else {
            return and_ + not_ + "Number.isNaN(" + inputVar + ")";
          }
      case "array" :
      case "object" :
          tag = match;
          break;
      default:
        return "";
    }
  }
  var additionalItems = schema.additionalItems;
  var items = schema.items;
  var length = items.length;
  var code = tag === "array" ? (
      additionalItems === "strip" || additionalItems === "strict" ? (
          additionalItems === "strip" ? and_ + inputVar + ".length" + gt + length : and_ + inputVar + ".length" + eq + length
        ) : ""
    ) : (
      additionalItems === "strip" ? "" : and_ + not_ + "Array.isArray(" + inputVar + ")"
    );
  for(var idx = 0 ,idx_finish = items.length; idx < idx_finish; ++idx){
    var match$3 = items[idx];
    var inlinedLocation = match$3.inlinedLocation;
    var item = match$3.schema;
    var itemCode;
    if (isLiteral(item) && !item.catch || schema.unnest) {
      itemCode = validation(b, inputVar + ("[" + inlinedLocation + "]"), item, negative);
    } else if (item.type === "object") {
      var inputVar$1 = inputVar + ("[" + inlinedLocation + "]");
      itemCode = validation(b, inputVar$1, item, negative) + refinement(b, inputVar$1, item, negative);
    } else {
      itemCode = "";
    }
    if (itemCode !== "") {
      code = code + and_ + itemCode;
    }
    
  }
  return code;
}

function typeFilterCode(b, schema, input, path) {
  var match = schema.type;
  var match$1 = schema.noValidation;
  if (match$1 !== undefined && match$1) {
    return "";
  }
  switch (match) {
    case "never" :
    case "unknown" :
    case "union" :
    case "json" :
        return "";
    default:
      var inputVar = input.v(b);
      return "if(" + validation(b, inputVar, schema, true) + refinement(b, inputVar, schema, true) + "){" + failWithArg(b, path, (function (input) {
                    return {
                            TAG: "InvalidType",
                            expected: schema,
                            received: input
                          };
                  }), inputVar) + "}";
  }
}

function parseWithTypeValidation(b, schema, input, path) {
  if (b.g.o & 1 || isLiteral(schema)) {
    b.c = b.c + typeFilterCode(b, schema, input, path);
  }
  var builder = schema.builder;
  if (builder !== undefined) {
    return builder(b, input, schema, path);
  } else {
    return input;
  }
}

function noopOperation(i) {
  return i;
}

var nonJsonableTags = new Set([
      "unknown",
      "nan",
      "bigint",
      "function",
      "instance",
      "symbol"
    ]);

function jsonableValidation(output, parent, path, flag, recSet) {
  var tag = output.type;
  if (tag === "undefined" && parent.type !== "object" || nonJsonableTags.has(tag)) {
    throw new SuryError({
              TAG: "InvalidJsonSchema",
              _0: parent
            }, flag, path);
  }
  var match = output.type;
  switch (match) {
    case "array" :
    case "object" :
    case "union" :
        break;
    default:
      return ;
  }
  var recSet$1 = recSet !== undefined ? Caml_option.valFromOption(recSet) : new Set();
  if (recSet$1.has(output)) {
    return ;
  }
  recSet$1.add(output);
  var recSet$2 = Caml_option.some(recSet$1);
  if (tag === "union") {
    output.anyOf.forEach(function (s) {
          jsonableValidation(s, parent, path, flag, recSet$2);
        });
    return ;
  }
  var additionalItems = output.additionalItems;
  var items = output.items;
  if (items === undefined) {
    return ;
  }
  if (additionalItems === "strip" || additionalItems === "strict") {
    additionalItems === "strip";
  } else {
    jsonableValidation(additionalItems, parent, path, flag, recSet$2);
  }
  items.forEach(function (item) {
        jsonableValidation(item.schema, output, path + ("[" + item.inlinedLocation + "]"), flag, recSet$2);
      });
}

function reverse(schema) {
  var fn = schema.output;
  if (fn === undefined) {
    return schema;
  }
  if (typeof fn === "object") {
    return fn;
  }
  var reversed = fn.call(schema);
  var reversed$1 = reversed.output === undefined ? copy(reversed) : reversed;
  if (reversed$1["~standard"] === undefined) {
    new Schema(reversed$1);
  }
  schema.output = reversed$1;
  reversed$1.output = schema;
  return reversed$1;
}

function internalCompile(schema, flag) {
  var b = rootScope(flag);
  if (flag & 8) {
    var output = reverse(schema);
    jsonableValidation(output, output, "", flag, undefined);
  }
  var input = {
    b: b,
    v: _var,
    i: "i",
    a: false
  };
  var builder = schema.builder;
  var output$1 = builder !== undefined ? builder(b, input, schema, "") : input;
  schema.isAsync = output$1.a;
  if (b.l !== "") {
    b.c = "let " + b.l + ";" + b.c;
  }
  if (flag & 1 || isLiteral(schema)) {
    b.c = typeFilterCode(b, schema, input, "") + b.c;
  }
  if (b.c === "" && output$1 === input && !(flag & 22)) {
    return noopOperation;
  }
  var inlinedOutput = flag & 4 ? "void 0" : output$1.i;
  if (flag & 16) {
    inlinedOutput = "JSON.stringify(" + inlinedOutput + ")";
  }
  if (flag & 2 && !output$1.a) {
    inlinedOutput = "Promise.resolve(" + inlinedOutput + ")";
  }
  var inlinedFunction = "i=>{" + b.c + "return " + inlinedOutput + "}";
  return new Function("e", "s", "return " + inlinedFunction)(b.g.e, s);
}

function operationFn(s, o) {
  if ((o in s)) {
    return (s[o]);
  }
  var f = internalCompile(o & 32 ? reverse(s) : s, o);
  ((s[o] = f));
  return f;
}

d(sp, "~standard", {
      get: (function () {
          var schema = this;
          return {
                  version: 1,
                  vendor: vendor,
                  validate: (function (input) {
                      try {
                        return {
                                value: operationFn(schema, 1)(input)
                              };
                      }
                      catch (exn){
                        var error = getOrRethrow(exn);
                        return {
                                issues: [{
                                    message: message(error),
                                    path: error.path === "" ? undefined : toArray(error.path)
                                  }]
                              };
                      }
                    })
                };
        })
    });

function compile(schema, input, output, mode, typeValidationOpt) {
  var typeValidation = typeValidationOpt !== undefined ? typeValidationOpt : true;
  var flag = 0;
  var exit = 0;
  switch (output) {
    case "Output" :
    case "Input" :
        exit = 1;
        break;
    case "Assert" :
        flag = flag | 4;
        break;
    case "Json" :
        flag = flag | 8;
        break;
    case "JsonString" :
        flag = flag | 24;
        break;
    
  }
  if (exit === 1 && output === input) {
    throw new Error("[Sury] Can't compile operation to converting value to self");
  }
  if (mode !== "Sync") {
    flag = flag | 2;
  }
  if (typeValidation) {
    flag = flag | 1;
  }
  if (input === "Output") {
    flag = flag | 32;
  }
  var fn = operationFn(schema, flag);
  if (input !== "JsonString") {
    return fn;
  }
  var flag$1 = flag;
  return function (jsonString) {
    try {
      return fn(JSON.parse(jsonString));
    }
    catch (exn){
      throw new SuryError({
                TAG: "OperationFailed",
                _0: exn.message
              }, flag$1, "");
    }
  };
}

function item(factory, item$1) {
  return function () {
    var reversed = reverse(item$1);
    if (reversed === item$1) {
      return this;
    } else {
      return factory(reversed);
    }
  };
}

function parseOrThrow(any, schema) {
  return operationFn(schema, 1)(any);
}

function parseJsonStringOrThrow(jsonString, schema) {
  var tmp;
  try {
    tmp = JSON.parse(jsonString);
  }
  catch (exn){
    throw new SuryError({
              TAG: "OperationFailed",
              _0: exn.message
            }, 1, "");
  }
  return parseOrThrow(tmp, schema);
}

function parseAsyncOrThrow(any, schema) {
  return operationFn(schema, 3)(any);
}

function convertOrThrow(input, schema) {
  return operationFn(schema, 0)(input);
}

function convertToJsonOrThrow(any, schema) {
  return operationFn(schema, 8)(any);
}

function convertToJsonStringOrThrow(input, schema) {
  return operationFn(schema, 24)(input);
}

function convertAsyncOrThrow(any, schema) {
  return operationFn(schema, 2)(any);
}

function reverseConvertOrThrow(value, schema) {
  return operationFn(schema, 32)(value);
}

function reverseConvertToJsonOrThrow(value, schema) {
  return operationFn(schema, 40)(value);
}

function reverseConvertToJsonStringOrThrow(value, schema, spaceOpt) {
  var space = spaceOpt !== undefined ? spaceOpt : 0;
  return JSON.stringify(reverseConvertToJsonOrThrow(value, schema), null, space);
}

function assertOrThrow(any, schema) {
  return operationFn(schema, 5)(any);
}

var $$undefined = {
  type: "undefined",
  const: (void 0)
};

var $$null = {
  type: "null",
  const: null
};

function parse(value) {
  if (value === null) {
    return $$null;
  }
  var $$typeof = typeof value;
  var schema;
  if ($$typeof === "object") {
    var i = {
      type: "instance"
    };
    i.class = value.constructor;
    schema = i;
  } else {
    schema = $$typeof === "undefined" ? $$undefined : (
        $$typeof === "number" && Number.isNaN(value) ? ({
              type: "nan"
            }) : ({
              type: $$typeof
            })
      );
  }
  schema.const = value;
  return schema;
}

function isAsync(schema) {
  var v = schema.isAsync;
  if (v !== undefined) {
    return v;
  }
  try {
    var b = rootScope(2);
    var input = {
      b: b,
      v: _var,
      i: "i",
      a: false
    };
    var builder = schema.builder;
    var output = builder !== undefined ? builder(b, input, schema, "") : input;
    schema.isAsync = output.a;
    return output.a;
  }
  catch (exn){
    getOrRethrow(exn);
    return false;
  }
}

function wrapExnToFailure(exn) {
  if ((exn&&exn.s===s)) {
    return {
            success: false,
            error: exn
          };
  }
  throw exn;
}

function js_safe(fn) {
  try {
    return {
            success: true,
            value: fn()
          };
  }
  catch (exn){
    return wrapExnToFailure(exn);
  }
}

function js_safeAsync(fn) {
  try {
    return fn().then((function (value) {
                  return {
                          success: true,
                          value: value
                        };
                }), wrapExnToFailure);
  }
  catch (exn){
    return Promise.resolve(wrapExnToFailure(exn));
  }
}

function make$1(namespace, name) {
  return "m:" + namespace + ":" + name;
}

function internal(name) {
  return "m:" + name;
}

var Id = {
  make: make$1,
  internal: internal
};

function get$1(schema, id) {
  return schema[id];
}

function set$1(schema, id, metadata) {
  var mut = copy(schema);
  mut[id] = metadata;
  return new Schema(mut);
}

function recursive(fn) {
  var r = "r" + globalConfig.r;
  globalConfig.r = globalConfig.r + 1 | 0;
  var builder = function (b, input, param, param$1) {
    return transform(b, input, (function (_b, input) {
                  return map(r, input);
                }));
  };
  var output = function () {
    return {
            type: "unknown",
            builder: (function (_b, input, param, param$1) {
                return map(r, input);
              })
          };
  };
  var placeholder = {
    type: "unknown",
    builder: builder,
    name: "Self",
    output: output
  };
  var schema = fn(placeholder);
  mergeInPlace(placeholder, schema);
  placeholder.name = toExpression(schema);
  placeholder.builder = builder;
  placeholder.output = output;
  var initialParseOperationBuilder = schema.builder;
  schema.builder = (function (b, input, selfSchema, path) {
      var inputVar = input.v(b);
      var bb = {
        c: "",
        l: "",
        a: initialAllocate,
        g: b.g
      };
      var opOutput = initialParseOperationBuilder(bb, input, selfSchema, "");
      var opBodyCode = allocateScope(bb) + ("return " + opOutput.i);
      b.c = b.c + ("let " + r + "=" + inputVar + "=>{" + opBodyCode + "};");
      return withPathPrepend(b, input, path, undefined, undefined, (function (b, input, param) {
                    return transform(b, input, (function (_b, input) {
                                  var output = map(r, input);
                                  if (opOutput.a) {
                                    output.a = true;
                                    placeholder.builder = (function (b, input, param, param$1) {
                                        return transform(b, input, (function (_b, input) {
                                                      var output = map(r, input);
                                                      output.a = true;
                                                      return output;
                                                    }));
                                      });
                                  }
                                  return output;
                                }));
                  }));
    });
  var initialReverse = schema.output.bind(schema);
  schema.output = (function () {
      var initialReversed = initialReverse();
      var mut = copy(initialReversed);
      mut.output = schema;
      schema.output = mut;
      mut.builder = (function (b, input, selfSchema, path) {
          var inputVar = input.v(b);
          var bb = {
            c: "",
            l: "",
            a: initialAllocate,
            g: b.g
          };
          var initialInput = {
            b: bb,
            v: input.v,
            i: input.i,
            a: input.a
          };
          var opOutput = initialReversed.builder(bb, initialInput, selfSchema, "");
          var opBodyCode = allocateScope(bb) + ("return " + opOutput.i);
          b.c = b.c + ("let " + r + "=" + inputVar + "=>{" + opBodyCode + "};");
          return withPathPrepend(b, input, path, undefined, undefined, (function (_b, input, param) {
                        return map(r, input);
                      }));
        });
      return mut;
    });
  return new Schema(schema);
}

function noValidation(schema, value) {
  var mut = copy(schema);
  mut.noValidation = value;
  return new Schema(mut);
}

function internalRefine(schema, refiner) {
  var mut = copy(schema);
  mut.builder = (function (b, input, selfSchema, path) {
      var builder = schema.builder;
      return transform(b, builder !== undefined ? builder(b, input, schema, path) : input, (function (b, input) {
                    var bb = {
                      c: "",
                      l: "",
                      a: initialAllocate,
                      g: b.g
                    };
                    var rCode = refiner(bb, input.v(bb), selfSchema, path);
                    b.c = b.c + allocateScope(bb) + rCode;
                    return input;
                  }));
    });
  mut.output = (function () {
      var schema$1 = reverse(schema);
      var mut = copy(schema$1);
      mut.builder = (function (b, input, selfSchema, path) {
          var input$1 = transform(b, input, (function (b, input) {
                  b.c = b.c + refiner(b, input.v(b), selfSchema, path);
                  return input;
                }));
          var builder = schema$1.builder;
          if (builder !== undefined) {
            return builder(b, input$1, schema$1, path);
          } else {
            return input$1;
          }
        });
      return mut;
    });
  return new Schema(mut);
}

function refine(schema, refiner) {
  return internalRefine(schema, (function (b, inputVar, selfSchema, path) {
                return embed(b, refiner(effectCtx(b, selfSchema, path))) + "(" + inputVar + ");";
              }));
}

function addRefinement(schema, metadataId, refinement, refiner) {
  var refinements = schema[metadataId];
  return internalRefine(set$1(schema, metadataId, refinements !== undefined ? refinements.concat(refinement) : [refinement]), refiner);
}

function transform$1(schema, transformer) {
  var mut = copy(schema);
  mut.builder = (function (b, input, selfSchema, path) {
      var builder = schema.builder;
      var input$1 = builder !== undefined ? builder(b, input, schema, path) : input;
      var match = transformer(effectCtx(b, selfSchema, path));
      var parser = match.p;
      if (parser !== undefined) {
        if (match.a !== undefined) {
          return invalidOperation(b, path, "The S.transform doesn't allow parser and asyncParser at the same time. Remove parser in favor of asyncParser");
        } else {
          return embedSyncOperation(b, input$1, parser);
        }
      }
      var asyncParser = match.a;
      if (asyncParser !== undefined) {
        if (!(b.g.o & 2)) {
          raise(b, "UnexpectedAsync", "");
        }
        var val = embedSyncOperation(b, input$1, asyncParser);
        val.a = true;
        return val;
      } else if (match.s !== undefined) {
        return invalidOperation(b, path, "The S.transform parser is missing");
      } else {
        return input$1;
      }
    });
  mut.output = (function () {
      var schema$1 = reverse(schema);
      return {
              type: "unknown",
              builder: (function (b, input, selfSchema, path) {
                  var match = transformer(effectCtx(b, selfSchema, path));
                  var serializer = match.s;
                  if (serializer !== undefined) {
                    var input$1 = embedSyncOperation(b, input, serializer);
                    var builder = schema$1.builder;
                    if (builder !== undefined) {
                      return builder(b, input$1, schema$1, path);
                    } else {
                      return input$1;
                    }
                  }
                  if (match.a !== undefined) {
                    return invalidOperation(b, path, "The S.transform serializer is missing");
                  }
                  if (match.p !== undefined) {
                    return invalidOperation(b, path, "The S.transform serializer is missing");
                  }
                  var builder$1 = schema$1.builder;
                  if (builder$1 !== undefined) {
                    return builder$1(b, input, schema$1, path);
                  } else {
                    return input;
                  }
                })
            };
    });
  mut.isAsync = undefined;
  return new Schema(mut);
}

var unit = new Schema($$undefined);

function output() {
  return {
          type: "undefined",
          builder: (function (b, param, param$1, param$2) {
              return {
                      b: b,
                      v: _notVar,
                      i: "null",
                      a: false
                    };
            }),
          const: (void 0)
        };
}

var nullAsUnit = new Schema({
      type: "null",
      builder: (function (b, param, param$1, param$2) {
          return {
                  b: b,
                  v: _notVar,
                  i: "void 0",
                  a: false
                };
        }),
      const: null,
      output: output
    });

var unknown = new Schema({
      type: "unknown"
    });

function builder(b, input, selfSchema, path) {
  b.c = b.c + failWithArg(b, path, (function (input) {
          return {
                  TAG: "InvalidType",
                  expected: selfSchema,
                  received: input
                };
        }), input.i) + ";";
  return input;
}

var schema = new Schema({
      type: "never",
      builder: builder
    });

function getItemCode(b, schema, input, output, deopt, path) {
  try {
    var bb = {
      c: "",
      l: "",
      a: initialAllocate,
      g: b.g
    };
    if (deopt) {
      bb.c = bb.c + typeFilterCode(bb, schema, input, path);
    }
    var builder = schema.builder;
    var itemOutput = builder !== undefined ? builder(bb, input, schema, path) : input;
    if (itemOutput !== input) {
      itemOutput.b = bb;
      if (schema.type === "unknown") {
        var reversed = reverse(schema);
        bb.c = bb.c + typeFilterCode(bb, reversed, itemOutput, path);
      }
      if (itemOutput.a) {
        output.a = true;
      }
      bb.c = bb.c + (output.v(b) + "=" + itemOutput.i);
    }
    return allocateScope(bb);
  }
  catch (exn){
    return "throw " + embed(b, getOrRethrow(exn));
  }
}

function isPriority(tag, byKey) {
  if ((tag === "array" || tag === "instance") && byKey["object"]) {
    return true;
  } else if (tag === "nan") {
    return byKey["number"];
  } else {
    return false;
  }
}

function builder$1(b, input, selfSchema, path) {
  var fail = function (caught) {
    return embed(b, (function (param) {
                  var args = arguments;
                  return raise(b, {
                              TAG: "InvalidType",
                              expected: selfSchema,
                              received: args[0],
                              unionErrors: args.length > 1 ? Array.from(args).slice(1) : undefined
                            }, path);
                })) + "(" + input.v(b) + caught + ")";
  };
  var schemas = selfSchema.anyOf;
  var typeValidation = b.g.o & 1;
  var initialInline = input.i;
  var deoptIdx = -1;
  var lastIdx = schemas.length - 1 | 0;
  var byKey = {};
  var keys = [];
  for(var idx = 0; idx <= lastIdx; ++idx){
    var schema = schemas[idx];
    var tag = schema.type;
    var exit = 0;
    switch (tag) {
      case "never" :
      case "unknown" :
      case "union" :
      case "json" :
          exit = 1;
          break;
      default:
        var key = tag === "instance" ? schema.class.name : tag;
        var arr = byKey[key];
        if (arr !== undefined) {
          if (tag !== "undefined" && tag !== "null" && tag !== "nan") {
            arr.push(schema);
          }
          
        } else {
          if (isPriority(tag, byKey)) {
            keys.unshift(key);
          } else {
            keys.push(key);
          }
          byKey[key] = [schema];
        }
    }
    if (exit === 1) {
      deoptIdx = idx;
      byKey = {};
      keys = [];
    }
    
  }
  var deoptIdx$1 = deoptIdx;
  var byKey$1 = byKey;
  var keys$1 = keys;
  var start = "";
  var end = "";
  var caught = "";
  var exit$1 = false;
  if (deoptIdx$1 !== -1) {
    for(var idx$1 = 0; idx$1 <= deoptIdx$1; ++idx$1){
      if (!exit$1) {
        var schema$1 = schemas[idx$1];
        var itemCode = getItemCode(b, schema$1, input, input, true, path);
        if (itemCode) {
          var errorVar = "e" + idx$1;
          start = start + ("try{" + itemCode + "}catch(" + errorVar + "){");
          end = "}" + end;
          caught = caught + "," + errorVar;
        } else {
          exit$1 = true;
        }
      }
      
    }
  }
  if (!exit$1) {
    var nextElse = false;
    var noop = "";
    for(var idx$2 = 0 ,idx_finish = keys$1.length; idx$2 < idx_finish; ++idx$2){
      var schemas$1 = byKey$1[keys$1[idx$2]];
      var inputVar = input.v(b);
      var isMultiple = schemas$1.length > 1;
      var firstSchema = schemas$1[0];
      var cond = "";
      var body;
      if (isMultiple) {
        var itemStart = "";
        var itemEnd = "";
        var itemNextElse = false;
        var itemNoop = "";
        var caught$1 = "";
        var byDiscriminant = {};
        var itemIdx = 0;
        var lastIdx$1 = schemas$1.length - 1 | 0;
        while(itemIdx <= lastIdx$1) {
          var schema$2 = schemas$1[itemIdx];
          var itemCond = (
            isLiteral(schema$2) ? validation(b, inputVar, schema$2, false) : ""
          ) + refinement(b, inputVar, schema$2, false).slice(2);
          var itemCode$1 = getItemCode(b, schema$2, input, input, false, path);
          if (itemCond) {
            if (itemCode$1) {
              var match = byDiscriminant[itemCond];
              if (match !== undefined) {
                if (typeof match === "string") {
                  byDiscriminant[itemCond] = [
                    match,
                    itemCode$1
                  ];
                } else {
                  match.push(itemCode$1);
                }
              } else {
                byDiscriminant[itemCond] = itemCode$1;
              }
            } else {
              itemNoop = itemNoop ? itemNoop + "||" + itemCond : itemCond;
            }
          }
          if (!itemCond || itemIdx === lastIdx$1) {
            var accedDiscriminants = Object.keys(byDiscriminant);
            for(var idx$3 = 0 ,idx_finish$1 = accedDiscriminants.length; idx$3 < idx_finish$1; ++idx$3){
              var discrim = accedDiscriminants[idx$3];
              var if_ = itemNextElse ? "else if" : "if";
              itemStart = itemStart + if_ + ("(" + discrim + "){");
              var code = byDiscriminant[discrim];
              if (typeof code === "string") {
                itemStart = itemStart + code + "}";
              } else {
                var caught$2 = "";
                for(var idx$4 = 0 ,idx_finish$2 = code.length; idx$4 < idx_finish$2; ++idx$4){
                  var code$1 = code[idx$4];
                  var errorVar$1 = "e" + idx$4;
                  itemStart = itemStart + ("try{" + code$1 + "}catch(" + errorVar$1 + "){");
                  caught$2 = caught$2 + "," + errorVar$1;
                }
                itemStart = itemStart + fail(caught$2) + "}".repeat(code.length) + "}";
              }
              itemNextElse = true;
            }
            byDiscriminant = {};
          }
          if (!itemCond) {
            if (itemCode$1) {
              if (itemNoop) {
                var if_$1 = itemNextElse ? "else if" : "if";
                itemStart = itemStart + if_$1 + ("(!(" + itemNoop + ")){");
                itemEnd = "}" + itemEnd;
                itemNoop = "";
                itemNextElse = false;
              }
              var errorVar$2 = "e" + itemIdx;
              itemStart = itemStart + ((
                  itemNextElse ? "else{" : ""
                ) + "try{" + itemCode$1 + "}catch(" + errorVar$2 + "){");
              itemEnd = (
                itemNextElse ? "}" : ""
              ) + "}" + itemEnd;
              caught$1 = caught$1 + "," + errorVar$2;
              itemNextElse = false;
            } else {
              itemNoop = "";
              itemIdx = lastIdx$1;
            }
          }
          itemIdx = itemIdx + 1;
        };
        cond = validation(b, inputVar, {
              type: firstSchema.type,
              builder: 0
            }, false);
        if (itemNoop) {
          if (itemStart) {
            if (typeValidation) {
              var if_$2 = itemNextElse ? "else if" : "if";
              itemStart = itemStart + if_$2 + ("(!(" + itemNoop + ")){" + fail(caught$1) + "}");
            }
            
          } else {
            cond = cond + ("&&(" + itemNoop + ")");
          }
        } else if (typeValidation && itemStart) {
          var errorCode = fail(caught$1);
          itemStart = itemStart + (
            itemNextElse ? "else{" + errorCode + "}" : errorCode
          );
        }
        body = itemStart + itemEnd;
      } else {
        cond = validation(b, inputVar, firstSchema, false) + refinement(b, inputVar, firstSchema, false);
        body = getItemCode(b, firstSchema, input, input, false, path);
      }
      var cond$1 = cond;
      if (body || isPriority(firstSchema.type, byKey$1)) {
        var if_$3 = nextElse ? "else if" : "if";
        start = start + if_$3 + ("(" + cond$1 + "){" + body + "}");
        nextElse = true;
      } else {
        noop = noop ? noop + "||" + cond$1 : cond$1;
      }
    }
    if (typeValidation || deoptIdx$1 === lastIdx) {
      var errorCode$1 = fail(caught);
      var tmp;
      if (noop) {
        var if_$4 = nextElse ? "else if" : "if";
        tmp = if_$4 + ("(!(" + noop + ")){" + errorCode$1 + "}");
      } else {
        tmp = nextElse ? "else{" + errorCode$1 + "}" : errorCode$1;
      }
      start = start + tmp;
    }
    
  }
  b.c = b.c + start + end;
  if (input.a) {
    return {
            b: b,
            v: _notVar,
            i: "Promise.resolve(" + input.i + ")",
            a: true
          };
  } else if (input.v === _var) {
    if (b.c === "" && input.b.c === "" && (input.b.l === input.i + "=" + initialInline || initialInline === "i")) {
      input.b.l = "";
      input.b.a = initialAllocate;
      input.v = _notVar;
      input.i = initialInline;
      return input;
    } else {
      return {
              b: input.b,
              v: input.v,
              i: input.i,
              a: input.a
            };
    }
  } else {
    return input;
  }
}

function factory(schemas) {
  var len = schemas.length;
  if (len === 1) {
    return schemas[0];
  }
  if (len !== 0) {
    var has = {};
    var anyOf = new Set();
    for(var idx = 0 ,idx_finish = schemas.length; idx < idx_finish; ++idx){
      var schema = schemas[idx];
      if (schema.type === "union" && schema.builder === builder$1) {
        schema.anyOf.forEach(function (item) {
              anyOf.add(item);
            });
        Object.assign(has, schema.has);
      } else {
        anyOf.add(schema);
        var v = schema.type;
        var tmp;
        switch (v) {
          case "union" :
          case "json" :
              tmp = "unknown";
              break;
          default:
            tmp = v;
        }
        has[tmp] = true;
      }
    }
    return new Schema({
                type: "union",
                builder: builder$1,
                has: has,
                anyOf: Array.from(anyOf),
                output: output$1
              });
  }
  throw new Error("[Sury] S.union requires at least one item");
}

function output$1() {
  var schemas = this.anyOf;
  var items = [];
  var toSelf = true;
  for(var idx = 0 ,idx_finish = schemas.length; idx < idx_finish; ++idx){
    var schema = schemas[idx];
    var reversed = reverse(schema);
    items[idx] = reversed;
    toSelf = toSelf && schema === reversed;
  }
  if (toSelf) {
    return this;
  } else {
    return factory(items);
  }
}

var defaultMetadataId = "m:Option.default";

function $$default(schema) {
  return schema[defaultMetadataId];
}

var nestedLoc = "BS_PRIVATE_NESTED_SOME_NONE";

var inLoc = "\"" + nestedLoc + "\"";

function nestedNone() {
  var item_schema = parse(0);
  var item = {
    schema: item_schema,
    location: nestedLoc,
    inlinedLocation: inLoc
  };
  var fields = {};
  fields[nestedLoc] = item;
  return {
          type: "object",
          builder: (function (b, param, selfSchema, param$1) {
              return {
                      b: b,
                      v: _notVar,
                      i: inlineConst(b, reverse(selfSchema)),
                      a: false
                    };
            }),
          additionalItems: "strip",
          items: [item],
          fields: fields
        };
}

function builder$2(b, param, selfSchema, param$1) {
  return {
          b: b,
          v: _notVar,
          i: "{" + inLoc + ":" + reverse(selfSchema).items[0].schema.const + "}",
          a: false
        };
}

function nestedOption(item) {
  var mut = copy(item);
  mut.output = nestedNone;
  mut.builder = builder$2;
  return mut;
}

function factory$1(item, unitOpt) {
  var unit$1 = unitOpt !== undefined ? unitOpt : unit;
  var reversed = reverse(item);
  var match = reversed.type;
  switch (match) {
    case "undefined" :
        return factory([
                    unit$1,
                    nestedOption(item)
                  ]);
    case "union" :
        var has = reversed.has;
        if (!has["undefined"]) {
          return factory([
                      item,
                      unit$1
                    ]);
        }
        var mut = copy(reversed);
        var schemas = mut.anyOf;
        var has$1 = mut.has;
        var anyOf = [];
        for(var idx = 0 ,idx_finish = schemas.length; idx < idx_finish; ++idx){
          var schema = schemas[idx];
          var match$1 = schema.type;
          var tmp;
          if (match$1 === "undefined") {
            if (!has$1["object"]) {
              var d = {};
              d["object"] = true;
              mut.has = Object.assign(d, has$1);
            }
            anyOf.push(reverse(unit$1));
            tmp = reverse(nestedOption(reverse(schema)));
          } else {
            var fields = schema.fields;
            if (fields !== undefined) {
              var item$1 = fields[nestedLoc];
              if (item$1 !== undefined) {
                var fSchema = item$1.schema;
                var newItem_schema = {
                  type: fSchema.type,
                  builder: fSchema.builder,
                  const: fSchema.const + 1
                };
                var newItem_location = item$1.location;
                var newItem_inlinedLocation = item$1.inlinedLocation;
                var newItem = {
                  schema: newItem_schema,
                  location: newItem_location,
                  inlinedLocation: newItem_inlinedLocation
                };
                var mut$1 = copy(schema);
                var fields$1 = {};
                fields$1[nestedLoc] = newItem;
                mut$1.items = [newItem];
                mut$1.fields = fields$1;
                reverse(mut$1).output = mut$1;
                tmp = mut$1;
              } else {
                tmp = schema;
              }
            } else {
              tmp = schema;
            }
          }
          anyOf.push(tmp);
        }
        mut.anyOf = anyOf;
        mut.output = output$1;
        return reverse(mut);
    default:
      return factory([
                  item,
                  unit$1
                ]);
  }
}

function getWithDefault(schema, $$default) {
  var mut = copy(schema);
  mut[defaultMetadataId] = $$default;
  mut.builder = (function (b, input, param, path) {
      var builder = schema.builder;
      return transform(b, builder !== undefined ? builder(b, input, schema, path) : input, (function (b, input) {
                    var inputVar = input.v(b);
                    var tmp;
                    tmp = $$default.TAG === "Value" ? embed(b, $$default._0) : embed(b, $$default._0) + "()";
                    return {
                            b: b,
                            v: _notVar,
                            i: inputVar + "===void 0?" + tmp + ":" + inputVar,
                            a: false
                          };
                  }));
    });
  mut.output = (function () {
      var reversed = reverse(schema);
      var anyOf = reversed.anyOf;
      if (anyOf !== undefined) {
        return factory(anyOf.filter(function (s) {
                        return !isOptional(s);
                      }));
      } else {
        return reversed;
      }
    });
  return new Schema(mut);
}

function getOr(schema, defalutValue) {
  return getWithDefault(schema, {
              TAG: "Value",
              _0: defalutValue
            });
}

function getOrWith(schema, defalutCb) {
  return getWithDefault(schema, {
              TAG: "Callback",
              _0: defalutCb
            });
}

var metadataId = "m:Array.refinements";

function refinements(schema) {
  var m = schema[metadataId];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

function factory$2(item$1) {
  return new Schema({
              type: "array",
              builder: (function (b, input, param, path) {
                  var inputVar = input.v(b);
                  var iteratorVar = varWithoutAllocation(b.g);
                  var bb = {
                    c: "",
                    l: "",
                    a: initialAllocate,
                    g: b.g
                  };
                  var itemInput = {
                    b: bb,
                    v: _notVar,
                    i: inputVar + "[" + iteratorVar + "]",
                    a: false
                  };
                  var itemOutput = withPathPrepend(bb, itemInput, path, iteratorVar, undefined, (function (b, input, path) {
                          return parseWithTypeValidation(b, item$1, input, path);
                        }));
                  var itemCode = allocateScope(bb);
                  var isTransformed = itemInput !== itemOutput;
                  var output = isTransformed ? ({
                        b: b,
                        v: _notVar,
                        i: "new Array(" + inputVar + ".length)",
                        a: false
                      }) : input;
                  if (isTransformed || itemCode !== "") {
                    b.c = b.c + ("for(let " + iteratorVar + "=0;" + iteratorVar + "<" + inputVar + ".length;++" + iteratorVar + "){" + itemCode + (
                        isTransformed ? addKey(b, output, iteratorVar, itemOutput) : ""
                      ) + "}");
                  }
                  if (itemOutput.a) {
                    return {
                            b: output.b,
                            v: _notVar,
                            i: "Promise.all(" + output.i + ")",
                            a: true
                          };
                  } else {
                    return output;
                  }
                }),
              additionalItems: item$1,
              items: immutableEmpty$1,
              output: item(factory$2, item$1)
            });
}

function setAdditionalItems(schema, additionalItems, deep) {
  var currentAdditionalItems = schema.additionalItems;
  if (currentAdditionalItems === undefined) {
    return schema;
  }
  var items = schema.items;
  if (!(currentAdditionalItems !== additionalItems && typeof currentAdditionalItems !== "object")) {
    return schema;
  }
  var mut = copy(schema);
  mut.additionalItems = additionalItems;
  if (deep) {
    var newItems = [];
    var newFields = {};
    for(var idx = 0 ,idx_finish = items.length; idx < idx_finish; ++idx){
      var item = items[idx];
      var newSchema = setAdditionalItems(item.schema, additionalItems, deep);
      var newItem = newSchema === item.schema ? item : ({
            schema: newSchema,
            location: item.location,
            inlinedLocation: item.inlinedLocation
          });
      newFields[item.location] = newItem;
      newItems.push(newItem);
    }
    mut.items = newItems;
    mut.fields = newFields;
  }
  return new Schema(mut);
}

function strip(schema) {
  return setAdditionalItems(schema, "strip", false);
}

function deepStrip(schema) {
  return setAdditionalItems(schema, "strip", true);
}

function strict(schema) {
  return setAdditionalItems(schema, "strict", false);
}

function deepStrict(schema) {
  return setAdditionalItems(schema, "strict", true);
}

function factory$3(item$1) {
  return new Schema({
              type: "object",
              builder: (function (b, input, param, path) {
                  var inputVar = input.v(b);
                  var keyVar = varWithoutAllocation(b.g);
                  var bb = {
                    c: "",
                    l: "",
                    a: initialAllocate,
                    g: b.g
                  };
                  var itemInput = {
                    b: bb,
                    v: _notVar,
                    i: inputVar + "[" + keyVar + "]",
                    a: false
                  };
                  var itemOutput = withPathPrepend(bb, itemInput, path, keyVar, undefined, (function (b, input, path) {
                          return parseWithTypeValidation(b, item$1, input, path);
                        }));
                  var itemCode = allocateScope(bb);
                  var isTransformed = itemInput !== itemOutput;
                  var output = isTransformed ? ({
                        b: b,
                        v: _notVar,
                        i: "{}",
                        a: false
                      }) : input;
                  if (isTransformed || itemCode !== "") {
                    b.c = b.c + ("for(let " + keyVar + " in " + inputVar + "){" + itemCode + (
                        isTransformed ? addKey(b, output, keyVar, itemOutput) : ""
                      ) + "}");
                  }
                  if (!itemOutput.a) {
                    return output;
                  }
                  var resolveVar = varWithoutAllocation(b.g);
                  var rejectVar = varWithoutAllocation(b.g);
                  var asyncParseResultVar = varWithoutAllocation(b.g);
                  var counterVar = varWithoutAllocation(b.g);
                  var outputVar = output.v(b);
                  return {
                          b: b,
                          v: _notVar,
                          i: "new Promise((" + resolveVar + "," + rejectVar + ")=>{let " + counterVar + "=Object.keys(" + outputVar + ").length;for(let " + keyVar + " in " + outputVar + "){" + outputVar + "[" + keyVar + "].then(" + asyncParseResultVar + "=>{" + outputVar + "[" + keyVar + "]=" + asyncParseResultVar + ";if(" + counterVar + "--===1){" + resolveVar + "(" + outputVar + ")}}," + rejectVar + ")}})",
                          a: true
                        };
                }),
              additionalItems: item$1,
              items: immutableEmpty$1,
              fields: immutableEmpty,
              output: item(factory$3, item$1)
            });
}

var Tuple = {};

var metadataId$1 = "m:String.refinements";

function refinements$1(schema) {
  var m = schema[metadataId$1];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

var cuidRegex = /^c[^\s-]{8,}$/i;

var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;

var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;

var datetimeRe = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/;

var schema$1 = new Schema({
      type: "string"
    });

function factory$4(item, spaceOpt) {
  var space = spaceOpt !== undefined ? spaceOpt : 0;
  return new Schema({
              type: "string",
              builder: (function (b, input, param, path) {
                  var jsonVal = allocateVal(b);
                  b.c = b.c + ("try{" + jsonVal.i + "=JSON.parse(" + input.i + ")}catch(t){" + failWithArg(b, path, (function (message) {
                            return {
                                    TAG: "OperationFailed",
                                    _0: message
                                  };
                          }), "t.message") + "}");
                  return parseWithTypeValidation(b, item, jsonVal, path);
                }),
              output: (function () {
                  var reversed = reverse(item);
                  var mut = copy(reversed);
                  mut.builder = (function (b, input, param, path) {
                      var prevFlag = b.g.o;
                      b.g.o = prevFlag | 8;
                      jsonableValidation(reversed, reversed, "", b.g.o, undefined);
                      var builder = reversed.builder;
                      var output = {
                        b: b,
                        v: _notVar,
                        i: "JSON.stringify(" + (
                          builder !== undefined ? builder(b, input, reversed, path) : input
                        ).i + (
                          space > 0 ? ",null," + space : ""
                        ) + ")",
                        a: false
                      };
                      b.g.o = prevFlag;
                      return output;
                    });
                  return mut;
                })
            });
}

var bool = new Schema({
      type: "boolean"
    });

var symbol = new Schema({
      type: "symbol"
    });

var metadataId$2 = "m:Int.refinements";

function refinements$2(schema) {
  var m = schema[metadataId$2];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

var schema$2 = new Schema({
      type: "number",
      format: "int32"
    });

var metadataId$3 = "m:Float.refinements";

function refinements$3(schema) {
  var m = schema[metadataId$3];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

var schema$3 = new Schema({
      type: "number"
    });

var schema$4 = new Schema({
      type: "bigint"
    });

function to(from, target) {
  if (from === target) {
    return from;
  }
  var anyOf = target.anyOf;
  if (anyOf !== undefined) {
    return factory(anyOf.map(function (target) {
                    return to(from, target);
                  }));
  }
  var extendCoercion = 0;
  var shrinkCoercion = 1;
  var fromOutput = reverse(from);
  var isFromLiteral = isLiteral(from);
  var isTargetLiteral = isLiteral(target);
  var fromTag = fromOutput.type;
  var coercion;
  var exit = 0;
  var exit$1 = 0;
  var targetTag = target.type;
  if (isFromLiteral && isTargetLiteral) {
    coercion = (function (b, param, param$1) {
        return {
                b: b,
                v: _notVar,
                i: inlineConst(b, target),
                a: false
              };
      });
  } else if (fromTag === targetTag && isFromLiteral && !isTargetLiteral || targetTag === "unknown") {
    coercion = extendCoercion;
  } else {
    switch (fromTag) {
      case "string" :
          var match = target.type;
          var exit$2 = 0;
          switch (match) {
            case "string" :
                var match$1 = target.const;
                coercion = match$1 !== undefined ? shrinkCoercion : extendCoercion;
                break;
            case "number" :
            case "bigint" :
            case "boolean" :
            case "null" :
            case "undefined" :
            case "nan" :
                exit$2 = 3;
                break;
            default:
              exit = 1;
          }
          if (exit$2 === 3) {
            var $$const = target.const;
            if (isTargetLiteral) {
              coercion = (function (b, inputVar, failCoercion) {
                  b.c = b.c + (inputVar + "===\"" + $$const + "\"||" + failCoercion + ";");
                  return {
                          b: b,
                          v: _notVar,
                          i: inlineConst(b, target),
                          a: false
                        };
                });
            } else {
              switch (match) {
                case "number" :
                    var format = target.format;
                    coercion = (function (b, inputVar, failCoercion) {
                        var output = {
                          b: b,
                          v: _notVar,
                          i: "+" + inputVar,
                          a: false
                        };
                        var outputVar = output.v(b);
                        b.c = b.c + (
                          format !== undefined ? "(" + refinement(b, outputVar, target, true).slice(2) + ")" : "Number.isNaN(" + outputVar + ")"
                        ) + ("&&" + failCoercion + ";");
                        return output;
                      });
                    break;
                case "bigint" :
                    coercion = (function (b, inputVar, failCoercion) {
                        var output = allocateVal(b);
                        b.c = b.c + ("try{" + output.i + "=BigInt(" + inputVar + ")}catch(_){" + failCoercion + "}");
                        return output;
                      });
                    break;
                case "boolean" :
                    coercion = (function (b, inputVar, failCoercion) {
                        var output = allocateVal(b);
                        b.c = b.c + ("(" + output.i + "=" + inputVar + "===\"true\")||" + inputVar + "===\"false\"||" + failCoercion + ";");
                        return output;
                      });
                    break;
                default:
                  exit = 1;
              }
            }
          }
          break;
      case "number" :
          var match$2 = fromOutput.format;
          if (match$2 === "int32") {
            var match$3 = target.type;
            if (match$3 === "number") {
              var match$4 = target.format;
              if (match$4 !== undefined) {
                exit$1 = 2;
              } else {
                coercion = extendCoercion;
              }
            } else {
              exit$1 = 2;
            }
          } else {
            exit$1 = 2;
          }
          break;
      case "unknown" :
          coercion = shrinkCoercion;
          break;
      case "bigint" :
      case "boolean" :
      case "null" :
      case "undefined" :
      case "nan" :
          exit$1 = 2;
          break;
      default:
        exit = 1;
    }
  }
  if (exit$1 === 2) {
    var $$const$1 = fromOutput.const;
    var match$5 = target.type;
    if (match$5 === "string") {
      if (isFromLiteral) {
        coercion = (function (b, param, param$1) {
            return {
                    b: b,
                    v: _notVar,
                    i: "\"" + $$const$1 + "\"",
                    a: false
                  };
          });
      } else {
        var exit$3 = 0;
        switch (fromTag) {
          case "number" :
          case "bigint" :
          case "boolean" :
              exit$3 = 3;
              break;
          default:
            exit = 1;
        }
        if (exit$3 === 3) {
          var match$6 = target.type;
          if (match$6 === "string") {
            coercion = (function (b, inputVar, param) {
                return {
                        b: b,
                        v: _notVar,
                        i: "\"\"+" + inputVar,
                        a: false
                      };
              });
          } else {
            exit = 1;
          }
        }
        
      }
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    var message = "S.to from " + toExpression(fromOutput) + " to " + toExpression(target) + " is not supported";
    throw new Error("[Sury] " + message);
  }
  var mut = copy(from);
  mut.builder = (function (b, input, param, path) {
      var builder = from.builder;
      var input$1 = builder !== undefined ? builder(b, input, from, path) : input;
      if (coercion === extendCoercion) {
        var builder$1 = target.builder;
        if (builder$1 !== undefined) {
          return builder$1(b, input$1, target, path);
        } else {
          return input$1;
        }
      }
      if (coercion === shrinkCoercion) {
        return parseWithTypeValidation(b, target, input$1, path);
      }
      var bb = {
        c: "",
        l: "",
        a: initialAllocate,
        g: b.g
      };
      var inputVar = input$1.v(bb);
      var input$2 = coercion(bb, inputVar, failWithArg(bb, path, (function (input) {
                  return {
                          TAG: "InvalidType",
                          expected: target,
                          received: input
                        };
                }), inputVar));
      var builder$2 = target.builder;
      var output = builder$2 !== undefined ? builder$2(bb, input$2, target, path) : input$2;
      b.c = b.c + allocateScope(bb);
      return output;
    });
  mut.output = (function () {
      return to(reverse(target), fromOutput);
    });
  return new Schema(mut);
}

function list(schema) {
  return transform$1(factory$2(schema), (function (param) {
                return {
                        p: Belt_List.fromArray,
                        s: Belt_List.toArray
                      };
              }));
}

function instance(class_) {
  return new Schema({
              type: "instance",
              class: class_
            });
}

function json(validate) {
  return new Schema({
              type: "json",
              builder: validate ? (function (b, input, selfSchema, path) {
                    var parse = function (input, pathOpt) {
                      var path$1 = pathOpt !== undefined ? pathOpt : path;
                      var match = typeof input;
                      if (match === "string" || match === "boolean") {
                        return input;
                      }
                      if (match === "object") {
                        if (input === null) {
                          return input;
                        }
                        if (Array.isArray(input)) {
                          var output = [];
                          for(var idx = 0 ,idx_finish = input.length; idx < idx_finish; ++idx){
                            var inputItem = input[idx];
                            var $$location = idx.toString();
                            output.push(parse(inputItem, path$1 + ("[" + fromString($$location) + "]")));
                          }
                          return output;
                        }
                        var keys = Object.keys(input);
                        var output$1 = {};
                        for(var idx$1 = 0 ,idx_finish$1 = keys.length; idx$1 < idx_finish$1; ++idx$1){
                          var key = keys[idx$1];
                          var field = input[key];
                          output$1[key] = parse(field, path$1 + ("[" + fromString(key) + "]"));
                        }
                        return output$1;
                      }
                      if (match === "number" && !Number.isNaN(input)) {
                        return input;
                      }
                      return raise(b, {
                                  TAG: "InvalidType",
                                  expected: selfSchema,
                                  received: input
                                }, path$1);
                    };
                    return map(embed(b, parse), input);
                  }) : undefined,
              output: (function () {
                  if (validate) {
                    return json(false);
                  } else {
                    return this;
                  }
                })
            });
}

var Catch = {};

function $$catch(schema, getFallbackValue) {
  var mut = copy(schema);
  mut.builder = (function (b, input, selfSchema, path) {
      var inputVar = input.v(b);
      return withCatch(b, input, (function (b, errorVar) {
                    return {
                            b: b,
                            v: _notVar,
                            i: embed(b, (function (input, internalError) {
                                    return getFallbackValue({
                                                e: internalError,
                                                i: input,
                                                s: selfSchema,
                                                f: (function (message, customPathOpt) {
                                                    var customPath = customPathOpt !== undefined ? customPathOpt : "";
                                                    return raise(b, {
                                                                TAG: "OperationFailed",
                                                                _0: message
                                                              }, path + customPath);
                                                  })
                                              });
                                  })) + "(" + inputVar + "," + errorVar + ")",
                            a: false
                          };
                  }), undefined, (function (b) {
                    return parseWithTypeValidation(b, schema, input, path);
                  }));
    });
  mut.noValidation = true;
  mut.catch = true;
  return new Schema(mut);
}

function meta(schema, data) {
  var mut = copy(schema);
  var name = data.name;
  if (name !== undefined) {
    if (name === "") {
      mut.name = undefined;
    } else {
      mut.name = name;
    }
  }
  var title = data.title;
  if (title !== undefined) {
    if (title === "") {
      mut.title = undefined;
    } else {
      mut.title = title;
    }
  }
  var description = data.description;
  if (description !== undefined) {
    if (description === "") {
      mut.description = undefined;
    } else {
      mut.description = description;
    }
  }
  var deprecated = data.deprecated;
  if (deprecated !== undefined) {
    mut.deprecated = deprecated;
  }
  var examples = data.examples;
  if (examples !== undefined) {
    if (examples.length !== 0) {
      mut.examples = examples.map(operationFn(schema, 32));
    } else {
      mut.examples = undefined;
    }
  }
  return new Schema(mut);
}

function getFullDitemPath(ditem) {
  switch (ditem.k) {
    case 0 :
        return "[" + ditem.inlinedLocation + "]";
    case 1 :
        return getFullDitemPath(ditem.of) + ditem.p;
    case 2 :
        return ditem.p;
    
  }
}

function getItemReversed(item) {
  switch (item.k) {
    case 1 :
        var schema = item.schema;
        var $$location = item.location;
        if (schema !== undefined) {
          return reverse(schema);
        }
        var targetReversed = getItemReversed(item.of);
        var items = targetReversed.items;
        var fields = targetReversed.fields;
        var maybeReversedItem = fields !== undefined ? fields[$$location] : items[$$location];
        if (maybeReversedItem === undefined) {
          var message = "Impossible to reverse the " + item.inlinedLocation + " access of '" + toExpression(targetReversed) + "' schema";
          throw new Error("[Sury] " + message);
        }
        return maybeReversedItem.schema;
    case 0 :
    case 2 :
        return reverse(item.schema);
    
  }
}

function definitionToOutput(b, definition, getItemOutput) {
  if (!(typeof definition === "object" && definition !== null)) {
    return {
            b: b,
            v: _var,
            i: embed(b, definition),
            a: false
          };
  }
  var item = definition[itemSymbol];
  if (item !== undefined) {
    return getItemOutput(item);
  }
  var isArray = Array.isArray(definition);
  var keys = Object.keys(definition);
  var objectVal = make(b, isArray);
  for(var idx = 0 ,idx_finish = keys.length; idx < idx_finish; ++idx){
    var key = keys[idx];
    add(objectVal, isArray ? "\"" + key + "\"" : fromString(key), definitionToOutput(b, definition[key], getItemOutput));
  }
  return complete(objectVal, isArray);
}

function objectStrictModeCheck(b, input, items, selfSchema, path) {
  if (!(selfSchema.type === "object" && selfSchema.additionalItems === "strict" && b.g.o & 1)) {
    return ;
  }
  var key = allocateVal(b);
  var keyVar = key.i;
  b.c = b.c + ("for(" + keyVar + " in " + input.i + "){if(");
  if (items.length !== 0) {
    for(var idx = 0 ,idx_finish = items.length; idx < idx_finish; ++idx){
      var match = items[idx];
      if (idx !== 0) {
        b.c = b.c + "&&";
      }
      b.c = b.c + (keyVar + "!==" + match.inlinedLocation);
    }
  } else {
    b.c = b.c + "true";
  }
  b.c = b.c + ("){" + failWithArg(b, path, (function (exccessFieldName) {
            return {
                    TAG: "ExcessField",
                    _0: exccessFieldName
                  };
          }), keyVar) + "}}");
}

function proxify(item) {
  return new Proxy(immutableEmpty, {
              get: (function (param, prop) {
                  if (prop === itemSymbol) {
                    return item;
                  }
                  var inlinedLocation = fromString(prop);
                  return proxify({
                              k: 1,
                              inlinedLocation: inlinedLocation,
                              location: prop,
                              of: item,
                              p: "[" + inlinedLocation + "]"
                            });
                })
            });
}

function builder$3(parentB, input, selfSchema, path) {
  var additionalItems = selfSchema.additionalItems;
  var items = selfSchema.items;
  var isArray = selfSchema.type === "array";
  if (parentB.g.o & 64) {
    var objectVal = make(parentB, isArray);
    for(var idx = 0 ,idx_finish = items.length; idx < idx_finish; ++idx){
      var match = items[idx];
      var inlinedLocation = match.inlinedLocation;
      add(objectVal, inlinedLocation, input[inlinedLocation]);
    }
    return complete(objectVal, isArray);
  }
  var b = {
    c: "",
    l: "",
    a: initialAllocate,
    g: parentB.g
  };
  var objectVal$1 = make(b, isArray);
  for(var idx$1 = 0 ,idx_finish$1 = items.length; idx$1 < idx_finish$1; ++idx$1){
    var match$1 = items[idx$1];
    var inlinedLocation$1 = match$1.inlinedLocation;
    var schema = match$1.schema;
    var itemPath = "[" + inlinedLocation$1 + "]";
    var itemInput = get(b, input, inlinedLocation$1);
    var path$1 = path + itemPath;
    if (b.g.o & 1 && !isLiteral(schema) && schema.type !== "object") {
      b.c = b.c + typeFilterCode(b, schema, itemInput, path$1);
    }
    var builder$4 = schema.builder;
    add(objectVal$1, inlinedLocation$1, builder$4 !== undefined ? builder$4(b, itemInput, schema, path$1) : itemInput);
  }
  objectStrictModeCheck(b, input, items, selfSchema, path);
  parentB.c = parentB.c + allocateScope(b);
  if ((additionalItems !== "strip" || b.g.o & 32) && selfSchema === reverse(selfSchema)) {
    objectVal$1.v = input.v;
    objectVal$1.i = input.i;
    objectVal$1.a = input.a;
    return objectVal$1;
  } else {
    return complete(objectVal$1, isArray);
  }
}

function nested(fieldName) {
  var parentCtx = this;
  var cacheId = "~" + fieldName;
  var ctx = parentCtx[cacheId];
  if (ctx !== undefined) {
    return Caml_option.valFromOption(ctx);
  }
  var schemas = [];
  var fields = {};
  var items = [];
  var schema = new Schema({
        type: "object",
        builder: builder$3,
        additionalItems: globalConfig.a,
        items: items,
        fields: fields,
        output: output$2
      });
  var target = parentCtx.f(fieldName, schema)[itemSymbol];
  var field = function (fieldName, schema) {
    var inlinedLocation = fromString(fieldName);
    if (fields[fieldName]) {
      throw new Error("[Sury] " + ("The field " + inlinedLocation + " defined twice"));
    }
    var ditem_2 = schema;
    var ditem_4 = "[" + inlinedLocation + "]";
    var ditem = {
      k: 1,
      inlinedLocation: inlinedLocation,
      location: fieldName,
      schema: ditem_2,
      of: target,
      p: ditem_4
    };
    fields[fieldName] = ditem;
    items.push(ditem);
    schemas.push(schema);
    return proxify(ditem);
  };
  var tag = function (tag$1, asValue) {
    field(tag$1, definitionToSchema(asValue));
  };
  var fieldOr = function (fieldName, schema, or) {
    return field(fieldName, getOr(factory$1(schema, undefined), or));
  };
  var flatten = function (schema) {
    var match = schema.type;
    if (match === "object") {
      var advanced = schema.advanced;
      var flattenedItems = schema.items;
      if (advanced) {
        var message = "Unsupported nested flatten for advanced object schema '" + toExpression(schema) + "'";
        throw new Error("[Sury] " + message);
      }
      var match$1 = reverse(schema);
      var match$2 = match$1.type;
      if (match$2 === "object") {
        var advanced$1 = match$1.advanced;
        if (advanced$1 !== true) {
          var result = {};
          for(var idx = 0 ,idx_finish = flattenedItems.length; idx < idx_finish; ++idx){
            var item = flattenedItems[idx];
            result[item.location] = field(item.location, item.schema);
          }
          return result;
        }
        
      }
      var message$1 = "Unsupported nested flatten for transformed schema '" + toExpression(schema) + "'";
      throw new Error("[Sury] " + message$1);
    }
    var message$2 = "The '" + toExpression(schema) + "' schema can't be flattened";
    throw new Error("[Sury] " + message$2);
  };
  var ctx$1 = {
    field: field,
    f: field,
    fieldOr: fieldOr,
    tag: tag,
    nested: nested,
    flatten: flatten
  };
  parentCtx[cacheId] = ctx$1;
  return ctx$1;
}

function definitionToSchema(definition) {
  if (!(typeof definition === "object" && definition !== null)) {
    return parse(definition);
  }
  if (definition["~standard"]) {
    return definition;
  }
  if (Array.isArray(definition)) {
    var reversedItems = [];
    var isTransformed = false;
    for(var idx = 0 ,idx_finish = definition.length; idx < idx_finish; ++idx){
      var schema = definitionToSchema(definition[idx]);
      var reversed = reverse(schema);
      var $$location = idx.toString();
      var inlinedLocation = "\"" + $$location + "\"";
      definition[idx] = {
        schema: schema,
        location: $$location,
        inlinedLocation: inlinedLocation
      };
      reversedItems[idx] = {
        schema: reversed,
        location: $$location,
        inlinedLocation: inlinedLocation
      };
      if (schema !== reversed) {
        isTransformed = true;
      }
      
    }
    return {
            type: "array",
            builder: builder$3,
            additionalItems: "strict",
            items: definition,
            output: isTransformed ? (function () {
                  return {
                          type: "array",
                          builder: builder$3,
                          additionalItems: "strict",
                          items: reversedItems
                        };
                }) : undefined
          };
  }
  var cnstr = definition.constructor;
  if (cnstr && cnstr !== Object) {
    return {
            type: "instance",
            const: definition,
            class: cnstr
          };
  }
  var fieldNames = Object.keys(definition);
  var length = fieldNames.length;
  var items = [];
  for(var idx$1 = 0; idx$1 < length; ++idx$1){
    var $$location$1 = fieldNames[idx$1];
    var inlinedLocation$1 = fromString($$location$1);
    var schema$1 = definitionToSchema(definition[$$location$1]);
    var item = {
      schema: schema$1,
      location: $$location$1,
      inlinedLocation: inlinedLocation$1
    };
    definition[$$location$1] = item;
    items[idx$1] = item;
  }
  return {
          type: "object",
          builder: builder$3,
          additionalItems: globalConfig.a,
          items: items,
          fields: definition,
          output: output$2
        };
}

function output$2() {
  var items = this.items;
  var reversedFields = {};
  var reversedItems = [];
  var isTransformed = false;
  for(var idx = 0 ,idx_finish = items.length; idx < idx_finish; ++idx){
    var match = items[idx];
    var $$location = match.location;
    var schema = match.schema;
    var reversed = reverse(schema);
    var item_inlinedLocation = match.inlinedLocation;
    var item = {
      schema: reversed,
      location: $$location,
      inlinedLocation: item_inlinedLocation
    };
    reversedFields[$$location] = item;
    reversedItems.push(item);
    if (schema !== reversed) {
      isTransformed = true;
    }
    
  }
  if (isTransformed) {
    return {
            type: "object",
            builder: builder$3,
            additionalItems: globalConfig.a,
            items: reversedItems,
            fields: reversedFields
          };
  } else {
    return this;
  }
}

function definitionToRitem(definition, path, ritems, ritemsByItemPath) {
  if (!(typeof definition === "object" && definition !== null)) {
    return {
            k: 1,
            p: path,
            s: parse(definition)
          };
  }
  var item = definition[itemSymbol];
  if (item !== undefined) {
    var ritem_2 = getItemReversed(item);
    var ritem = {
      k: 0,
      p: path,
      i: item,
      s: ritem_2
    };
    item.r = ritem;
    ritemsByItemPath[getFullDitemPath(item)] = ritem;
    return ritem;
  }
  if (Array.isArray(definition)) {
    var items = [];
    for(var idx = 0 ,idx_finish = definition.length; idx < idx_finish; ++idx){
      var $$location = idx.toString();
      var inlinedLocation = "\"" + $$location + "\"";
      var ritem$1 = definitionToRitem(definition[idx], path + ("[" + inlinedLocation + "]"), ritems, ritemsByItemPath);
      ritems.push(ritem$1);
      var item_schema = ritem$1.s;
      var item$1 = {
        schema: item_schema,
        location: $$location,
        inlinedLocation: inlinedLocation
      };
      items[idx] = item$1;
    }
    return {
            k: 2,
            p: path,
            s: {
              type: "array",
              builder: builder,
              additionalItems: "strict",
              items: items,
              output: output$2
            },
            a: true
          };
  }
  var fieldNames = Object.keys(definition);
  var fields = {};
  var items$1 = [];
  for(var idx$1 = 0 ,idx_finish$1 = fieldNames.length; idx$1 < idx_finish$1; ++idx$1){
    var $$location$1 = fieldNames[idx$1];
    var inlinedLocation$1 = fromString($$location$1);
    var ritem$2 = definitionToRitem(definition[$$location$1], path + ("[" + inlinedLocation$1 + "]"), ritems, ritemsByItemPath);
    ritems.push(ritem$2);
    var item_schema$1 = ritem$2.s;
    var item$2 = {
      schema: item_schema$1,
      location: $$location$1,
      inlinedLocation: inlinedLocation$1
    };
    items$1[idx$1] = item$2;
    fields[$$location$1] = item$2;
  }
  return {
          k: 2,
          p: path,
          s: {
            type: "object",
            builder: builder,
            advanced: true,
            additionalItems: globalConfig.a,
            items: items$1,
            fields: fields,
            output: output$2
          },
          a: false
        };
}

function advancedReverse(definition, to, flattened) {
  return function () {
    var originalSchema = this;
    var ritemsByItemPath = {};
    var ritems = [];
    var ritem = definitionToRitem(definition, "", ritems, ritemsByItemPath);
    var mut;
    switch (ritem.k) {
      case 0 :
      case 1 :
          mut = copy(ritem.s);
          break;
      case 2 :
          mut = ritem.s;
          break;
      
    }
    mut.builder = (function (b, input, selfSchema, path) {
        var getRitemInput = function (ritem) {
          if (ritem.p === "") {
            return input;
          } else {
            return {
                    b: b,
                    v: _notVar,
                    i: input.v(b) + ritem.p,
                    a: false
                  };
          }
        };
        var reversedToInput = function (reversed, originalPath) {
          if (isLiteral(reversed)) {
            return {
                    b: b,
                    v: _var,
                    i: embed(b, reversed.const),
                    a: false
                  };
          }
          var tag = reversed.type;
          var additionalItems = reversed.additionalItems;
          var items = reversed.items;
          if (items !== undefined && typeof additionalItems === "string") {
            var isArray = tag === "array";
            var objectVal = make(b, isArray);
            for(var idx = 0 ,idx_finish = items.length; idx < idx_finish; ++idx){
              var item = items[idx];
              var itemPath = originalPath + ("[" + item.inlinedLocation + "]");
              var ritem = ritemsByItemPath[itemPath];
              var itemInput = ritem !== undefined ? getRitemInput(ritem) : reversedToInput(item.schema, itemPath);
              add(objectVal, item.inlinedLocation, itemInput);
            }
            return complete(objectVal, isArray);
          }
          var tmp = originalPath === "" ? "Schema isn't registered" : "Schema for " + originalPath + " isn't registered";
          return invalidOperation(b, path, tmp);
        };
        var getItemOutput = function (item, itemPath) {
          var ritem = item.r;
          if (ritem !== undefined) {
            var reversed = ritem.s;
            var itemInput = getRitemInput(ritem);
            var path$1 = path + ritem.p;
            if (ritem.p !== "" && b.g.o & 1 && !isLiteral(reversed) && reversed.type !== "object") {
              b.c = b.c + typeFilterCode(b, reversed, itemInput, path$1);
            }
            var builder = reversed.builder;
            if (builder !== undefined) {
              return builder(b, itemInput, reversed, path$1);
            } else {
              return itemInput;
            }
          }
          var reversed$1 = reverse(item.schema);
          var input = reversedToInput(reversed$1, itemPath);
          var prevFlag = b.g.o;
          b.g.o = (prevFlag | 1) ^ 1;
          var builder$1 = reversed$1.builder;
          var output = builder$1 !== undefined ? builder$1(b, input, reversed$1, path) : input;
          b.g.o = prevFlag;
          return output;
        };
        if (to !== undefined) {
          return getItemOutput(to, "");
        }
        objectStrictModeCheck(b, input, selfSchema.items, selfSchema, path);
        var isArray = originalSchema.type === "array";
        var items = originalSchema.items;
        var objectVal = make(b, isArray);
        if (flattened !== undefined) {
          for(var idx = 0 ,idx_finish = flattened.length; idx < idx_finish; ++idx){
            merge(objectVal, getItemOutput(flattened[idx], ""));
          }
        }
        for(var idx$1 = 0 ,idx_finish$1 = items.length; idx$1 < idx_finish$1; ++idx$1){
          var item = items[idx$1];
          if (!objectVal[item.inlinedLocation]) {
            add(objectVal, item.inlinedLocation, getItemOutput(item, "[" + item.inlinedLocation + "]"));
          }
          
        }
        return complete(objectVal, isArray);
      });
    return mut;
  };
}

function advancedBuilder(definition, flattened) {
  return function (parentB, input, selfSchema, path) {
    var isFlatten = parentB.g.o & 64;
    var outputs = isFlatten ? input : ({});
    var b = {
      c: "",
      l: "",
      a: initialAllocate,
      g: parentB.g
    };
    if (!isFlatten) {
      var items = selfSchema.items;
      var inputVar = input.v(b);
      for(var idx = 0 ,idx_finish = items.length; idx < idx_finish; ++idx){
        var match = items[idx];
        var inlinedLocation = match.inlinedLocation;
        var schema = match.schema;
        var itemPath = "[" + inlinedLocation + "]";
        var itemInput = {
          b: b,
          v: _notVar,
          i: inputVar + itemPath,
          a: false
        };
        var path$1 = path + itemPath;
        if (b.g.o & 1 && !isLiteral(schema) && schema.type !== "object") {
          b.c = b.c + typeFilterCode(b, schema, itemInput, path$1);
        }
        var builder = schema.builder;
        outputs[inlinedLocation] = builder !== undefined ? builder(b, itemInput, schema, path$1) : itemInput;
      }
      objectStrictModeCheck(b, input, items, selfSchema, path);
    }
    if (flattened !== undefined) {
      var prevFlag = b.g.o;
      b.g.o = prevFlag | 64;
      for(var idx$1 = 0 ,idx_finish$1 = flattened.length; idx$1 < idx_finish$1; ++idx$1){
        var item = flattened[idx$1];
        var schema$1 = item.schema;
        var builder$1 = schema$1.builder;
        outputs[item.i] = builder$1 !== undefined ? builder$1(b, outputs, schema$1, path) : outputs;
      }
      b.g.o = prevFlag;
    }
    var getItemOutput = function (item) {
      switch (item.k) {
        case 0 :
            return outputs[item.inlinedLocation];
        case 1 :
            return get(b, getItemOutput(item.of), item.inlinedLocation);
        case 2 :
            return outputs[item.i];
        
      }
    };
    var output = definitionToOutput(b, definition, getItemOutput);
    parentB.c = parentB.c + allocateScope(b);
    return output;
  };
}

function shape(schema, definer) {
  var mut = copy(schema);
  var item = {
    k: 2,
    schema: schema,
    p: "",
    i: 0
  };
  var definition = definer(proxify(item));
  mut.builder = (function (b, input, param, path) {
      var builder = schema.builder;
      var itemOutput = builder !== undefined ? builder(b, input, schema, path) : input;
      var bb = {
        c: "",
        l: "",
        a: initialAllocate,
        g: b.g
      };
      var getItemOutput = function (item) {
        switch (item.k) {
          case 1 :
              return get(bb, getItemOutput(item.of), item.inlinedLocation);
          case 0 :
          case 2 :
              return itemOutput;
          
        }
      };
      var output = definitionToOutput(bb, definition, getItemOutput);
      b.c = b.c + allocateScope(bb);
      return output;
    });
  mut.output = advancedReverse(definition, item, undefined);
  return new Schema(mut);
}

function object(definer) {
  var flattened = (void 0);
  var items = [];
  var fields = {};
  var flatten = function (schema) {
    var match = schema.type;
    if (match === "object") {
      var flattenedItems = schema.items;
      for(var idx = 0 ,idx_finish = flattenedItems.length; idx < idx_finish; ++idx){
        var match$1 = flattenedItems[idx];
        var inlinedLocation = match$1.inlinedLocation;
        var $$location = match$1.location;
        var flattenedSchema = match$1.schema;
        var item = fields[$$location];
        if (item !== undefined) {
          if (item.schema !== flattenedSchema) {
            throw new Error("[Sury] " + ("The field " + inlinedLocation + " defined twice with incompatible schemas"));
          }
          
        } else {
          var item$1 = {
            k: 0,
            schema: flattenedSchema,
            inlinedLocation: inlinedLocation,
            location: $$location
          };
          items.push(item$1);
          fields[$$location] = item$1;
        }
      }
      var f = (flattened || (flattened = []));
      var item_2 = f.length;
      var item$2 = {
        k: 2,
        schema: schema,
        p: "",
        i: item_2
      };
      f.push(item$2);
      return proxify(item$2);
    }
    var message = "The '" + toExpression(schema) + "' schema can't be flattened";
    throw new Error("[Sury] " + message);
  };
  var field = function (fieldName, schema) {
    var inlinedLocation = fromString(fieldName);
    if (fields[fieldName]) {
      throw new Error("[Sury] " + ("The field " + inlinedLocation + " defined twice with incompatible schemas"));
    }
    var ditem = {
      k: 0,
      schema: schema,
      inlinedLocation: inlinedLocation,
      location: fieldName
    };
    fields[fieldName] = ditem;
    items.push(ditem);
    return proxify(ditem);
  };
  var tag = function (tag$1, asValue) {
    field(tag$1, definitionToSchema(asValue));
  };
  var fieldOr = function (fieldName, schema, or) {
    return field(fieldName, getOr(factory$1(schema, undefined), or));
  };
  var ctx = {
    field: field,
    f: field,
    fieldOr: fieldOr,
    tag: tag,
    nested: nested,
    flatten: flatten
  };
  var definition = definer(ctx);
  return new Schema({
              type: "object",
              builder: advancedBuilder(definition, flattened),
              advanced: true,
              additionalItems: globalConfig.a,
              items: items,
              fields: fields,
              output: advancedReverse(definition, undefined, flattened)
            });
}

function tuple(definer) {
  var items = [];
  var item = function (idx, schema) {
    var $$location = idx.toString();
    var inlinedLocation = "\"" + $$location + "\"";
    if (items[idx]) {
      throw new Error("[Sury] " + ("The item [" + inlinedLocation + "] is defined multiple times"));
    }
    var ditem = {
      k: 0,
      schema: schema,
      inlinedLocation: inlinedLocation,
      location: $$location
    };
    items[idx] = ditem;
    return proxify(ditem);
  };
  var tag = function (idx, asValue) {
    item(idx, definitionToSchema(asValue));
  };
  var ctx = {
    item: item,
    tag: tag
  };
  var definition = definer(ctx);
  for(var idx = 0 ,idx_finish = items.length; idx < idx_finish; ++idx){
    if (!items[idx]) {
      var $$location = idx.toString();
      var inlinedLocation = "\"" + $$location + "\"";
      var ditem = {
        schema: unit,
        location: $$location,
        inlinedLocation: inlinedLocation
      };
      items[idx] = ditem;
    }
    
  }
  return new Schema({
              type: "array",
              builder: advancedBuilder(definition, undefined),
              additionalItems: "strict",
              items: items,
              output: advancedReverse(definition, undefined, undefined)
            });
}

function matches(schema) {
  return schema;
}

var ctx = {
  m: matches
};

function factory$5(definer) {
  return new Schema(definitionToSchema(definer(ctx)));
}

function factory$6(item) {
  return factory$1(item, nullAsUnit);
}

function js_schema(definition) {
  return new Schema(definitionToSchema(definition));
}

function $$enum(values) {
  return factory(values.map(js_schema));
}

function unnest(schema) {
  if (schema.type === "object") {
    var items = schema.items;
    if (items.length === 0) {
      throw new Error("[Sury] Invalid empty object for S.unnest schema.");
    }
    return new Schema({
                type: "array",
                builder: (function (b, input, param, path) {
                    var inputVar = input.v(b);
                    var iteratorVar = varWithoutAllocation(b.g);
                    var bb = {
                      c: "",
                      l: "",
                      a: initialAllocate,
                      g: b.g
                    };
                    var itemInput = make(bb, false);
                    var lengthCode = "";
                    for(var idx = 0 ,idx_finish = items.length; idx < idx_finish; ++idx){
                      var item = items[idx];
                      add(itemInput, item.inlinedLocation, {
                            b: bb,
                            v: _notVar,
                            i: inputVar + "[" + idx + "][" + iteratorVar + "]",
                            a: false
                          });
                      lengthCode = lengthCode + (inputVar + "[" + idx + "].length,");
                    }
                    var output = {
                      b: b,
                      v: _notVar,
                      i: "new Array(Math.max(" + lengthCode + "))",
                      a: false
                    };
                    var outputVar = output.v(b);
                    var itemOutput = withPathPrepend(bb, complete(itemInput, false), path, iteratorVar, (function (bb, itemOutput) {
                            bb.c = bb.c + addKey(bb, output, iteratorVar, itemOutput) + ";";
                          }), (function (b, input, path) {
                            var builder = schema.builder;
                            if (builder !== undefined) {
                              return builder(b, input, schema, path);
                            } else {
                              return input;
                            }
                          }));
                    var itemCode = allocateScope(bb);
                    b.c = b.c + ("for(let " + iteratorVar + "=0;" + iteratorVar + "<" + outputVar + ".length;++" + iteratorVar + "){" + itemCode + "}");
                    if (itemOutput.a) {
                      return {
                              b: output.b,
                              v: _notVar,
                              i: "Promise.all(" + output.i + ")",
                              a: true
                            };
                    } else {
                      return output;
                    }
                  }),
                additionalItems: "strict",
                items: items.map(function (item, idx) {
                      var $$location = idx.toString();
                      return {
                              schema: factory$2(item.schema),
                              location: $$location,
                              inlinedLocation: "\"" + $$location + "\""
                            };
                    }),
                unnest: true,
                output: (function () {
                    var schema$1 = reverse(schema);
                    return {
                            type: "array",
                            builder: (function (b, input, param, path) {
                                var inputVar = input.v(b);
                                var iteratorVar = varWithoutAllocation(b.g);
                                var outputVar = varWithoutAllocation(b.g);
                                var bb = {
                                  c: "",
                                  l: "",
                                  a: initialAllocate,
                                  g: b.g
                                };
                                var itemInput = {
                                  b: bb,
                                  v: _notVar,
                                  i: inputVar + "[" + iteratorVar + "]",
                                  a: false
                                };
                                var itemOutput = withPathPrepend(bb, itemInput, path, iteratorVar, (function (bb, output) {
                                        var initialArraysCode = "";
                                        var settingCode = "";
                                        for(var idx = 0 ,idx_finish = items.length; idx < idx_finish; ++idx){
                                          var item = items[idx];
                                          initialArraysCode = initialArraysCode + ("new Array(" + inputVar + ".length),");
                                          settingCode = settingCode + (outputVar + "[" + idx + "][" + iteratorVar + "]=" + get(b, output, item.inlinedLocation).i + ";");
                                        }
                                        b.a(outputVar + "=[" + initialArraysCode + "]");
                                        bb.c = bb.c + settingCode;
                                      }), (function (b, input, path) {
                                        return parseWithTypeValidation(b, schema$1, input, path);
                                      }));
                                var itemCode = allocateScope(bb);
                                b.c = b.c + ("for(let " + iteratorVar + "=0;" + iteratorVar + "<" + inputVar + ".length;++" + iteratorVar + "){" + itemCode + "}");
                                if (itemOutput.a) {
                                  return {
                                          b: b,
                                          v: _notVar,
                                          i: "Promise.all(" + outputVar + ")",
                                          a: true
                                        };
                                } else {
                                  return {
                                          b: b,
                                          v: _var,
                                          i: outputVar,
                                          a: false
                                        };
                                }
                              }),
                            additionalItems: schema$1,
                            items: immutableEmpty$1
                          };
                  })
              });
  }
  throw new Error("[Sury] S.unnest supports only object schemas.");
}

function tuple1(v0) {
  return tuple(function (s) {
              return s.item(0, v0);
            });
}

function tuple2(v0, v1) {
  return new Schema(definitionToSchema([
                  v0,
                  v1
                ]));
}

function tuple3(v0, v1, v2) {
  return new Schema(definitionToSchema([
                  v0,
                  v1,
                  v2
                ]));
}

function intMin(schema, minValue, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "Number must be greater than or equal to " + minValue;
  return addRefinement(schema, metadataId$2, {
              kind: {
                TAG: "Min",
                value: minValue
              },
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(" + inputVar + "<" + embed(b, minValue) + "){" + fail(b, message, path) + "}";
              }));
}

function intMax(schema, maxValue, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "Number must be lower than or equal to " + maxValue;
  return addRefinement(schema, metadataId$2, {
              kind: {
                TAG: "Max",
                value: maxValue
              },
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(" + inputVar + ">" + embed(b, maxValue) + "){" + fail(b, message, path) + "}";
              }));
}

function port(schema, message) {
  var mutStandard = internalRefine(schema, (function (b, inputVar, selfSchema, path) {
          return inputVar + ">0&&" + inputVar + "<65536&&" + inputVar + "%1===0||" + (
                  message !== undefined ? fail(b, message, path) : failWithArg(b, path, (function (input) {
                            return {
                                    TAG: "InvalidType",
                                    expected: selfSchema,
                                    received: input
                                  };
                          }), inputVar)
                ) + ";";
        }));
  mutStandard.format = "port";
  reverse(mutStandard).format = "port";
  return mutStandard;
}

function floatMin(schema, minValue, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "Number must be greater than or equal to " + minValue;
  return addRefinement(schema, metadataId$3, {
              kind: {
                TAG: "Min",
                value: minValue
              },
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(" + inputVar + "<" + embed(b, minValue) + "){" + fail(b, message, path) + "}";
              }));
}

function floatMax(schema, maxValue, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "Number must be lower than or equal to " + maxValue;
  return addRefinement(schema, metadataId$3, {
              kind: {
                TAG: "Max",
                value: maxValue
              },
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(" + inputVar + ">" + embed(b, maxValue) + "){" + fail(b, message, path) + "}";
              }));
}

function arrayMinLength(schema, length, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "Array must be " + length + " or more items long";
  return addRefinement(schema, metadataId, {
              kind: {
                TAG: "Min",
                length: length
              },
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(" + inputVar + ".length<" + embed(b, length) + "){" + fail(b, message, path) + "}";
              }));
}

function arrayMaxLength(schema, length, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "Array must be " + length + " or fewer items long";
  return addRefinement(schema, metadataId, {
              kind: {
                TAG: "Max",
                length: length
              },
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(" + inputVar + ".length>" + embed(b, length) + "){" + fail(b, message, path) + "}";
              }));
}

function stringMinLength(schema, length, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "String must be " + length + " or more characters long";
  return addRefinement(schema, metadataId$1, {
              kind: {
                TAG: "Min",
                length: length
              },
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(" + inputVar + ".length<" + embed(b, length) + "){" + fail(b, message, path) + "}";
              }));
}

function stringMaxLength(schema, length, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "String must be " + length + " or fewer characters long";
  return addRefinement(schema, metadataId$1, {
              kind: {
                TAG: "Max",
                length: length
              },
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(" + inputVar + ".length>" + embed(b, length) + "){" + fail(b, message, path) + "}";
              }));
}

function email(schema, messageOpt) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid email address";
  return addRefinement(schema, metadataId$1, {
              kind: "Email",
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(!" + embed(b, emailRegex) + ".test(" + inputVar + ")){" + fail(b, message, path) + "}";
              }));
}

function uuid(schema, messageOpt) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid UUID";
  return addRefinement(schema, metadataId$1, {
              kind: "Uuid",
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(!" + embed(b, uuidRegex) + ".test(" + inputVar + ")){" + fail(b, message, path) + "}";
              }));
}

function cuid(schema, messageOpt) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid CUID";
  return addRefinement(schema, metadataId$1, {
              kind: "Cuid",
              message: message
            }, (function (b, inputVar, param, path) {
                return "if(!" + embed(b, cuidRegex) + ".test(" + inputVar + ")){" + fail(b, message, path) + "}";
              }));
}

function url(schema, messageOpt) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid url";
  return addRefinement(schema, metadataId$1, {
              kind: "Url",
              message: message
            }, (function (b, inputVar, param, path) {
                return "try{new URL(" + inputVar + ")}catch(_){" + fail(b, message, path) + "}";
              }));
}

function pattern(schema, re, messageOpt) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid";
  return addRefinement(schema, metadataId$1, {
              kind: {
                TAG: "Pattern",
                re: re
              },
              message: message
            }, (function (b, inputVar, param, path) {
                var reVal = {
                  b: b,
                  v: _var,
                  i: embed(b, re),
                  a: false
                };
                return reVal.i + ".lastIndex=0;if(!" + reVal.i + ".test(" + inputVar + ")){" + fail(b, message, path) + "}";
              }));
}

function datetime(schema, messageOpt) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid datetime string! Expected UTC";
  var refinement = {
    kind: "Datetime",
    message: message
  };
  var refinements = schema[metadataId$1];
  return transform$1(set$1(schema, metadataId$1, refinements !== undefined ? refinements.concat(refinement) : [refinement]), (function (s) {
                return {
                        p: (function (string) {
                            if (!datetimeRe.test(string)) {
                              s.fail(message, undefined);
                            }
                            return new Date(string);
                          }),
                        s: (function (date) {
                            return date.toISOString();
                          })
                      };
              }));
}

function trim(schema) {
  var transformer = function (string) {
    return string.trim();
  };
  return transform$1(schema, (function (param) {
                return {
                        p: transformer,
                        s: transformer
                      };
              }));
}

function nullable(schema) {
  return factory([
              schema,
              unit,
              $$null
            ]);
}

function nullableAsOption(schema) {
  return factory([
              schema,
              unit,
              nullAsUnit
            ]);
}

function js_union(values) {
  return factory(values.map(definitionToSchema));
}

function js_transform(schema, maybeParser, maybeSerializer) {
  return transform$1(schema, (function (s) {
                return {
                        p: maybeParser !== undefined ? (function (v) {
                              return maybeParser(v, s);
                            }) : undefined,
                        s: maybeSerializer !== undefined ? (function (v) {
                              return maybeSerializer(v, s);
                            }) : undefined
                      };
              }));
}

function js_refine(schema, refiner) {
  return refine(schema, (function (s) {
                return function (v) {
                  refiner(v, s);
                };
              }));
}

function noop(a) {
  return a;
}

function js_asyncParserRefine(schema, refine) {
  return transform$1(schema, (function (s) {
                return {
                        a: (function (v) {
                            return refine(v, s).then(function () {
                                        return v;
                                      });
                          }),
                        s: noop
                      };
              }));
}

function js_optional(schema, maybeOr) {
  var schema$1 = factory([
        schema,
        unit
      ]);
  if (maybeOr === undefined) {
    return schema$1;
  }
  var or = Caml_option.valFromOption(maybeOr);
  if (typeof or === "function") {
    return getOrWith(schema$1, or);
  } else {
    return getOr(schema$1, or);
  }
}

function js_nullable(schema, maybeOr) {
  var schema$1 = factory([
        schema,
        nullAsUnit
      ]);
  if (maybeOr === undefined) {
    return schema$1;
  }
  var or = Caml_option.valFromOption(maybeOr);
  if (typeof or === "function") {
    return getOrWith(schema$1, or);
  } else {
    return getOr(schema$1, or);
  }
}

function js_merge(s1, s2) {
  if (s1.type === "object") {
    if (s2.type === "object") {
      var items2 = s2.items;
      var items = [].concat(s1.items);
      var fields = Object.assign({}, s1.fields);
      for(var idx = 0 ,idx_finish = items2.length; idx < idx_finish; ++idx){
        var item = items2[idx];
        if (fields[item.location]) {
          throw new Error("[Sury] " + ("The field " + item.inlinedLocation + " is defined multiple times"));
        }
        items.push(item);
        fields[item.location] = item;
      }
      return new Schema({
                  type: "object",
                  builder: (function (b, input, param, path) {
                      var builder = s1.builder;
                      var s1Result = builder !== undefined ? builder(b, input, s1, path) : input;
                      var builder$1 = s2.builder;
                      var s2Result = builder$1 !== undefined ? builder$1(b, input, s2, path) : input;
                      return {
                              b: b,
                              v: _notVar,
                              i: "{..." + s1Result.i + ", ..." + s2Result.i + "}",
                              a: false
                            };
                    }),
                  advanced: true,
                  additionalItems: s2.additionalItems,
                  items: items,
                  fields: fields,
                  output: (function () {
                      return {
                              type: "unknown",
                              builder: (function (b, param, param$1, path) {
                                  return invalidOperation(b, path, "The S.merge serializing is not supported yet");
                                })
                            };
                    })
                });
    }
    throw new Error("[Sury] The merge supports only Object schemas");
  }
  throw new Error("[Sury] The merge supports only Object schemas");
}

function $$global(override) {
  globalConfig.r = 0;
  var defaultAdditionalItems = override.defaultAdditionalItems;
  globalConfig.a = defaultAdditionalItems !== undefined ? defaultAdditionalItems : "strip";
  var prevDisableNanNumberCheck = globalConfig.n;
  var disableNanNumberValidation = override.disableNanNumberValidation;
  globalConfig.n = disableNanNumberValidation !== undefined ? disableNanNumberValidation : false;
  if (prevDisableNanNumberCheck !== globalConfig.n) {
    return resetOperationsCache(schema$3);
  }
  
}

var jsonSchemaMetadataId = "m:JSONSchema";

function internalToJSONSchema(schema) {
  var jsonSchema = {};
  switch (schema.type) {
    case "never" :
        jsonSchema.not = {};
        break;
    case "string" :
        var $$const = schema.const;
        jsonSchema.type = "string";
        refinements$1(schema).forEach(function (refinement) {
              var match = refinement.kind;
              if (typeof match !== "object") {
                switch (match) {
                  case "Email" :
                      jsonSchema.format = "email";
                      return ;
                  case "Uuid" :
                      jsonSchema.format = "uuid";
                      return ;
                  case "Cuid" :
                      return ;
                  case "Url" :
                      jsonSchema.format = "uri";
                      return ;
                  case "Datetime" :
                      jsonSchema.format = "date-time";
                      return ;
                  
                }
              } else {
                switch (match.TAG) {
                  case "Min" :
                      jsonSchema.minLength = match.length;
                      return ;
                  case "Max" :
                      jsonSchema.maxLength = match.length;
                      return ;
                  case "Length" :
                      var length = match.length;
                      jsonSchema.minLength = length;
                      jsonSchema.maxLength = length;
                      return ;
                  case "Pattern" :
                      jsonSchema.pattern = String(match.re);
                      return ;
                  
                }
              }
            });
        if ($$const !== undefined) {
          jsonSchema.const = $$const;
        }
        break;
    case "number" :
        var format = schema.format;
        var $$const$1 = schema.const;
        if (format !== undefined) {
          if (format === "int32") {
            jsonSchema.type = "integer";
            refinements$2(schema).forEach(function (refinement) {
                  var match = refinement.kind;
                  if (match.TAG === "Min") {
                    jsonSchema.minimum = match.value;
                  } else {
                    jsonSchema.maximum = match.value;
                  }
                });
          } else {
            jsonSchema.type = "integer";
            jsonSchema.maximum = 65535;
            jsonSchema.minimum = 0;
          }
        } else {
          jsonSchema.type = "number";
          refinements$3(schema).forEach(function (refinement) {
                var match = refinement.kind;
                if (match.TAG === "Min") {
                  jsonSchema.minimum = match.value;
                } else {
                  jsonSchema.maximum = match.value;
                }
              });
        }
        if ($$const$1 !== undefined) {
          jsonSchema.const = $$const$1;
        }
        break;
    case "boolean" :
        var $$const$2 = schema.const;
        jsonSchema.type = "boolean";
        if ($$const$2 !== undefined) {
          jsonSchema.const = $$const$2;
        }
        break;
    case "null" :
        jsonSchema.type = "null";
        break;
    case "array" :
        var additionalItems = schema.additionalItems;
        var exit = 0;
        if (additionalItems === "strip" || additionalItems === "strict") {
          exit = 1;
        } else {
          jsonSchema.items = Caml_option.some(internalToJSONSchema(additionalItems));
          jsonSchema.type = "array";
          refinements(schema).forEach(function (refinement) {
                var match = refinement.kind;
                switch (match.TAG) {
                  case "Min" :
                      jsonSchema.minItems = match.length;
                      return ;
                  case "Max" :
                      jsonSchema.maxItems = match.length;
                      return ;
                  case "Length" :
                      var length = match.length;
                      jsonSchema.maxItems = length;
                      jsonSchema.minItems = length;
                      return ;
                  
                }
              });
        }
        if (exit === 1) {
          var items = schema.items.map(function (item) {
                return internalToJSONSchema(item.schema);
              });
          var itemsNumber = items.length;
          jsonSchema.items = Caml_option.some(items);
          jsonSchema.type = "array";
          jsonSchema.minItems = itemsNumber;
          jsonSchema.maxItems = itemsNumber;
        }
        break;
    case "object" :
        var additionalItems$1 = schema.additionalItems;
        var exit$1 = 0;
        if (additionalItems$1 === "strip" || additionalItems$1 === "strict") {
          exit$1 = 1;
        } else {
          jsonSchema.type = "object";
          jsonSchema.additionalProperties = Caml_option.some(internalToJSONSchema(additionalItems$1));
        }
        if (exit$1 === 1) {
          var properties = {};
          var required = [];
          schema.items.forEach(function (item) {
                var fieldSchema = internalToJSONSchema(item.schema);
                if (!isOptional(item.schema)) {
                  required.push(item.location);
                }
                properties[item.location] = fieldSchema;
              });
          var additionalProperties;
          additionalProperties = (additionalItems$1 === "strip" || additionalItems$1 === "strict") && additionalItems$1 !== "strip" ? false : true;
          jsonSchema.type = "object";
          jsonSchema.properties = properties;
          jsonSchema.additionalProperties = Caml_option.some(additionalProperties);
          if (required.length !== 0) {
            jsonSchema.required = required;
          }
          
        }
        break;
    case "union" :
        var literals = [];
        var items$1 = [];
        schema.anyOf.forEach(function (childSchema) {
              if (childSchema.type === "undefined") {
                return ;
              }
              items$1.push(internalToJSONSchema(childSchema));
              if (isLiteral(childSchema)) {
                literals.push(childSchema.const);
                return ;
              }
              
            });
        var itemsNumber$1 = items$1.length;
        var $$default = schema[defaultMetadataId];
        if ($$default !== undefined) {
          var serialize = operationFn(schema, 32);
          var tmp;
          tmp = $$default.TAG === "Value" ? $$default._0 : $$default._0();
          jsonSchema.default = serialize(tmp);
        }
        if (itemsNumber$1 === 1) {
          Object.assign(jsonSchema, items$1[0]);
        } else if (literals.length === itemsNumber$1) {
          jsonSchema.enum = literals;
        } else {
          jsonSchema.anyOf = items$1;
        }
        break;
    case "unknown" :
    case "json" :
        break;
    default:
      throw new Error("[Sury] Unexpected schema type");
  }
  var m = schema.description;
  if (m !== undefined) {
    jsonSchema.description = m;
  }
  var m$1 = schema.title;
  if (m$1 !== undefined) {
    jsonSchema.title = m$1;
  }
  var deprecated = schema.deprecated;
  if (deprecated !== undefined) {
    jsonSchema.deprecated = deprecated;
  }
  var examples = schema.examples;
  if (examples !== undefined) {
    jsonSchema.examples = examples;
  }
  var metadataRawSchema = schema[jsonSchemaMetadataId];
  if (metadataRawSchema !== undefined) {
    Object.assign(jsonSchema, metadataRawSchema);
  }
  return jsonSchema;
}

function toJSONSchema(schema) {
  jsonableValidation(schema, schema, "", 8, undefined);
  return internalToJSONSchema(schema);
}

function extendJSONSchema(schema, jsonSchema) {
  var existingSchemaExtend = schema[jsonSchemaMetadataId];
  return set$1(schema, jsonSchemaMetadataId, existingSchemaExtend !== undefined ? Object.assign({}, existingSchemaExtend, jsonSchema) : jsonSchema);
}

function primitiveToSchema(primitive) {
  return parse(primitive);
}

function toIntSchema(jsonSchema) {
  var minimum = jsonSchema.minimum;
  var schema$5;
  if (minimum !== undefined) {
    schema$5 = intMin(schema$2, minimum | 0, undefined);
  } else {
    var exclusiveMinimum = jsonSchema.exclusiveMinimum;
    schema$5 = exclusiveMinimum !== undefined ? intMin(schema$2, exclusiveMinimum + 1 | 0, undefined) : schema$2;
  }
  var maximum = jsonSchema.maximum;
  if (maximum !== undefined) {
    return intMax(schema$5, maximum | 0, undefined);
  }
  var exclusiveMinimum$1 = jsonSchema.exclusiveMinimum;
  if (exclusiveMinimum$1 !== undefined) {
    return intMax(schema$5, exclusiveMinimum$1 - 1 | 0, undefined);
  } else {
    return schema$5;
  }
}

function definitionToDefaultValue(definition) {
  if (typeof definition === "object") {
    return definition.default;
  }
  
}

function fromJSONSchema(jsonSchema) {
  var anySchema = json(false);
  var definitionToSchema = function (definition) {
    if (typeof definition === "object") {
      return fromJSONSchema(definition);
    } else {
      return anySchema;
    }
  };
  var type_ = jsonSchema.type;
  var schema$5;
  var exit = 0;
  var exit$1 = 0;
  if (jsonSchema.nullable) {
    schema$5 = factory$6(fromJSONSchema(Object.assign({}, jsonSchema, {
                  nullable: false
                })));
  } else if (type_ !== undefined) {
    var type_$1 = Caml_option.valFromOption(type_);
    if (type_$1 === "object") {
      var properties = jsonSchema.properties;
      if (properties !== undefined) {
        var schema$6 = object(function (s) {
              var obj = {};
              Object.keys(properties).forEach(function (key) {
                    var property = properties[key];
                    var propertySchema = definitionToSchema(property);
                    var r = jsonSchema.required;
                    var propertySchema$1;
                    var exit = 0;
                    if (r !== undefined && r.includes(key)) {
                      propertySchema$1 = propertySchema;
                    } else {
                      exit = 1;
                    }
                    if (exit === 1) {
                      var defaultValue = definitionToDefaultValue(property);
                      propertySchema$1 = defaultValue !== undefined ? getOr(factory$1(propertySchema), defaultValue) : factory$1(propertySchema);
                    }
                    obj[key] = s.f(key, propertySchema$1);
                  });
              return obj;
            });
        var additionalProperties = jsonSchema.additionalProperties;
        schema$5 = additionalProperties !== undefined && Caml_option.valFromOption(additionalProperties) === false ? strict(schema$6) : schema$6;
      } else {
        var additionalProperties$1 = jsonSchema.additionalProperties;
        if (additionalProperties$1 !== undefined) {
          var additionalProperties$2 = Caml_option.valFromOption(additionalProperties$1);
          schema$5 = typeof additionalProperties$2 === "object" ? factory$3(fromJSONSchema(additionalProperties$2)) : (
              additionalProperties$2 ? factory$3(anySchema) : strict(object(function (param) {
                          
                        }))
            );
        } else {
          schema$5 = factory$5(function (param) {
                
              });
        }
      }
    } else if (type_$1 === "array") {
      var items = jsonSchema.items;
      var schema$7;
      if (items !== undefined) {
        var single = JSONSchema.Arrayable.classify(Caml_option.valFromOption(items));
        if (single.TAG === "Single") {
          schema$7 = factory$2(definitionToSchema(single._0));
        } else {
          var array = single._0;
          schema$7 = tuple(function (s) {
                return array.map(function (d, idx) {
                            return s.item(idx, definitionToSchema(d));
                          });
              });
        }
      } else {
        schema$7 = factory$2(anySchema);
      }
      var min = jsonSchema.minItems;
      var schema$8 = min !== undefined ? arrayMinLength(schema$7, min, undefined) : schema$7;
      var max = jsonSchema.maxItems;
      schema$5 = max !== undefined ? arrayMaxLength(schema$8, max, undefined) : schema$8;
    } else {
      exit$1 = 2;
    }
  } else {
    exit$1 = 2;
  }
  if (exit$1 === 2) {
    var primitives = jsonSchema.enum;
    var definitions = jsonSchema.allOf;
    var definitions$1 = jsonSchema.anyOf;
    if (definitions$1 !== undefined) {
      var len = definitions$1.length;
      if (len !== 1) {
        schema$5 = len !== 0 ? factory(definitions$1.map(definitionToSchema)) : anySchema;
      } else {
        var d = definitions$1[0];
        schema$5 = definitionToSchema(d);
      }
    } else if (definitions !== undefined) {
      var len$1 = definitions.length;
      if (len$1 !== 1) {
        schema$5 = len$1 !== 0 ? refine(anySchema, (function (s) {
                  return function (data) {
                    definitions.forEach(function (d) {
                          try {
                            return assertOrThrow(data, definitionToSchema(d));
                          }
                          catch (exn){
                            return s.fail("Should pass for all schemas of the allOf property.", undefined);
                          }
                        });
                  };
                })) : anySchema;
      } else {
        var d$1 = definitions[0];
        schema$5 = definitionToSchema(d$1);
      }
    } else {
      var definitions$2 = jsonSchema.oneOf;
      if (definitions$2 !== undefined) {
        var len$2 = definitions$2.length;
        if (len$2 !== 1) {
          schema$5 = len$2 !== 0 ? refine(anySchema, (function (s) {
                    return function (data) {
                      var hasOneValidRef = {
                        contents: false
                      };
                      definitions$2.forEach(function (d) {
                            var passed;
                            try {
                              assertOrThrow(data, definitionToSchema(d));
                              passed = true;
                            }
                            catch (exn){
                              passed = false;
                            }
                            if (passed) {
                              if (hasOneValidRef.contents) {
                                s.fail("Should pass single schema according to the oneOf property.", undefined);
                              }
                              hasOneValidRef.contents = true;
                              return ;
                            }
                            
                          });
                      if (!hasOneValidRef.contents) {
                        return s.fail("Should pass at least one schema according to the oneOf property.", undefined);
                      }
                      
                    };
                  })) : anySchema;
        } else {
          var d$2 = definitions$2[0];
          schema$5 = definitionToSchema(d$2);
        }
      } else {
        var not = jsonSchema.not;
        if (not !== undefined) {
          var not$1 = Caml_option.valFromOption(not);
          schema$5 = refine(anySchema, (function (s) {
                  return function (data) {
                    var passed;
                    try {
                      assertOrThrow(data, definitionToSchema(not$1));
                      passed = true;
                    }
                    catch (exn){
                      passed = false;
                    }
                    if (passed) {
                      return s.fail("Should NOT be valid against schema in the not property.", undefined);
                    }
                    
                  };
                }));
        } else if (primitives !== undefined) {
          var len$3 = primitives.length;
          if (len$3 !== 1) {
            schema$5 = len$3 !== 0 ? factory(primitives.map(primitiveToSchema)) : anySchema;
          } else {
            var p = primitives[0];
            schema$5 = parse(p);
          }
        } else {
          var $$const = jsonSchema.const;
          if ($$const !== undefined) {
            schema$5 = parse($$const);
          } else if (type_ !== undefined) {
            var match = jsonSchema.multipleOf;
            var type_$2 = Caml_option.valFromOption(type_);
            var exit$2 = 0;
            var exit$3 = 0;
            var match$1 = jsonSchema.format;
            if (Array.isArray(type_$2)) {
              schema$5 = factory(type_$2.map(function (type_) {
                        return fromJSONSchema(Object.assign({}, jsonSchema, {
                                        type: Caml_option.some(type_)
                                      }));
                      }));
            } else if (type_$2 === "string") {
              var p$1 = jsonSchema.pattern;
              var schema$9 = p$1 !== undefined ? pattern(schema$1, new RegExp(p$1), undefined) : schema$1;
              var minLength = jsonSchema.minLength;
              var schema$10 = minLength !== undefined ? stringMinLength(schema$9, minLength, undefined) : schema$9;
              var maxLength = jsonSchema.maxLength;
              var schema$11 = maxLength !== undefined ? stringMaxLength(schema$10, maxLength, undefined) : schema$10;
              var match$2 = jsonSchema.format;
              if (match$2 !== undefined) {
                switch (match$2) {
                  case "date-time" :
                      schema$5 = datetime(schema$11, undefined);
                      break;
                  case "email" :
                      schema$5 = email(schema$11, undefined);
                      break;
                  case "uri" :
                      schema$5 = url(schema$11, undefined);
                      break;
                  case "uuid" :
                      schema$5 = uuid(schema$11, undefined);
                      break;
                  default:
                    schema$5 = schema$11;
                }
              } else {
                schema$5 = schema$11;
              }
            } else if (type_$2 === "integer" || match$1 !== undefined && match$1 === "int64" && type_$2 === "number") {
              schema$5 = toIntSchema(jsonSchema);
            } else {
              exit$3 = 4;
            }
            if (exit$3 === 4) {
              if (match !== undefined && !(match !== 1 || type_$2 !== "number")) {
                schema$5 = toIntSchema(jsonSchema);
              } else {
                exit$2 = 3;
              }
            }
            if (exit$2 === 3) {
              if (type_$2 === "number") {
                var minimum = jsonSchema.minimum;
                var schema$12;
                if (minimum !== undefined) {
                  schema$12 = floatMin(schema$3, minimum, undefined);
                } else {
                  var exclusiveMinimum = jsonSchema.exclusiveMinimum;
                  schema$12 = exclusiveMinimum !== undefined ? floatMin(schema$3, exclusiveMinimum + 1, undefined) : schema$3;
                }
                var maximum = jsonSchema.maximum;
                if (maximum !== undefined) {
                  schema$5 = floatMax(schema$12, maximum, undefined);
                } else {
                  var exclusiveMinimum$1 = jsonSchema.exclusiveMinimum;
                  schema$5 = exclusiveMinimum$1 !== undefined ? floatMax(schema$12, exclusiveMinimum$1 - 1, undefined) : schema$12;
                }
              } else if (type_$2 === "boolean") {
                schema$5 = bool;
              } else if (type_$2 === "null") {
                schema$5 = js_schema(null);
              } else {
                exit = 1;
              }
            }
            
          } else {
            exit = 1;
          }
        }
      }
    }
  }
  if (exit === 1) {
    var if_ = jsonSchema.if;
    if (if_ !== undefined) {
      var then = jsonSchema.then;
      if (then !== undefined) {
        var else_ = jsonSchema.else;
        if (else_ !== undefined) {
          var ifSchema = definitionToSchema(Caml_option.valFromOption(if_));
          var thenSchema = definitionToSchema(Caml_option.valFromOption(then));
          var elseSchema = definitionToSchema(Caml_option.valFromOption(else_));
          schema$5 = refine(anySchema, (function (param) {
                  return function (data) {
                    var passed;
                    try {
                      assertOrThrow(data, ifSchema);
                      passed = true;
                    }
                    catch (exn){
                      passed = false;
                    }
                    if (passed) {
                      return assertOrThrow(data, thenSchema);
                    } else {
                      return assertOrThrow(data, elseSchema);
                    }
                  };
                }));
        } else {
          schema$5 = anySchema;
        }
      } else {
        schema$5 = anySchema;
      }
    } else {
      schema$5 = anySchema;
    }
  }
  if (jsonSchema.description === undefined && jsonSchema.deprecated === undefined && jsonSchema.examples === undefined && jsonSchema.title === undefined) {
    return schema$5;
  }
  return meta(schema$5, {
              title: jsonSchema.title,
              description: jsonSchema.description,
              deprecated: jsonSchema.deprecated,
              examples: jsonSchema.examples
            });
}

function min(schema, minValue, maybeMessage) {
  switch (schema.type) {
    case "string" :
        return stringMinLength(schema, minValue, maybeMessage);
    case "number" :
        if (schema.format !== undefined) {
          return intMin(schema, minValue, maybeMessage);
        } else {
          return floatMin(schema, minValue, maybeMessage);
        }
    case "array" :
        return arrayMinLength(schema, minValue, maybeMessage);
    default:
      var message = "S.min is not supported for " + toExpression(schema) + " schema. Coerce the schema to string, number or array using S.to first.";
      throw new Error("[Sury] " + message);
  }
}

function max(schema, maxValue, maybeMessage) {
  switch (schema.type) {
    case "string" :
        return stringMaxLength(schema, maxValue, maybeMessage);
    case "number" :
        if (schema.format !== undefined) {
          return intMax(schema, maxValue, maybeMessage);
        } else {
          return floatMax(schema, maxValue, maybeMessage);
        }
    case "array" :
        return arrayMaxLength(schema, maxValue, maybeMessage);
    default:
      var message = "S.max is not supported for " + toExpression(schema) + " schema. Coerce the schema to string, number or array using S.to first.";
      throw new Error("[Sury] " + message);
  }
}

function length(schema, length$1, maybeMessage) {
  switch (schema.type) {
    case "string" :
        var message = maybeMessage !== undefined ? maybeMessage : "String must be exactly " + length$1 + " characters long";
        return addRefinement(schema, metadataId$1, {
                    kind: {
                      TAG: "Length",
                      length: length$1
                    },
                    message: message
                  }, (function (b, inputVar, param, path) {
                      return "if(" + inputVar + ".length!==" + embed(b, length$1) + "){" + fail(b, message, path) + "}";
                    }));
    case "array" :
        var message$1 = maybeMessage !== undefined ? maybeMessage : "Array must be exactly " + length$1 + " items long";
        return addRefinement(schema, metadataId, {
                    kind: {
                      TAG: "Length",
                      length: length$1
                    },
                    message: message$1
                  }, (function (b, inputVar, param, path) {
                      return "if(" + inputVar + ".length!==" + embed(b, length$1) + "){" + fail(b, message$1, path) + "}";
                    }));
    default:
      var message$2 = "S.length is not supported for " + toExpression(schema) + " schema. Coerce the schema to string or array using S.to first.";
      throw new Error("[Sury] " + message$2);
  }
}

var Path = {
  empty: "",
  dynamic: "[]",
  toArray: toArray,
  fromArray: fromArray,
  fromLocation: fromLocation,
  concat: concat
};

var Flag = {
  none: 0,
  typeValidation: 1,
  async: 2,
  assertOutput: 4,
  jsonableOutput: 8,
  jsonStringOutput: 16,
  reverse: 32,
  has: has
};

var never = schema;

var string = schema$1;

var $$int = schema$2;

var $$float = schema$3;

var bigint = schema$4;

var literal = js_schema;

var array = factory$2;

var dict = factory$3;

var option = factory$1;

var $$null$1 = factory$6;

var jsonString = factory$4;

var union = factory;

var parseJsonOrThrow = parseOrThrow;

var Schema$1 = {};

var schema$5 = factory$5;

var $$Object = {};

var $$Option = {
  $$default: $$default,
  getOr: getOr,
  getOrWith: getOrWith
};

var String_Refinement = {};

var $$String$1 = {
  Refinement: String_Refinement,
  refinements: refinements$1
};

var Int_Refinement = {};

var Int = {
  Refinement: Int_Refinement,
  refinements: refinements$2
};

var Float_Refinement = {};

var Float = {
  Refinement: Float_Refinement,
  refinements: refinements$3
};

var Array_Refinement = {};

var $$Array = {
  Refinement: Array_Refinement,
  refinements: refinements
};

var Metadata = {
  Id: Id,
  get: get$1,
  set: set$1
};

export {
  Path ,
  $$Error ,
  Flag ,
  never ,
  unknown ,
  unit ,
  nullAsUnit ,
  string ,
  bool ,
  $$int ,
  $$float ,
  bigint ,
  symbol ,
  json ,
  literal ,
  array ,
  unnest ,
  list ,
  instance ,
  dict ,
  option ,
  $$null$1 as $$null,
  nullable ,
  nullableAsOption ,
  jsonString ,
  union ,
  $$enum ,
  meta ,
  Catch ,
  $$catch ,
  transform$1 as transform,
  refine ,
  shape ,
  to ,
  compile ,
  parseOrThrow ,
  parseJsonOrThrow ,
  parseJsonStringOrThrow ,
  parseAsyncOrThrow ,
  convertOrThrow ,
  convertToJsonOrThrow ,
  convertToJsonStringOrThrow ,
  convertAsyncOrThrow ,
  reverseConvertOrThrow ,
  reverseConvertToJsonOrThrow ,
  reverseConvertToJsonStringOrThrow ,
  assertOrThrow ,
  isAsync ,
  recursive ,
  noValidation ,
  toExpression ,
  Schema$1 as Schema,
  schema$5 as schema,
  $$Object ,
  object ,
  strip ,
  deepStrip ,
  strict ,
  deepStrict ,
  Tuple ,
  tuple ,
  tuple1 ,
  tuple2 ,
  tuple3 ,
  $$Option ,
  $$String$1 as $$String,
  Int ,
  Float ,
  $$Array ,
  Metadata ,
  reverse ,
  ErrorClass ,
  min ,
  floatMin ,
  max ,
  floatMax ,
  length ,
  port ,
  email ,
  uuid ,
  cuid ,
  url ,
  pattern ,
  datetime ,
  trim ,
  toJSONSchema ,
  fromJSONSchema ,
  extendJSONSchema ,
  $$global ,
  js_safe ,
  js_safeAsync ,
  js_union ,
  js_optional ,
  js_nullable ,
  js_asyncParserRefine ,
  js_refine ,
  js_transform ,
  js_schema ,
  js_merge ,
}
/* s Not a pure module */

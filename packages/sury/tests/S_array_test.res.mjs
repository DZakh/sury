// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import Ava from "ava";

var value = [
  "Hello world!",
  ""
];

var any = ["Hello world!", ""];

var invalidAny = true;

var nestedInvalidAny = ["Hello world!", 1];

function factory() {
  return S.array(S.string);
}

Ava("Successfully parses", (function (t) {
        var schema = S.array(S.string);
        t.deepEqual(S.parseOrThrow(any, schema), value, undefined);
      }));

Ava("Fails to parse", (function (t) {
        var schema = S.array(S.string);
        U.assertThrows(t, (function () {
                return S.parseOrThrow(invalidAny, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: schema,
                received: invalidAny
              },
              path: S.Path.empty
            });
      }));

Ava("Fails to parse nested", (function (t) {
        var schema = S.array(S.string);
        U.assertThrows(t, (function () {
                return S.parseOrThrow(nestedInvalidAny, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.string,
                received: 1
              },
              path: S.Path.fromArray(["1"])
            });
      }));

Ava("Successfully serializes", (function (t) {
        var schema = S.array(S.string);
        t.deepEqual(S.reverseConvertOrThrow(value, schema), any, undefined);
      }));

Ava("Compiled parse code snapshot", (function (t) {
        var schema = S.array(S.string);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(!Array.isArray(i)){e[1](i)}for(let v0=0;v0<i.length;++v0){let v2=i[v0];try{if(typeof v2!==\"string\"){e[0](v2)}}catch(v1){if(v1&&v1.s===s){v1.path=\"\"+\'[\"\'+v0+\'\"]\'+v1.path}throw v1}}return i}", undefined);
      }));

Ava("Compiled async parse code snapshot", (function (t) {
        var schema = S.array(S.transform(S.unknown, (function (param) {
                    return {
                            a: (function (i) {
                                return Promise.resolve(i);
                              })
                          };
                  })));
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(!Array.isArray(i)){e[1](i)}let v3=new Array(i.length);for(let v0=0;v0<i.length;++v0){let v2;try{v2=e[0](i[v0]).catch(v1=>{if(v1&&v1.s===s){v1.path=\"\"+\'[\"\'+v0+\'\"]\'+v1.path}throw v1})}catch(v1){if(v1&&v1.s===s){v1.path=\"\"+\'[\"\'+v0+\'\"]\'+v1.path}throw v1}v3[v0]=v2}return Promise.all(v3)}", undefined);
      }));

Ava("Compiled serialize code snapshot", (function (t) {
        var schema = S.array(S.string);
        U.assertCompiledCodeIsNoop(t, schema, "ReverseConvert", undefined);
        var schema$1 = S.array(S.option(S.string));
        U.assertCompiledCodeIsNoop(t, schema$1, "ReverseConvert", undefined);
      }));

Ava("Compiled serialize code snapshot with transform", (function (t) {
        var schema = S.array(S.$$null(S.string));
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v4=new Array(i.length);for(let v0=0;v0<i.length;++v0){let v2=i[v0],v3;try{if(v2===void 0){v2=null}v3=v2}catch(v1){if(v1&&v1.s===s){v1.path=\"\"+\'[\"\'+v0+\'\"]\'+v1.path}throw v1}v4[v0]=v3}return v4}", undefined);
      }));

Ava("Reverse to self", (function (t) {
        var schema = S.array(S.string);
        t.is(S.reverse(schema), schema, undefined);
      }));

Ava("Succesfully uses reversed schema for parsing back to initial value", (function (t) {
        var schema = S.array(S.string);
        U.assertReverseParsesBack(t, schema, value);
      }));

var CommonWithNested = {
  value: value,
  any: any,
  invalidAny: invalidAny,
  nestedInvalidAny: nestedInvalidAny,
  factory: factory
};

Ava("Reverse child schema", (function (t) {
        var schema = S.array(S.$$null(S.string));
        U.assertEqualSchemas(t, S.reverse(schema), S.array(S.option(S.string)), undefined);
      }));

Ava("Successfully parses matrix", (function (t) {
        var schema = S.array(S.array(S.string));
        t.deepEqual(S.parseOrThrow([["a", "b"], ["c", "d"]], schema), [
              [
                "a",
                "b"
              ],
              [
                "c",
                "d"
              ]
            ], undefined);
      }));

Ava("Fails to parse matrix", (function (t) {
        var schema = S.array(S.array(S.string));
        U.assertThrows(t, (function () {
                return S.parseOrThrow([["a", 1], ["c", "d"]], schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.string,
                received: 1
              },
              path: S.Path.fromArray([
                    "0",
                    "1"
                  ])
            });
      }));

Ava("Successfully parses array of optional items", (function (t) {
        var schema = S.array(S.option(S.string));
        t.deepEqual(S.parseOrThrow(["a", undefined, undefined, "b"], schema), [
              "a",
              undefined,
              undefined,
              "b"
            ], undefined);
      }));

export {
  CommonWithNested ,
}
/*  Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import Ava from "ava";

Ava("Successfully parses and reverse converts a simple object with unnest", (function (t) {
        var schema = S.unnest(S.schema(function (s) {
                  return {
                          foo: s.m(S.string),
                          bar: s.m(S.$$int)
                        };
                }));
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(!Array.isArray(i)||i.length!==2||!Array.isArray(i[\"0\"])||!Array.isArray(i[\"1\"])){e[2](i)}let v1=new Array(Math.max(i[0].length,i[1].length,));for(let v0=0;v0<v1.length;++v0){let v3=i[0][v0],v4=i[1][v0];try{if(typeof v3!==\"string\"){e[0](v3)}if(typeof v4!==\"number\"||v4>2147483647||v4<-2147483648||v4%1!==0){e[1](v4)}v1[v0]={\"foo\":v3,\"bar\":v4,};}catch(v2){if(v2&&v2.s===s){v2.path=\"\"+\'[\"\'+v0+\'\"]\'+v2.path}throw v2}}return v1}", undefined);
        U.assertCompiledCode(t, schema, "Convert", "i=>{let v1=new Array(Math.max(i[0].length,i[1].length,));for(let v0=0;v0<v1.length;++v0){v1[v0]={\"foo\":i[0][v0],\"bar\":i[1][v0],};}return v1}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v1=[new Array(i.length),new Array(i.length),];for(let v0=0;v0<i.length;++v0){let v3=i[v0];v1[0][v0]=v3[\"foo\"];v1[1][v0]=v3[\"bar\"];}return v1}", undefined);
        U.assertCompiledCode(t, schema, "ReverseParse", "i=>{if(!Array.isArray(i)){e[3](i)}let v1=[new Array(i.length),new Array(i.length),];for(let v0=0;v0<i.length;++v0){let v3=i[v0];try{if(typeof v3!==\"object\"||!v3){e[0](v3)}let v4=v3[\"foo\"],v5=v3[\"bar\"];if(typeof v4!==\"string\"){e[1](v4)}if(typeof v5!==\"number\"||v5>2147483647||v5<-2147483648||v5%1!==0){e[2](v5)}v1[0][v0]=v4;v1[1][v0]=v5;}catch(v2){if(v2&&v2.s===s){v2.path=\"\"+\'[\"\'+v0+\'\"]\'+v2.path}throw v2}}return v1}", undefined);
        t.deepEqual(S.parseOrThrow([["a", "b"], [0, 1]], schema), [
              {
                foo: "a",
                bar: 0
              },
              {
                foo: "b",
                bar: 1
              }
            ], undefined);
        t.deepEqual(S.reverseConvertOrThrow([
                  {
                    foo: "a",
                    bar: 0
                  },
                  {
                    foo: "b",
                    bar: 1
                  }
                ], schema), [["a", "b"], [0, 1]], undefined);
        var example = S.unnest(S.schema(function (s) {
                  return {
                          id: s.m(S.string),
                          name: s.m(S.$$null(S.string)),
                          deleted: s.m(S.bool)
                        };
                }));
        U.assertCompiledCode(t, example, "ReverseConvert", "i=>{let v1=[new Array(i.length),new Array(i.length),new Array(i.length),];for(let v0=0;v0<i.length;++v0){let v3=i[v0];try{let v4=v3[\"name\"];if(v4===void 0){v4=null}v1[0][v0]=v3[\"id\"];v1[1][v0]=v4;v1[2][v0]=v3[\"deleted\"];}catch(v2){if(v2&&v2.s===s){v2.path=\"\"+\'[\"\'+v0+\'\"]\'+v2.path}throw v2}}return v1}", undefined);
      }));

Ava("Transforms nullable fields", (function (t) {
        var schema = S.unnest(S.schema(function (s) {
                  return {
                          foo: s.m(S.string),
                          bar: s.m(S.$$null(S.$$int))
                        };
                }));
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(!Array.isArray(i)||i.length!==2||!Array.isArray(i[\"0\"])||!Array.isArray(i[\"1\"])){e[2](i)}let v1=new Array(Math.max(i[0].length,i[1].length,));for(let v0=0;v0<v1.length;++v0){let v3=i[0][v0],v4=i[1][v0];try{if(typeof v3!==\"string\"){e[0](v3)}if(v4===null){v4=void 0}else if(!(typeof v4===\"number\"&&v4<2147483647&&v4>-2147483648&&v4%1===0)){e[1](v4)}v1[v0]={\"foo\":v3,\"bar\":v4,};}catch(v2){if(v2&&v2.s===s){v2.path=\"\"+\'[\"\'+v0+\'\"]\'+v2.path}throw v2}}return v1}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v1=[new Array(i.length),new Array(i.length),];for(let v0=0;v0<i.length;++v0){let v3=i[v0];try{let v4=v3[\"bar\"];if(v4===void 0){v4=null}v1[0][v0]=v3[\"foo\"];v1[1][v0]=v4;}catch(v2){if(v2&&v2.s===s){v2.path=\"\"+\'[\"\'+v0+\'\"]\'+v2.path}throw v2}}return v1}", undefined);
        t.deepEqual(S.parseOrThrow([["a", "b"], [0, null]], schema), [
              {
                foo: "a",
                bar: 0
              },
              {
                foo: "b",
                bar: undefined
              }
            ], undefined);
        t.deepEqual(S.reverseConvertOrThrow([
                  {
                    foo: "a",
                    bar: 0
                  },
                  {
                    foo: "b",
                    bar: undefined
                  }
                ], schema), [["a", "b"], [0, null]], undefined);
      }));

Ava("Case with missing item at the end", (function (t) {
        var schema = S.unnest(S.schema(function (s) {
                  return {
                          foo: s.m(S.option(S.string)),
                          bar: s.m(S.bool)
                        };
                }));
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(!Array.isArray(i)||i.length!==2||!Array.isArray(i[\"0\"])||!Array.isArray(i[\"1\"])){e[2](i)}let v1=new Array(Math.max(i[0].length,i[1].length,));for(let v0=0;v0<v1.length;++v0){let v3=i[0][v0],v4=i[1][v0];try{if(!(typeof v3===\"string\"||v3===void 0)){e[0](v3)}if(typeof v4!==\"boolean\"){e[1](v4)}v1[v0]={\"foo\":v3,\"bar\":v4,};}catch(v2){if(v2&&v2.s===s){v2.path=\"\"+\'[\"\'+v0+\'\"]\'+v2.path}throw v2}}return v1}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v1=[new Array(i.length),new Array(i.length),];for(let v0=0;v0<i.length;++v0){let v3=i[v0];v1[0][v0]=v3[\"foo\"];v1[1][v0]=v3[\"bar\"];}return v1}", undefined);
        t.deepEqual(S.parseOrThrow([["a", "b"], [true, true, false]], schema), [
              {
                foo: "a",
                bar: true
              },
              {
                foo: "b",
                bar: true
              },
              {
                foo: undefined,
                bar: false
              }
            ], undefined);
        t.deepEqual(S.reverseConvertOrThrow([
                  {
                    foo: "a",
                    bar: true
                  },
                  {
                    foo: "b",
                    bar: true
                  },
                  {
                    foo: undefined,
                    bar: false
                  }
                ], schema), [["a", "b", undefined], [true, true, false]], undefined);
      }));

Ava("Handles empty objects", (function (t) {
        t.throws((function () {
                return S.unnest(S.object(function (param) {
                                
                              }));
              }), {
              message: "[Schema] Invalid empty object for S.unnest schema."
            }, undefined);
      }));

Ava("Handles non-object schemas", (function (t) {
        t.throws((function () {
                return S.unnest(S.tuple2(S.string, S.$$int));
              }), {
              message: "[Schema] S.unnest supports only object schemas."
            }, undefined);
      }));

export {
  
}
/*  Not a pure module */

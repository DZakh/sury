// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import * as Ava from "ava";
import Ava$1 from "ava";

Ava$1("JSONSchema of bool schema", (function (t) {
        t.deepEqual(S.toJSONSchema(S.bool), {"type": "boolean"}, undefined);
      }));

Ava$1("JSONSchema of string schema", (function (t) {
        t.deepEqual(S.toJSONSchema(S.string), {"type": "string"}, undefined);
      }));

Ava$1("JSONSchema of int schema", (function (t) {
        t.deepEqual(S.toJSONSchema(S.$$int), {"type": "integer"}, undefined);
      }));

Ava$1("JSONSchema of float schema", (function (t) {
        t.deepEqual(S.toJSONSchema(S.$$float), {"type": "number"}, undefined);
      }));

Ava$1("JSONSchema of email schema", (function (t) {
        t.deepEqual(S.toJSONSchema(S.email(S.string, undefined)), {"type": "string", "format": "email"}, undefined);
      }));

Ava$1("JSONSchema of url schema", (function (t) {
        t.deepEqual(S.toJSONSchema(S.url(S.string, undefined)), {"type": "string", "format": "uri"}, "The format should be uri for url schema");
      }));

Ava$1("JSONSchema of datetime schema", (function (t) {
        t.deepEqual(S.toJSONSchema(S.datetime(S.string, undefined)), {"type": "string", "format": "date-time"}, undefined);
      }));

Ava$1("JSONSchema of cuid schema", (function (t) {
        t.deepEqual(S.toJSONSchema(S.cuid(S.string, undefined)), {"type": "string"}, undefined);
      }));

Ava$1("JSONSchema of uuid schema", (function (t) {
        t.deepEqual(S.toJSONSchema(S.uuid(S.string, undefined)), {"type": "string", "format": "uuid"}, undefined);
      }));

Ava$1("JSONSchema of pattern schema", (function (t) {
        t.deepEqual(S.toJSONSchema(S.pattern(S.string, /abc/g, undefined)), {"type": "string","pattern": "/abc/g"}, undefined);
      }));

Ava$1("JSONSchema of string schema uses the last refinement for format", (function (t) {
        t.deepEqual(S.toJSONSchema(S.datetime(S.email(S.string, undefined), undefined)), {"type": "string", "format": "date-time"}, undefined);
      }));

Ava$1("JSONSchema of string with min", (function (t) {
        t.deepEqual(S.toJSONSchema(S.min(S.string, 1, undefined)), {"type": "string", "minLength": 1}, undefined);
      }));

Ava$1("JSONSchema of string with max", (function (t) {
        t.deepEqual(S.toJSONSchema(S.max(S.string, 1, undefined)), {"type": "string", "maxLength": 1}, undefined);
      }));

Ava$1("JSONSchema of string with length", (function (t) {
        t.deepEqual(S.toJSONSchema(S.length(S.string, 1, undefined)), {"type": "string", "minLength": 1, "maxLength": 1}, undefined);
      }));

Ava$1("JSONSchema of string with both min and max", (function (t) {
        t.deepEqual(S.toJSONSchema(S.max(S.min(S.string, 1, undefined), 4, undefined)), {"type": "string", "minLength": 1, "maxLength": 4}, undefined);
      }));

Ava$1("JSONSchema of int with min", (function (t) {
        t.deepEqual(S.toJSONSchema(S.min(S.$$int, 1, undefined)), {"type": "integer", "minimum": 1}, undefined);
      }));

Ava$1("JSONSchema of int with max", (function (t) {
        t.deepEqual(S.toJSONSchema(S.max(S.$$int, 1, undefined)), {"type": "integer", "maximum": 1}, undefined);
      }));

Ava$1("JSONSchema of port", (function (t) {
        t.deepEqual(S.toJSONSchema(S.port(S.$$int, undefined)), {"type": "integer"}, undefined);
      }));

Ava$1("JSONSchema of float with min", (function (t) {
        t.deepEqual(S.toJSONSchema(S.floatMin(S.$$float, 1, undefined)), {"type": "number", "minimum": 1}, undefined);
      }));

Ava$1("JSONSchema of float with max", (function (t) {
        t.deepEqual(S.toJSONSchema(S.floatMax(S.$$float, 1, undefined)), {"type": "number", "maximum": 1}, undefined);
      }));

Ava$1("JSONSchema of nullable float", (function (t) {
        t.deepEqual(S.toJSONSchema(S.$$null(S.$$float)), {"anyOf": [{"type": "number"}, {"type": "null"}]}, undefined);
      }));

Ava$1("JSONSchema of never", (function (t) {
        t.deepEqual(S.toJSONSchema(S.never), {"not": {}}, undefined);
      }));

Ava$1("JSONSchema of true", (function (t) {
        t.deepEqual(S.toJSONSchema(S.literal(true)), {"type": "boolean", "const": true}, undefined);
      }));

Ava$1("JSONSchema of false", (function (t) {
        t.deepEqual(S.toJSONSchema(S.literal(false)), {"type": "boolean", "const": false}, undefined);
      }));

Ava$1("JSONSchema of string literal", (function (t) {
        t.deepEqual(S.toJSONSchema(S.literal("Hello World!")), {"type": "string", "const": "Hello World!"}, undefined);
      }));

Ava$1("JSONSchema of object literal", (function (t) {
        t.deepEqual(S.toJSONSchema(S.literal({
                      received: true
                    })), {
        "type": "object",
        "additionalProperties": true,
        "properties": {
          "received": {
            "type": "boolean",
            "const": true
          }
        },
        "required": ["received"]
      }, undefined);
      }));

Ava$1("JSONSchema of number literal", (function (t) {
        t.deepEqual(S.toJSONSchema(S.literal(123)), {"type": "number", "const": 123}, undefined);
      }));

Ava$1("JSONSchema of null", (function (t) {
        t.deepEqual(S.toJSONSchema(S.literal(null)), {"type": "null"}, undefined);
      }));

Ava$1("JSONSchema of undefined", (function (t) {
        U.assertThrowsMessage(t, (function () {
                return S.toJSONSchema(S.literal(undefined));
              }), "Failed converting to JSON: The 'undefined' schema cannot be converted to JSON");
      }));

Ava$1("JSONSchema of NaN", (function (t) {
        U.assertThrowsMessage(t, (function () {
                return S.toJSONSchema(S.literal(NaN));
              }), "Failed converting to JSON: The 'NaN' schema cannot be converted to JSON");
      }));

Ava$1("JSONSchema of tuple", (function (t) {
        t.deepEqual(S.toJSONSchema(S.tuple2(S.string, S.bool)), {
      "type": "array",
      "minItems": 2,
      "maxItems": 2,
      "items": [{"type": "string"}, {"type": "boolean"}],
  }, undefined);
      }));

Ava$1("JSONSchema of enum", (function (t) {
        t.deepEqual(S.toJSONSchema(S.$$enum([
                      "Yes",
                      "No"
                    ])), {
      "enum": ["Yes", "No"],
    }, undefined);
      }));

Ava$1("JSONSchema of union", (function (t) {
        t.deepEqual(S.toJSONSchema(S.union([
                      S.literal("Yes"),
                      S.string
                    ])), {
      "anyOf": [
        {
          const: 'Yes',
          type: 'string'
        },
        {
          type: 'string'
        }
      ]
    }, undefined);
      }));

Ava$1("JSONSchema of string array", (function (t) {
        t.deepEqual(S.toJSONSchema(S.array(S.string)), {
      "type": "array",
      "items": {"type": "string"},
    }, undefined);
      }));

Ava$1("JSONSchema of array with min length", (function (t) {
        t.deepEqual(S.toJSONSchema(S.min(S.array(S.string), 1, undefined)), {
      "type": "array",
      "items": {"type": "string"},
      "minItems": 1
    }, undefined);
      }));

Ava$1("JSONSchema of array with max length", (function (t) {
        t.deepEqual(S.toJSONSchema(S.max(S.array(S.string), 1, undefined)), {
      "type": "array",
      "items": {"type": "string"},
      "maxItems": 1
    }, undefined);
      }));

Ava$1("JSONSchema of array with fixed length", (function (t) {
        t.deepEqual(S.toJSONSchema(S.length(S.array(S.string), 1, undefined)), {
      "type": "array",
      "items": {"type": "string"},
      "minItems": 1,
      "maxItems": 1
    }, undefined);
      }));

Ava$1("JSONSchema of string dict", (function (t) {
        t.deepEqual(S.toJSONSchema(S.dict(S.string)), {
      "type": "object",
      "additionalProperties": {"type": "string"},
    }, undefined);
      }));

Ava$1("JSONSchema of object with single string field", (function (t) {
        t.deepEqual(S.toJSONSchema(S.object(function (s) {
                      return s.f("field", S.string);
                    })), {
      "type": "object",
      "properties": {"field": {"type": "string"}},
      "required": ["field"],
      "additionalProperties": true,
    }, undefined);
      }));

Ava$1("JSONSchema of object with strict mode", (function (t) {
        t.deepEqual(S.toJSONSchema(S.strict(S.object(function (s) {
                          return s.f("field", S.string);
                        }))), {
      "type": "object",
      "properties": {"field": {"type": "string"}},
      "required": ["field"],
      "additionalProperties": false,
    }, undefined);
      }));

Ava$1("JSONSchema of object with optional field", (function (t) {
        t.deepEqual(S.toJSONSchema(S.object(function (s) {
                      return s.f("field", S.option(S.string));
                    })), {
      "type": "object",
      "properties": {"field": {"type": "string"}},
      "additionalProperties": true,
    }, undefined);
      }));

Ava$1("JSONSchema of object with deprecated field", (function (t) {
        t.deepEqual(S.toJSONSchema(S.object(function (s) {
                      return s.f("field", S.meta(S.string, {
                                      description: "Use another field",
                                      deprecated: true
                                    }));
                    })), {
      "type": "object",
      "properties": {"field": {
        "type": "string",
        "deprecated": true,
        "description": "Use another field"
      }},
      "required": ["field"],
      "additionalProperties": true,
    }, undefined);
      }));

Ava$1("Deprecated message overrides existing description", (function (t) {
        t.deepEqual(S.toJSONSchema(S.meta(S.meta(S.string, {
                          description: "Previous description"
                        }), {
                      description: "Use another field",
                      deprecated: true
                    })), {
      "type": "string",
      "deprecated": true,
      "description": "Use another field"
    }, undefined);
      }));

Ava$1("JSONSchema of nested object", (function (t) {
        t.deepEqual(S.toJSONSchema(S.object(function (s) {
                      return s.f("objectWithOneStringField", S.object(function (s) {
                                      return s.f("Field", S.string);
                                    }));
                    })), {
      "type": "object",
      "properties": {
        "objectWithOneStringField": {
          "type": "object",
          "properties": {"Field": {"type": "string"}},
          "required": ["Field"],
          "additionalProperties": true,
        },
      },
      "required": ["objectWithOneStringField"],
      "additionalProperties": true,
    }, undefined);
      }));

Ava$1("JSONSchema of object with one optional and one normal field", (function (t) {
        t.deepEqual(S.toJSONSchema(S.object(function (s) {
                      return [
                              s.f("field", S.string),
                              s.f("optionalField", S.option(S.string))
                            ];
                    })), {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
        },
        "optionalField": {"type": "string"},
      },
      "required": ["field"],
      "additionalProperties": true,
    }, undefined);
      }));

Ava$1("JSONSchema of optional root schema", (function (t) {
        U.assertThrowsMessage(t, (function () {
                return S.toJSONSchema(S.option(S.string));
              }), "Failed converting to JSON: The \'string | undefined\' schema cannot be converted to JSON");
      }));

Ava$1("JSONSchema of object with S.option(S.option(_)) field", (function (t) {
        t.deepEqual(S.toJSONSchema(S.object(function (s) {
                      return s.f("field", S.option(S.option(S.string)));
                    })), {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
        },
      },
      "additionalProperties": true,
    }, undefined);
      }));

Ava.default.failing("JSONSchema of reversed object with S.option(S.option(_)) field", (function (t) {
        t.deepEqual(S.toJSONSchema(S.reverse(S.object(function (s) {
                          return s.f("field", S.option(S.option(S.string)));
                        }))), {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
        },
      },
      "additionalProperties": true,
    }, undefined);
      }));

export {
  
}
/*  Not a pure module */

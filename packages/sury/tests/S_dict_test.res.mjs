// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import Ava from "ava";

var value = Object.fromEntries([
      [
        "key1",
        "value1"
      ],
      [
        "key2",
        "value2"
      ]
    ]);

var any = {"key1":"value1","key2":"value2"};

var invalidAny = true;

var nestedInvalidAny = {"key1":"value1","key2":true};

function factory() {
  return S.dict(S.string);
}

Ava("Successfully parses", (function (t) {
        var schema = S.dict(S.string);
        t.deepEqual(S.parseOrThrow(any, schema), value, undefined);
      }));

Ava("Successfully serializes", (function (t) {
        var schema = S.dict(S.string);
        t.deepEqual(S.reverseConvertOrThrow(value, schema), any, undefined);
      }));

Ava("Fails to parse", (function (t) {
        var schema = S.dict(S.string);
        U.assertThrows(t, (function () {
                return S.parseOrThrow(invalidAny, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: schema,
                received: invalidAny
              },
              path: S.Path.empty
            });
      }));

Ava("Fails to parse nested", (function (t) {
        var schema = S.dict(S.string);
        U.assertThrows(t, (function () {
                return S.parseOrThrow(nestedInvalidAny, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.string,
                received: true
              },
              path: S.Path.fromArray(["key2"])
            });
      }));

Ava("Compiled parse code snapshot", (function (t) {
        var schema = S.dict(S.string);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i||Array.isArray(i)){e[1](i)}for(let v0 in i){let v2=i[v0];try{if(typeof v2!==\"string\"){e[0](v2)}}catch(v1){if(v1&&v1.s===s){v1.path=\"\"+\'[\"\'+v0+\'\"]\'+v1.path}throw v1}}return i}", undefined);
      }));

Ava("Compiled async parse code snapshot", (function (t) {
        var schema = S.dict(S.transform(S.unknown, (function (param) {
                    return {
                            a: (function (i) {
                                return Promise.resolve(i);
                              })
                          };
                  })));
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i||Array.isArray(i)){e[1](i)}let v3={};for(let v0 in i){let v2;try{v2=e[0](i[v0]).catch(v1=>{if(v1&&v1.s===s){v1.path=\"\"+\'[\"\'+v0+\'\"]\'+v1.path}throw v1})}catch(v1){if(v1&&v1.s===s){v1.path=\"\"+\'[\"\'+v0+\'\"]\'+v1.path}throw v1}v3[v0]=v2}return new Promise((v4,v5)=>{let v7=Object.keys(v3).length;for(let v0 in v3){v3[v0].then(v6=>{v3[v0]=v6;if(v7--===1){v4(v3)}},v5)}})}", undefined);
      }));

Ava("Compiled serialize code snapshot", (function (t) {
        var schema = S.dict(S.string);
        U.assertCompiledCodeIsNoop(t, schema, "ReverseConvert", undefined);
        var schema$1 = S.dict(S.option(S.string));
        U.assertCompiledCodeIsNoop(t, schema$1, "ReverseConvert", undefined);
      }));

Ava("Compiled serialize code snapshot with transform", (function (t) {
        var schema = S.dict(S.$$null(S.string));
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v4={};for(let v0 in i){let v2=i[v0],v3;try{if(v2===void 0){v2=null}v3=v2}catch(v1){if(v1&&v1.s===s){v1.path=\"\"+\'[\"\'+v0+\'\"]\'+v1.path}throw v1}v4[v0]=v3}return v4}", undefined);
      }));

Ava("Reverse to self", (function (t) {
        var schema = S.dict(S.string);
        t.is(S.reverse(schema), schema, undefined);
      }));

Ava("Succesfully uses reversed schema for parsing back to initial value", (function (t) {
        var schema = S.dict(S.string);
        U.assertReverseParsesBack(t, schema, value);
      }));

var CommonWithNested = {
  value: value,
  any: any,
  invalidAny: invalidAny,
  nestedInvalidAny: nestedInvalidAny,
  factory: factory
};

Ava("Reverse child schema", (function (t) {
        var schema = S.dict(S.$$null(S.string));
        U.assertEqualSchemas(t, S.reverse(schema), S.dict(S.option(S.string)), undefined);
      }));

Ava("Successfully parses dict with int keys", (function (t) {
        var schema = S.dict(S.string);
        t.deepEqual(S.parseOrThrow({1:"b",2:"d"}, schema), Object.fromEntries([
                  [
                    "1",
                    "b"
                  ],
                  [
                    "2",
                    "d"
                  ]
                ]), undefined);
      }));

Ava("Applies operation for each item on serializing", (function (t) {
        var schema = S.dict(S.jsonString(S.$$int, undefined));
        t.deepEqual(S.reverseConvertOrThrow(Object.fromEntries([
                      [
                        "a",
                        1
                      ],
                      [
                        "b",
                        2
                      ]
                    ]), schema), {
        "a": "1",
        "b": "2",
      }, undefined);
      }));

Ava("Fails to serialize dict item", (function (t) {
        var schema = S.dict(S.refine(S.string, (function (s) {
                    return function (param) {
                      s.fail("User error", undefined);
                    };
                  })));
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow(Object.fromEntries([
                                [
                                  "a",
                                  "aa"
                                ],
                                [
                                  "b",
                                  "bb"
                                ]
                              ]), schema);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "OperationFailed",
                _0: "User error"
              },
              path: S.Path.fromLocation("a")
            });
      }));

Ava("Successfully parses dict with optional items", (function (t) {
        var schema = S.dict(S.option(S.string));
        t.deepEqual(S.parseOrThrow({"key1":"value1","key2":undefined}, schema), Object.fromEntries([
                  [
                    "key1",
                    "value1"
                  ],
                  [
                    "key2",
                    undefined
                  ]
                ]), undefined);
      }));

export {
  CommonWithNested ,
}
/* value Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import * as Ava from "ava";
import Ava$1 from "ava";

Ava$1("Successfully reverse converts jsonable schemas", (function (t) {
        t.deepEqual(S.reverseConvertToJsonOrThrow(true, S.bool), true, undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow(true, S.literal(true)), true, undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow("abc", S.string), "abc", undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow("abc", S.literal("abc")), "abc", undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow(123, S.$$int), 123, undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow(123, S.literal(123)), 123, undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow(123, S.$$float), 123, undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow(123, S.literal(123)), 123, undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow([
                  true,
                  "foo",
                  123
                ], S.literal([
                      true,
                      "foo",
                      123
                    ])), [
              true,
              "foo",
              123
            ], undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow({
                  foo: true
                }, S.literal({
                      foo: true
                    })), Object.fromEntries([[
                    "foo",
                    true
                  ]]), undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow({
                  foo: [
                    true,
                    "foo",
                    123
                  ]
                }, S.literal({
                      foo: [
                        true,
                        "foo",
                        123
                      ]
                    })), Object.fromEntries([[
                    "foo",
                    [
                      true,
                      "foo",
                      123
                    ]
                  ]]), undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow(undefined, S.$$null(S.bool)), null, undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow(null, S.literal(null)), null, undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow([], S.array(S.bool)), [], undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow({}, S.dict(S.bool)), {}, undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow(true, S.object(function (s) {
                      return s.f("foo", S.bool);
                    })), Object.fromEntries([[
                    "foo",
                    true
                  ]]), undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow(true, S.tuple1(S.bool)), [true], undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow("foo", S.union([
                      S.literal("foo"),
                      S.literal("bar")
                    ])), "foo", undefined);
      }));

Ava$1("Fails to reverse convert Option schema", (function (t) {
        var schema = S.option(S.bool);
        U.assertThrows(t, (function () {
                return S.reverseConvertToJsonOrThrow(undefined, schema);
              }), {
              operation: "ReverseConvertToJson",
              code: {
                TAG: "InvalidJsonSchema",
                _0: schema
              },
              path: S.Path.empty
            });
      }));

Ava$1("Allows to convert to JSON with option as an object field", (function (t) {
        var schema = S.schema(function (s) {
              return {
                      foo: s.m(S.option(S.bool))
                    };
            });
        t.deepEqual(S.reverseConvertToJsonOrThrow({
                  foo: undefined
                }, schema), {"foo":undefined}, "Shouldn't have undefined value here. Needs to be fixed in future versions");
      }));

Ava$1("Allows to convert to JSON with optional S.json as an object field", (function (t) {
        var schema = S.schema(function (s) {
              return {
                      foo: s.m(S.option(S.json(false)))
                    };
            });
        t.deepEqual(S.reverseConvertToJsonOrThrow({
                  foo: undefined
                }, schema), {"foo":undefined}, "Shouldn't have undefined value here. Needs to be fixed in future versions");
      }));

Ava$1("Doesn't allow to convert to JSON array with optional items", (function (t) {
        var schema = S.array(S.option(S.bool));
        U.assertThrowsMessage(t, (function () {
                return S.reverseConvertToJsonOrThrow([undefined], schema);
              }), "Failed converting to JSON: The \'(boolean | undefined)[]\' schema cannot be converted to JSON");
      }));

Ava$1("Doesn't allow to convert to JSON tuple with optional items", (function (t) {
        var schema = S.tuple1(S.option(S.bool));
        U.assertThrowsMessage(t, (function () {
                return S.reverseConvertToJsonOrThrow(undefined, schema);
              }), "Failed converting to JSON at [\"0\"]: The 'boolean | undefined' schema cannot be converted to JSON");
      }));

Ava$1("Allows to convert to JSON with option as dict field", (function (t) {
        var schema = S.dict(S.option(S.bool));
        t.deepEqual(S.reverseConvertToJsonOrThrow(Object.fromEntries([[
                        "foo",
                        undefined
                      ]]), schema), {foo:undefined}, "Shouldn't have undefined value here. Needs to be fixed in future versions");
      }));

Ava$1("Fails to reverse convert Undefined literal", (function (t) {
        var schema = S.literal();
        U.assertThrows(t, (function () {
                return S.reverseConvertToJsonOrThrow(undefined, schema);
              }), {
              operation: "ReverseConvertToJson",
              code: {
                TAG: "InvalidJsonSchema",
                _0: schema
              },
              path: S.Path.empty
            });
      }));

Ava$1("Fails to reverse convert Function literal", (function (t) {
        var fn = function () {
          
        };
        var schema = S.literal(fn);
        U.assertThrows(t, (function () {
                return S.reverseConvertToJsonOrThrow(fn, schema);
              }), {
              operation: "ReverseConvertToJson",
              code: {
                TAG: "InvalidJsonSchema",
                _0: schema
              },
              path: S.Path.empty
            });
      }));

Ava.default.failing("Fails to reverse convert Object literal", (function (t) {
        var error = (new Error("foo"));
        var schema = S.literal(error);
        U.assertThrows(t, (function () {
                return S.reverseConvertToJsonOrThrow(error, schema);
              }), {
              operation: "ReverseConvertToJson",
              code: {
                TAG: "InvalidJsonSchema",
                _0: schema
              },
              path: S.Path.empty
            });
      }));

Ava$1("Fails to reverse convert Symbol literal", (function (t) {
        var symbol = (Symbol());
        var schema = S.literal(symbol);
        U.assertThrows(t, (function () {
                return S.reverseConvertToJsonOrThrow(symbol, schema);
              }), {
              operation: "ReverseConvertToJson",
              code: {
                TAG: "InvalidJsonSchema",
                _0: schema
              },
              path: S.Path.empty
            });
      }));

Ava$1("Fails to reverse convert BigInt literal", (function (t) {
        var bigint = 1234n;
        var schema = S.literal(bigint);
        U.assertThrows(t, (function () {
                return S.reverseConvertToJsonOrThrow(bigint, schema);
              }), {
              operation: "ReverseConvertToJson",
              code: {
                TAG: "InvalidJsonSchema",
                _0: schema
              },
              path: S.Path.empty
            });
      }));

Ava$1("Fails to reverse convert Dict literal with invalid field", (function (t) {
        var dict = {"foo": 123n};
        var schema = S.literal(dict);
        U.assertThrows(t, (function () {
                return S.reverseConvertToJsonOrThrow(dict, schema);
              }), {
              operation: "ReverseConvertToJson",
              code: {
                TAG: "InvalidJsonSchema",
                _0: S.literal(123n)
              },
              path: S.Path.fromLocation("foo")
            });
      }));

Ava$1("Fails to reverse convert NaN literal", (function (t) {
        var schema = S.literal(NaN);
        U.assertThrows(t, (function () {
                return S.reverseConvertToJsonOrThrow(undefined, schema);
              }), {
              operation: "ReverseConvertToJson",
              code: {
                TAG: "InvalidJsonSchema",
                _0: schema
              },
              path: S.Path.empty
            });
      }));

Ava$1("Fails to reverse convert Unknown schema", (function (t) {
        U.assertThrows(t, (function () {
                return S.reverseConvertToJsonOrThrow(123, S.unknown);
              }), {
              operation: "ReverseConvertToJson",
              code: {
                TAG: "InvalidJsonSchema",
                _0: S.unknown
              },
              path: S.Path.empty
            });
      }));

Ava$1("Fails to reverse convert Never schema", (function (t) {
        U.assertThrows(t, (function () {
                return S.reverseConvertToJsonOrThrow(123, S.never);
              }), {
              operation: "ReverseConvertToJson",
              code: {
                TAG: "InvalidType",
                expected: S.never,
                received: 123
              },
              path: S.Path.empty
            });
      }));

Ava$1("Fails to reverse convert object with invalid nested schema", (function (t) {
        U.assertThrowsMessage(t, (function () {
                return S.reverseConvertToJsonOrThrow(true, S.object(function (s) {
                                return s.f("foo", S.unknown);
                              }));
              }), "Failed converting to JSON at [\"foo\"]: The \'unknown\' schema cannot be converted to JSON");
      }));

Ava$1("Fails to reverse convert tuple with invalid nested schema", (function (t) {
        U.assertThrowsMessage(t, (function () {
                return S.reverseConvertToJsonOrThrow(true, S.tuple1(S.unknown));
              }), "Failed converting to JSON at [\"0\"]: The \'unknown\' schema cannot be converted to JSON");
      }));

Ava$1("Doesn't serialize union to JSON when at least one item is not JSON-able", (function (t) {
        var schema = S.union([
              S.string,
              S.unknown
            ]);
        U.assertThrowsMessage(t, (function () {
                return S.reverseConvertToJsonOrThrow("foo", schema);
              }), "Failed converting to JSON: The \'string | unknown\' schema cannot be converted to JSON");
        t.deepEqual(S.reverseConvertOrThrow("foo", schema), "foo", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{try{if(typeof i!==\"string\"){e[0](i)}}catch(e0){e[1](i,e0)}return i}", undefined);
      }));

Ava$1("Fails to reverse convert union with invalid json schemas", (function (t) {
        var schema = S.union([
              S.literal(NaN),
              S.unknown
            ]);
        U.assertThrowsMessage(t, (function () {
                return S.reverseConvertToJsonOrThrow(NaN, schema);
              }), "Failed converting to JSON: The \'NaN | unknown\' schema cannot be converted to JSON");
      }));

var Connective = {};

var Operator = {};

var Comparison = {
  Operator: Operator
};

var schema = S.recursive(function (innerSchema) {
      return S.union([
                  S.object(function (s) {
                        s.tag("type", "or");
                        return {
                                TAG: "Connective",
                                _0: {
                                  operator: "or",
                                  conditions: s.f("value", S.array(innerSchema))
                                }
                              };
                      }),
                  S.object(function (s) {
                        s.tag("type", "and");
                        return {
                                TAG: "Connective",
                                _0: {
                                  operator: "and",
                                  conditions: s.f("value", S.array(innerSchema))
                                }
                              };
                      }),
                  S.object(function (s) {
                        s.tag("type", "equal");
                        return {
                                TAG: "Comparison",
                                _0: {
                                  operator: "equal",
                                  values: s.f("value", S.tuple2(S.string, S.string))
                                }
                              };
                      }),
                  S.object(function (s) {
                        s.tag("type", "greater-than");
                        return {
                                TAG: "Comparison",
                                _0: {
                                  operator: "greater-than",
                                  values: s.f("value", S.tuple2(S.string, S.string))
                                }
                              };
                      })
                ]);
    });

var Condition = {
  Connective: Connective,
  Comparison: Comparison,
  schema: schema
};

var bodySchema = S.schema(function (s) {
      return {
              condition: s.m(schema)
            };
    });

var conditionJSON = {
  "type": "and",
  "value": [
    {
      "type": "equal",
      "value": [
        "account",
        "1234"        
      ]
    },
    {
      "type": "greater-than",
      "value": [
        "cost-center",
        "1000"        
      ]
    }
  ]
};

var condition = {
  TAG: "Connective",
  _0: {
    operator: "and",
    conditions: [
      {
        TAG: "Comparison",
        _0: {
          operator: "equal",
          values: [
            "account",
            "1234"
          ]
        }
      },
      {
        TAG: "Comparison",
        _0: {
          operator: "greater-than",
          values: [
            "cost-center",
            "1000"
          ]
        }
      }
    ]
  }
};

Ava.default.failing("Serializes deeply recursive schema", (function (t) {
        U.assertCompiledCode(t, bodySchema, "ReverseConvert", "i=>{let v0=i[\"condition\"],v22;let r0=v0=>{if(typeof v0===\"object\"&&v0){if(v0[\"TAG\"]===\"Connective\"){let v1=v0[\"TAG\"],v2=v0[\"_0\"][\"operator\"],v3=v0[\"_0\"][\"conditions\"],v7=new Array(v3.length);if(v1!==\"Connective\"){e[0](v1)}if(v2!==\"or\"){e[1](v2)}for(let v4=0;v4<v3.length;++v4){let v6;try{v6=r0(v3[v4])}catch(v5){if(v5&&v5.s===s){v5.path=\"[\\\"_0\\\"][\\\"conditions\\\"]\"+\'[\"\'+v4+\'\"]\'+v5.path}throw v5}v7[v4]=v6}v0={\"type\":e[2],\"value\":v7,}}else if(v0[\"TAG\"]===\"Connective\"){let v8=v0[\"TAG\"],v9=v0[\"_0\"][\"operator\"],v10=v0[\"_0\"][\"conditions\"],v14=new Array(v10.length);if(v8!==\"Connective\"){e[3](v8)}if(v9!==\"and\"){e[4](v9)}for(let v11=0;v11<v10.length;++v11){let v13;try{v13=r0(v10[v11])}catch(v12){if(v12&&v12.s===s){v12.path=\"[\\\"_0\\\"][\\\"conditions\\\"]\"+\'[\"\'+v11+\'\"]\'+v12.path}throw v12}v14[v11]=v13}v0={\"type\":e[5],\"value\":v14,}}else if(v0[\"TAG\"]===\"Comparison\"){let v15=v0[\"TAG\"],v16=v0[\"_0\"][\"operator\"],v17=v0[\"_0\"][\"values\"];if(v15!==\"Comparison\"){e[6](v15)}if(v16!==\"equal\"){e[7](v16)}v0={\"type\":e[8],\"value\":v17,}}else if(v0[\"TAG\"]===\"Comparison\"){let v18=v0[\"TAG\"],v19=v0[\"_0\"][\"operator\"],v20=v0[\"_0\"][\"values\"];if(v18!==\"Comparison\"){e[9](v18)}if(v19!==\"greater-than\"){e[10](v19)}v0={\"type\":e[11],\"value\":v20,}}}return v0};try{v22=r0(v0)}catch(v21){if(v21&&v21.s===s){v21.path=\"[\\\"condition\\\"]\"+v21.path}throw v21}return {\"condition\":v22,}}", undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow({
                  condition: condition
                }, bodySchema), {
              condition: conditionJSON
            }, undefined);
      }));

var SerializesDeepRecursive = {
  Condition: Condition,
  bodySchema: bodySchema,
  conditionJSON: conditionJSON,
  condition: condition
};

export {
  SerializesDeepRecursive ,
}
/*  Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import Ava from "ava";

Ava("Successfully parses object with inlinable string field", (function (t) {
        var schema = S.object(function (s) {
              return {
                      field: s.f("field", S.string)
                    };
            });
        t.deepEqual(S.parseOrThrow({field: "bar"}, schema), {
              field: "bar"
            }, undefined);
      }));

Ava("Fails to parse object with inlinable string field", (function (t) {
        var schema = S.object(function (s) {
              return {
                      field: s.f("field", S.string)
                    };
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow({field: 123}, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.string,
                received: 123
              },
              path: S.Path.fromArray(["field"])
            });
      }));

Ava("Fails to parse object with custom user error in array field (should have correct path)", (function (t) {
        var schema = S.object(function (s) {
              return {
                      field: s.f("field", S.array(S.refine(S.string, (function (s) {
                                      return function (param) {
                                        s.fail("User error", undefined);
                                      };
                                    }))))
                    };
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow({field: ["foo"]}, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "OperationFailed",
                _0: "User error"
              },
              path: S.Path.fromArray([
                    "field",
                    "0"
                  ])
            });
      }));

Ava("Successfully parses object with inlinable bool field", (function (t) {
        var schema = S.object(function (s) {
              return {
                      field: s.f("field", S.bool)
                    };
            });
        t.deepEqual(S.parseOrThrow({field: true}, schema), {
              field: true
            }, undefined);
      }));

Ava("Fails to parse object with inlinable bool field", (function (t) {
        var schema = S.object(function (s) {
              return {
                      field: s.f("field", S.bool)
                    };
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow({field: 123}, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.bool,
                received: 123
              },
              path: S.Path.fromArray(["field"])
            });
      }));

Ava("Successfully parses object with unknown field (Noop operation)", (function (t) {
        var schema = S.object(function (s) {
              return {
                      field: s.f("field", S.unknown)
                    };
            });
        t.deepEqual(S.parseOrThrow(({field: new Date("2015-12-12")}), schema), ({field: new Date("2015-12-12")}), undefined);
      }));

Ava("Successfully serializes object with unknown field (Noop operation)", (function (t) {
        var schema = S.object(function (s) {
              return {
                      field: s.f("field", S.unknown)
                    };
            });
        t.deepEqual(S.reverseConvertOrThrow(({field: new Date("2015-12-12")}), schema), ({field: new Date("2015-12-12")}), undefined);
      }));

Ava("Fails to parse object with inlinable never field", (function (t) {
        var schema = S.object(function (s) {
              return {
                      field: s.f("field", S.never)
                    };
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow({field: true}, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.never,
                received: true
              },
              path: S.Path.fromArray(["field"])
            });
      }));

Ava("Successfully parses object with inlinable float field", (function (t) {
        var schema = S.object(function (s) {
              return {
                      field: s.f("field", S.$$float)
                    };
            });
        t.deepEqual(S.parseOrThrow({field: 123}, schema), {
              field: 123
            }, undefined);
      }));

Ava("Fails to parse object with inlinable float field", (function (t) {
        var schema = S.object(function (s) {
              return {
                      field: s.f("field", S.$$float)
                    };
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow({field: true}, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.$$float,
                received: true
              },
              path: S.Path.fromArray(["field"])
            });
      }));

Ava("Successfully parses object with inlinable int field", (function (t) {
        var schema = S.object(function (s) {
              return {
                      field: s.f("field", S.$$int)
                    };
            });
        t.deepEqual(S.parseOrThrow({field: 123}, schema), {
              field: 123
            }, undefined);
      }));

Ava("Fails to parse object with inlinable int field", (function (t) {
        var schema = S.object(function (s) {
              return {
                      field: s.f("field", S.$$int)
                    };
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow({field: true}, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.$$int,
                received: true
              },
              path: S.Path.fromArray(["field"])
            });
      }));

Ava("Successfully parses object with not inlinable empty object field", (function (t) {
        var schema = S.object(function (s) {
              return {
                      field: s.f("field", S.object(function (param) {
                                
                              }))
                    };
            });
        t.deepEqual(S.parseOrThrow({field: {}}, schema), {
              field: undefined
            }, undefined);
      }));

Ava("Fails to parse object with not inlinable empty object field", (function (t) {
        var fieldSchema = S.object(function (param) {
              
            });
        var schema = S.object(function (s) {
              return {
                      field: s.f("field", fieldSchema)
                    };
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow({field: true}, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: fieldSchema,
                received: true
              },
              path: S.Path.fromArray(["field"])
            });
      }));

Ava("Fails to parse object when provided invalid data", (function (t) {
        var schema = S.object(function (s) {
              return {
                      field: s.f("field", S.string)
                    };
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow(12, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: schema,
                received: 12
              },
              path: S.Path.empty
            });
      }));

Ava("Successfully serializes object with single field", (function (t) {
        var schema = S.object(function (s) {
              return {
                      field: s.f("field", S.string)
                    };
            });
        t.deepEqual(S.reverseConvertOrThrow({
                  field: "bar"
                }, schema), {field: "bar"}, undefined);
      }));

Ava("Successfully parses object with multiple fields", (function (t) {
        var schema = S.object(function (s) {
              return {
                      boo: s.f("boo", S.string),
                      zoo: s.f("zoo", S.string)
                    };
            });
        t.deepEqual(S.parseOrThrow({boo: "bar", zoo: "jee"}, schema), {
              boo: "bar",
              zoo: "jee"
            }, undefined);
      }));

Ava("Successfully serializes object with multiple fields", (function (t) {
        var schema = S.object(function (s) {
              return {
                      boo: s.f("boo", S.string),
                      zoo: s.f("zoo", S.string)
                    };
            });
        t.deepEqual(S.reverseConvertOrThrow({
                  boo: "bar",
                  zoo: "jee"
                }, schema), {boo: "bar", zoo: "jee"}, undefined);
      }));

Ava("Successfully parses object with transformed field", (function (t) {
        var schema = S.object(function (s) {
              return {
                      string: s.f("string", S.transform(S.string, (function (param) {
                                  return {
                                          p: (function (string) {
                                              return string + "field";
                                            })
                                        };
                                })))
                    };
            });
        t.deepEqual(S.parseOrThrow({string: "bar"}, schema), {
              string: "barfield"
            }, undefined);
      }));

Ava("Fails to parse object when transformed field has raises error", (function (t) {
        var schema = S.object(function (s) {
              return {
                      field: s.f("field", S.transform(S.string, (function (s) {
                                  return {
                                          p: (function (param) {
                                              return s.fail("User error", undefined);
                                            })
                                        };
                                })))
                    };
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow({
                            field: "bar"
                          }, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "OperationFailed",
                _0: "User error"
              },
              path: S.Path.fromArray(["field"])
            });
      }));

Ava("Shows transformed object field name in error path when fails to parse", (function (t) {
        var schema = S.object(function (s) {
              return {
                      transformedFieldName: s.f("originalFieldName", S.transform(S.string, (function (s) {
                                  return {
                                          p: (function (param) {
                                              return s.fail("User error", undefined);
                                            })
                                        };
                                })))
                    };
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow({
                            originalFieldName: "bar"
                          }, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "OperationFailed",
                _0: "User error"
              },
              path: S.Path.fromArray(["originalFieldName"])
            });
      }));

Ava("Successfully serializes object with transformed field", (function (t) {
        var schema = S.object(function (s) {
              return {
                      string: s.f("string", S.transform(S.string, (function (param) {
                                  return {
                                          s: (function (string) {
                                              return string + "field";
                                            })
                                        };
                                })))
                    };
            });
        t.deepEqual(S.reverseConvertOrThrow({
                  string: "bar"
                }, schema), {"string": "barfield"}, undefined);
      }));

Ava("Fails to serializes object when transformed field has raises error", (function (t) {
        var schema = S.object(function (s) {
              return {
                      field: s.f("field", S.transform(S.string, (function (s) {
                                  return {
                                          s: (function (param) {
                                              return s.fail("User error", undefined);
                                            })
                                        };
                                })))
                    };
            });
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow({
                            field: "bar"
                          }, schema);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "OperationFailed",
                _0: "User error"
              },
              path: S.Path.fromArray(["field"])
            });
      }));

Ava("Shows transformed object field name in error path when fails to serializes", (function (t) {
        var schema = S.object(function (s) {
              return {
                      transformedFieldName: s.f("originalFieldName", S.transform(S.string, (function (s) {
                                  return {
                                          s: (function (param) {
                                              return s.fail("User error", undefined);
                                            })
                                        };
                                })))
                    };
            });
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow({
                            transformedFieldName: "bar"
                          }, schema);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "OperationFailed",
                _0: "User error"
              },
              path: S.Path.fromArray(["transformedFieldName"])
            });
      }));

Ava("Shows transformed to nested object field name in error path when fails to serializes", (function (t) {
        var schema = S.object(function (s) {
              return {
                      v1: {
                        transformedFieldName: s.f("originalFieldName", S.transform(S.string, (function (s) {
                                    return {
                                            s: (function (param) {
                                                return s.fail("User error", undefined);
                                              })
                                          };
                                  })))
                      }
                    };
            });
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow({
                            v1: {
                              transformedFieldName: "bar"
                            }
                          }, schema);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "OperationFailed",
                _0: "User error"
              },
              path: S.Path.fromArray([
                    "v1",
                    "transformedFieldName"
                  ])
            });
      }));

Ava("Successfully parses object with optional fields", (function (t) {
        var schema = S.object(function (s) {
              return {
                      boo: s.f("boo", S.option(S.string)),
                      zoo: s.f("zoo", S.option(S.string))
                    };
            });
        t.deepEqual(S.parseOrThrow({boo: "bar"}, schema), {
              boo: "bar",
              zoo: undefined
            }, undefined);
      }));

Ava("Successfully serializes object with optional fields", (function (t) {
        var schema = S.object(function (s) {
              return {
                      boo: s.f("boo", S.option(S.string)),
                      zoo: s.f("zoo", S.option(S.string))
                    };
            });
        t.deepEqual(S.reverseConvertOrThrow({
                  boo: "bar",
                  zoo: undefined
                }, schema), {boo: "bar", zoo: undefined}, undefined);
      }));

Ava("Successfully parses object with optional fields with default", (function (t) {
        var schema = S.object(function (s) {
              return {
                      boo: s.fieldOr("boo", S.string, "default boo"),
                      zoo: s.fieldOr("zoo", S.string, "default zoo")
                    };
            });
        t.deepEqual(S.parseOrThrow({boo: "bar"}, schema), {
              boo: "bar",
              zoo: "default zoo"
            }, undefined);
      }));

Ava("Successfully serializes object with optional fields with default", (function (t) {
        var schema = S.object(function (s) {
              return {
                      boo: s.fieldOr("boo", S.string, "default boo"),
                      zoo: s.fieldOr("zoo", S.string, "default zoo")
                    };
            });
        t.deepEqual(S.reverseConvertOrThrow({
                  boo: "bar",
                  zoo: "baz"
                }, schema), {boo: "bar", zoo: "baz"}, undefined);
      }));

Ava("Successfully parses object with optional fields using (?). The optinal field becomes undefined instead of beeing missing", (function (t) {
        var optionsSchema = S.object(function (s) {
              return {
                      fast: s.f("fast", S.option(S.bool)),
                      mode: s.f("mode", S.$$int)
                    };
            });
        t.deepEqual(S.parseOrThrow({mode: 1}, optionsSchema), {
              fast: undefined,
              mode: 1
            }, undefined);
      }));

Ava("Successfully serializes object with optional fields using (?)", (function (t) {
        var optionsSchema = S.object(function (s) {
              return {
                      fast: s.f("fast", S.option(S.bool)),
                      mode: s.f("mode", S.$$int)
                    };
            });
        t.deepEqual(S.reverseConvertOrThrow({
                  mode: 1
                }, optionsSchema), {mode: 1, fast: undefined}, undefined);
      }));

Ava("Successfully parses object with mapped field names", (function (t) {
        var schema = S.object(function (s) {
              return {
                      name: s.f("Name", S.string),
                      email: s.f("Email", S.string),
                      age: s.f("Age", S.$$int)
                    };
            });
        t.deepEqual(S.parseOrThrow({"Name":"Dmitry","Email":"dzakh.dev@gmail.com","Age":21}, schema), {
              name: "Dmitry",
              email: "dzakh.dev@gmail.com",
              age: 21
            }, undefined);
      }));

Ava("Successfully serializes object with mapped field", (function (t) {
        var schema = S.object(function (s) {
              return {
                      name: s.f("Name", S.string),
                      email: s.f("Email", S.string),
                      age: s.f("Age", S.$$int)
                    };
            });
        t.deepEqual(S.reverseConvertOrThrow({
                  name: "Dmitry",
                  email: "dzakh.dev@gmail.com",
                  age: 21
                }, schema), {"Name":"Dmitry","Email":"dzakh.dev@gmail.com","Age":21}, undefined);
      }));

Ava("Successfully parses object transformed to tuple", (function (t) {
        var schema = S.object(function (s) {
              return [
                      s.f("boo", S.$$int),
                      s.f("zoo", S.$$int)
                    ];
            });
        t.deepEqual(S.parseOrThrow({boo: 1, zoo: 2}, schema), [
              1,
              2
            ], undefined);
      }));

Ava("Successfully serializes object transformed to tuple", (function (t) {
        var schema = S.object(function (s) {
              return [
                      s.f("boo", S.$$int),
                      s.f("zoo", S.$$int)
                    ];
            });
        t.deepEqual(S.reverseConvertOrThrow([
                  1,
                  2
                ], schema), {boo: 1, zoo: 2}, undefined);
      }));

Ava("Successfully parses object transformed to nested object", (function (t) {
        var schema = S.object(function (s) {
              return {
                      v1: {
                        boo: s.f("boo", S.$$int),
                        zoo: s.f("zoo", S.$$int)
                      }
                    };
            });
        t.deepEqual(S.parseOrThrow({boo: 1, zoo: 2}, schema), {
              v1: {
                boo: 1,
                zoo: 2
              }
            }, undefined);
      }));

Ava("Successfully serializes object transformed to nested object", (function (t) {
        var schema = S.object(function (s) {
              return {
                      v1: {
                        boo: s.f("boo", S.$$int),
                        zoo: s.f("zoo", S.$$int)
                      }
                    };
            });
        t.deepEqual(S.reverseConvertOrThrow({
                  v1: {
                    boo: 1,
                    zoo: 2
                  }
                }, schema), {boo: 1, zoo: 2}, undefined);
      }));

Ava("Successfully parses object transformed to nested tuple", (function (t) {
        var schema = S.object(function (s) {
              return {
                      v1: [
                        s.f("boo", S.$$int),
                        s.f("zoo", S.$$int)
                      ]
                    };
            });
        t.deepEqual(S.parseOrThrow({boo: 1, zoo: 2}, schema), {
              v1: [
                1,
                2
              ]
            }, undefined);
      }));

Ava("Successfully serializes object transformed to nested tuple", (function (t) {
        var schema = S.object(function (s) {
              return {
                      v1: [
                        s.f("boo", S.$$int),
                        s.f("zoo", S.$$int)
                      ]
                    };
            });
        t.deepEqual(S.reverseConvertOrThrow({
                  v1: [
                    1,
                    2
                  ]
                }, schema), {boo: 1, zoo: 2}, undefined);
      }));

Ava("Successfully parses object with only one field returned from transformer", (function (t) {
        var schema = S.object(function (s) {
              return s.f("field", S.bool);
            });
        t.deepEqual(S.parseOrThrow({"field": true}, schema), true, undefined);
      }));

Ava("Successfully serializes object with only one field returned from transformer", (function (t) {
        var schema = S.object(function (s) {
              return s.f("field", S.bool);
            });
        t.deepEqual(S.reverseConvertOrThrow(true, schema), {"field": true}, undefined);
      }));

Ava("Successfully parses object transformed to the one with hardcoded fields", (function (t) {
        var schema = S.object(function (s) {
              return {
                      hardcoded: false,
                      field: s.f("field", S.bool)
                    };
            });
        t.deepEqual(S.parseOrThrow({"field": true}, schema), {
              hardcoded: false,
              field: true
            }, undefined);
      }));

Ava("Successfully serializes object transformed to the one with hardcoded fields", (function (t) {
        var schema = S.object(function (s) {
              return {
                      hardcoded: false,
                      field: s.f("field", S.bool)
                    };
            });
        t.deepEqual(S.reverseConvertOrThrow({
                  hardcoded: false,
                  field: true
                }, schema), {"field": true}, undefined);
      }));

Ava("Successfully parses object transformed to variant", (function (t) {
        var schema = S.object(function (s) {
              return {
                      NAME: "VARIANT",
                      VAL: s.f("field", S.bool)
                    };
            });
        t.deepEqual(S.parseOrThrow({"field": true}, schema), {
              NAME: "VARIANT",
              VAL: true
            }, undefined);
      }));

Ava("Successfully serializes object transformed to variant", (function (t) {
        var schema = S.object(function (s) {
              return {
                      NAME: "VARIANT",
                      VAL: s.f("field", S.bool)
                    };
            });
        t.deepEqual(S.reverseConvertOrThrow({
                  NAME: "VARIANT",
                  VAL: true
                }, schema), {"field": true}, undefined);
      }));

Ava("Parse reversed schema with nested objects and tuples has type validation", (function (t) {
        var schema = S.object(function (s) {
              return {
                      foo: 1,
                      obj: {
                        foo: 2,
                        bar: s.f("bar", S.string)
                      },
                      tuple: [
                        3,
                        s.f("baz", S.bool)
                      ]
                    };
            });
        U.assertThrows(t, (function () {
                return S.compile(schema, "Output", "Input", "Sync", true);
              }), {
              operation: "ReverseParse",
              code: {
                TAG: "InvalidOperation",
                description: "Type validation mode is not supported"
              },
              path: S.Path.empty
            });
        U.assertCompiledCode(t, S.object(function (s) {
                  return {
                          foo: s.f("foo", S.bool)
                        };
                }), "ReverseParse", "i=>{if(typeof i!==\"object\"||!i){e[1](i)}let v0=i[\"foo\"];if(typeof v0!==\"boolean\"){e[0](v0)}return {\"foo\":v0,}}", undefined);
      }));

function makeTestObject() {
  return (Object.freeze({
    number: 1,
    negNumber: -1,
    maxNumber: Number.MAX_VALUE,
    string: 'string',
    longString:
      'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Vivendum intellegat et qui, ei denique consequuntur vix. Semper aeterno percipit ut his, sea ex utinam referrentur repudiandae. No epicuri hendrerit consetetur sit, sit dicta adipiscing ex, in facete detracto deterruisset duo. Quot populo ad qui. Sit fugit nostrum et. Ad per diam dicant interesset, lorem iusto sensibus ut sed. No dicam aperiam vis. Pri posse graeco definitiones cu, id eam populo quaestio adipiscing, usu quod malorum te. Ex nam agam veri, dicunt efficiantur ad qui, ad legere adversarium sit. Commune platonem mel id, brute adipiscing duo an. Vivendum intellegat et qui, ei denique consequuntur vix. Offendit eleifend moderatius ex vix, quem odio mazim et qui, purto expetendis cotidieque quo cu, veri persius vituperata ei nec. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.',
    boolean: true,
    deeplyNested: {
      foo: 'bar',
      num: 1,
      bool: false,
    },
  }));
}

function makeSchema() {
  return S.object(function (s) {
              return {
                      number: s.f("number", S.$$float),
                      negNumber: s.f("negNumber", S.$$float),
                      maxNumber: s.f("maxNumber", S.$$float),
                      string: s.f("string", S.string),
                      longString: s.f("longString", S.string),
                      boolean: s.f("boolean", S.bool),
                      deeplyNested: s.f("deeplyNested", S.object(function (s) {
                                return {
                                        foo: s.f("foo", S.string),
                                        num: s.f("num", S.$$float),
                                        bool: s.f("bool", S.bool)
                                      };
                              }))
                    };
            });
}

Ava("Successfully parses object from benchmark - with S.object", (function (t) {
        S.setGlobalConfig({
              disableNanNumberValidation: true
            });
        var schema = makeSchema();
        t.deepEqual(S.parseOrThrow(makeTestObject(), schema), makeTestObject(), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[10](i)}let v0=i[\"number\"],v1=i[\"negNumber\"],v2=i[\"maxNumber\"],v3=i[\"string\"],v4=i[\"longString\"],v5=i[\"boolean\"],v6=i[\"deeplyNested\"];if(typeof v0!==\"number\"){e[0](v0)}if(typeof v1!==\"number\"){e[1](v1)}if(typeof v2!==\"number\"){e[2](v2)}if(typeof v3!==\"string\"){e[3](v3)}if(typeof v4!==\"string\"){e[4](v4)}if(typeof v5!==\"boolean\"){e[5](v5)}if(typeof v6!==\"object\"||!v6){e[6](v6)}let v7=v6[\"foo\"],v8=v6[\"num\"],v9=v6[\"bool\"];if(typeof v7!==\"string\"){e[7](v7)}if(typeof v8!==\"number\"){e[8](v8)}if(typeof v9!==\"boolean\"){e[9](v9)}return {\"number\":v0,\"negNumber\":v1,\"maxNumber\":v2,\"string\":v3,\"longString\":v4,\"boolean\":v5,\"deeplyNested\":{\"foo\":v7,\"num\":v8,\"bool\":v9,},}}", undefined);
        S.setGlobalConfig({});
      }));

Ava("Successfully asserts object from benchmark - with S.object", (function (t) {
        S.setGlobalConfig({
              disableNanNumberValidation: true
            });
        var schema = makeSchema();
        t.deepEqual(S.assertOrThrow(makeTestObject(), schema), undefined, undefined);
        U.assertCompiledCode(t, schema, "Assert", "i=>{if(typeof i!==\"object\"||!i){e[10](i)}let v0=i[\"number\"],v1=i[\"negNumber\"],v2=i[\"maxNumber\"],v3=i[\"string\"],v4=i[\"longString\"],v5=i[\"boolean\"],v6=i[\"deeplyNested\"];if(typeof v0!==\"number\"){e[0](v0)}if(typeof v1!==\"number\"){e[1](v1)}if(typeof v2!==\"number\"){e[2](v2)}if(typeof v3!==\"string\"){e[3](v3)}if(typeof v4!==\"string\"){e[4](v4)}if(typeof v5!==\"boolean\"){e[5](v5)}if(typeof v6!==\"object\"||!v6){e[6](v6)}let v7=v6[\"foo\"],v8=v6[\"num\"],v9=v6[\"bool\"];if(typeof v7!==\"string\"){e[7](v7)}if(typeof v8!==\"number\"){e[8](v8)}if(typeof v9!==\"boolean\"){e[9](v9)}return void 0}", undefined);
        S.setGlobalConfig({});
      }));

Ava("Successfully parses strict object from benchmark - with S.object", (function (t) {
        S.setGlobalConfig({
              defaultAdditionalItems: "strict",
              disableNanNumberValidation: true
            });
        var schema = makeSchema();
        t.deepEqual(S.parseOrThrow(makeTestObject(), schema), makeTestObject(), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i||Array.isArray(i)){e[12](i)}let v0=i[\"number\"],v1=i[\"negNumber\"],v2=i[\"maxNumber\"],v3=i[\"string\"],v4=i[\"longString\"],v5=i[\"boolean\"],v6=i[\"deeplyNested\"],v11;if(typeof v0!==\"number\"){e[0](v0)}if(typeof v1!==\"number\"){e[1](v1)}if(typeof v2!==\"number\"){e[2](v2)}if(typeof v3!==\"string\"){e[3](v3)}if(typeof v4!==\"string\"){e[4](v4)}if(typeof v5!==\"boolean\"){e[5](v5)}if(typeof v6!==\"object\"||!v6||Array.isArray(v6)){e[6](v6)}let v7=v6[\"foo\"],v8=v6[\"num\"],v9=v6[\"bool\"],v10;if(typeof v7!==\"string\"){e[7](v7)}if(typeof v8!==\"number\"){e[8](v8)}if(typeof v9!==\"boolean\"){e[9](v9)}for(v10 in v6){if(v10!==\"foo\"&&v10!==\"num\"&&v10!==\"bool\"){e[10](v10)}}for(v11 in i){if(v11!==\"number\"&&v11!==\"negNumber\"&&v11!==\"maxNumber\"&&v11!==\"string\"&&v11!==\"longString\"&&v11!==\"boolean\"&&v11!==\"deeplyNested\"){e[11](v11)}}return {\"number\":v0,\"negNumber\":v1,\"maxNumber\":v2,\"string\":v3,\"longString\":v4,\"boolean\":v5,\"deeplyNested\":{\"foo\":v7,\"num\":v8,\"bool\":v9,},}}", undefined);
        S.setGlobalConfig({});
      }));

Ava("Successfully asserts strict object from benchmark - with S.object", (function (t) {
        S.setGlobalConfig({
              defaultAdditionalItems: "strict",
              disableNanNumberValidation: true
            });
        var schema = makeSchema();
        t.deepEqual(S.assertOrThrow(makeTestObject(), schema), undefined, undefined);
        U.assertCompiledCode(t, schema, "Assert", "i=>{if(typeof i!==\"object\"||!i||Array.isArray(i)){e[12](i)}let v0=i[\"number\"],v1=i[\"negNumber\"],v2=i[\"maxNumber\"],v3=i[\"string\"],v4=i[\"longString\"],v5=i[\"boolean\"],v6=i[\"deeplyNested\"],v11;if(typeof v0!==\"number\"){e[0](v0)}if(typeof v1!==\"number\"){e[1](v1)}if(typeof v2!==\"number\"){e[2](v2)}if(typeof v3!==\"string\"){e[3](v3)}if(typeof v4!==\"string\"){e[4](v4)}if(typeof v5!==\"boolean\"){e[5](v5)}if(typeof v6!==\"object\"||!v6||Array.isArray(v6)){e[6](v6)}let v7=v6[\"foo\"],v8=v6[\"num\"],v9=v6[\"bool\"],v10;if(typeof v7!==\"string\"){e[7](v7)}if(typeof v8!==\"number\"){e[8](v8)}if(typeof v9!==\"boolean\"){e[9](v9)}for(v10 in v6){if(v10!==\"foo\"&&v10!==\"num\"&&v10!==\"bool\"){e[10](v10)}}for(v11 in i){if(v11!==\"number\"&&v11!==\"negNumber\"&&v11!==\"maxNumber\"&&v11!==\"string\"&&v11!==\"longString\"&&v11!==\"boolean\"&&v11!==\"deeplyNested\"){e[11](v11)}}return void 0}", undefined);
        S.setGlobalConfig({});
      }));

Ava("Successfully serializes object from benchmark - with S.object", (function (t) {
        S.setGlobalConfig({
              disableNanNumberValidation: true
            });
        var schema = makeSchema();
        t.deepEqual(S.reverseConvertOrThrow(makeTestObject(), schema), makeTestObject(), undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v0=i[\"deeplyNested\"];return {\"number\":i[\"number\"],\"negNumber\":i[\"negNumber\"],\"maxNumber\":i[\"maxNumber\"],\"string\":i[\"string\"],\"longString\":i[\"longString\"],\"boolean\":i[\"boolean\"],\"deeplyNested\":{\"foo\":v0[\"foo\"],\"num\":v0[\"num\"],\"bool\":v0[\"bool\"],},}}", undefined);
        S.setGlobalConfig({});
      }));

var BenchmarkWithSObject = {
  makeTestObject: makeTestObject,
  makeSchema: makeSchema
};

function makeTestObject$1() {
  return (Object.freeze({
    number: 1,
    negNumber: -1,
    maxNumber: Number.MAX_VALUE,
    string: 'string',
    longString:
      'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Vivendum intellegat et qui, ei denique consequuntur vix. Semper aeterno percipit ut his, sea ex utinam referrentur repudiandae. No epicuri hendrerit consetetur sit, sit dicta adipiscing ex, in facete detracto deterruisset duo. Quot populo ad qui. Sit fugit nostrum et. Ad per diam dicant interesset, lorem iusto sensibus ut sed. No dicam aperiam vis. Pri posse graeco definitiones cu, id eam populo quaestio adipiscing, usu quod malorum te. Ex nam agam veri, dicunt efficiantur ad qui, ad legere adversarium sit. Commune platonem mel id, brute adipiscing duo an. Vivendum intellegat et qui, ei denique consequuntur vix. Offendit eleifend moderatius ex vix, quem odio mazim et qui, purto expetendis cotidieque quo cu, veri persius vituperata ei nec. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.',
    boolean: true,
    deeplyNested: {
      foo: 'bar',
      num: 1,
      bool: false,
    },
  }));
}

function makeSchema$1() {
  return S.schema(function (s) {
              return {
                      number: s.m(S.$$float),
                      negNumber: s.m(S.$$float),
                      maxNumber: s.m(S.$$float),
                      string: s.m(S.string),
                      longString: s.m(S.string),
                      boolean: s.m(S.bool),
                      deeplyNested: {
                        foo: s.m(S.string),
                        num: s.m(S.$$float),
                        bool: s.m(S.bool)
                      }
                    };
            });
}

Ava("Successfully parses object from benchmark", (function (t) {
        S.setGlobalConfig({
              disableNanNumberValidation: true
            });
        var schema = makeSchema$1();
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[10](i)}let v0=i[\"number\"],v1=i[\"negNumber\"],v2=i[\"maxNumber\"],v3=i[\"string\"],v4=i[\"longString\"],v5=i[\"boolean\"],v6=i[\"deeplyNested\"];if(typeof v0!==\"number\"){e[0](v0)}if(typeof v1!==\"number\"){e[1](v1)}if(typeof v2!==\"number\"){e[2](v2)}if(typeof v3!==\"string\"){e[3](v3)}if(typeof v4!==\"string\"){e[4](v4)}if(typeof v5!==\"boolean\"){e[5](v5)}if(typeof v6!==\"object\"||!v6){e[6](v6)}let v7=v6[\"foo\"],v8=v6[\"num\"],v9=v6[\"bool\"];if(typeof v7!==\"string\"){e[7](v7)}if(typeof v8!==\"number\"){e[8](v8)}if(typeof v9!==\"boolean\"){e[9](v9)}return {\"number\":v0,\"negNumber\":v1,\"maxNumber\":v2,\"string\":v3,\"longString\":v4,\"boolean\":v5,\"deeplyNested\":{\"foo\":v7,\"num\":v8,\"bool\":v9,},}}", undefined);
        t.deepEqual(S.parseOrThrow(makeTestObject$1(), schema), makeTestObject$1(), undefined);
        S.setGlobalConfig({});
      }));

Ava("Successfully asserts object from benchmark", (function (t) {
        S.setGlobalConfig({
              disableNanNumberValidation: true
            });
        var schema = makeSchema$1();
        t.deepEqual(S.assertOrThrow(makeTestObject$1(), schema), undefined, undefined);
        U.assertCompiledCode(t, schema, "Assert", "i=>{if(typeof i!==\"object\"||!i){e[10](i)}let v0=i[\"number\"],v1=i[\"negNumber\"],v2=i[\"maxNumber\"],v3=i[\"string\"],v4=i[\"longString\"],v5=i[\"boolean\"],v6=i[\"deeplyNested\"];if(typeof v0!==\"number\"){e[0](v0)}if(typeof v1!==\"number\"){e[1](v1)}if(typeof v2!==\"number\"){e[2](v2)}if(typeof v3!==\"string\"){e[3](v3)}if(typeof v4!==\"string\"){e[4](v4)}if(typeof v5!==\"boolean\"){e[5](v5)}if(typeof v6!==\"object\"||!v6){e[6](v6)}let v7=v6[\"foo\"],v8=v6[\"num\"],v9=v6[\"bool\"];if(typeof v7!==\"string\"){e[7](v7)}if(typeof v8!==\"number\"){e[8](v8)}if(typeof v9!==\"boolean\"){e[9](v9)}return void 0}", undefined);
        S.setGlobalConfig({});
      }));

Ava("Successfully parses strict object from benchmark", (function (t) {
        S.setGlobalConfig({
              defaultAdditionalItems: "strict",
              disableNanNumberValidation: true
            });
        var schema = makeSchema$1();
        t.deepEqual(S.parseOrThrow(makeTestObject$1(), schema), makeTestObject$1(), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i||Array.isArray(i)){e[12](i)}let v0=i[\"number\"],v1=i[\"negNumber\"],v2=i[\"maxNumber\"],v3=i[\"string\"],v4=i[\"longString\"],v5=i[\"boolean\"],v6=i[\"deeplyNested\"],v11;if(typeof v0!==\"number\"){e[0](v0)}if(typeof v1!==\"number\"){e[1](v1)}if(typeof v2!==\"number\"){e[2](v2)}if(typeof v3!==\"string\"){e[3](v3)}if(typeof v4!==\"string\"){e[4](v4)}if(typeof v5!==\"boolean\"){e[5](v5)}if(typeof v6!==\"object\"||!v6||Array.isArray(v6)){e[6](v6)}let v7=v6[\"foo\"],v8=v6[\"num\"],v9=v6[\"bool\"],v10;if(typeof v7!==\"string\"){e[7](v7)}if(typeof v8!==\"number\"){e[8](v8)}if(typeof v9!==\"boolean\"){e[9](v9)}for(v10 in v6){if(v10!==\"foo\"&&v10!==\"num\"&&v10!==\"bool\"){e[10](v10)}}for(v11 in i){if(v11!==\"number\"&&v11!==\"negNumber\"&&v11!==\"maxNumber\"&&v11!==\"string\"&&v11!==\"longString\"&&v11!==\"boolean\"&&v11!==\"deeplyNested\"){e[11](v11)}}return i}", undefined);
        S.setGlobalConfig({});
      }));

Ava("Successfully asserts strict object from benchmark", (function (t) {
        S.setGlobalConfig({
              defaultAdditionalItems: "strict",
              disableNanNumberValidation: true
            });
        var schema = makeSchema$1();
        t.deepEqual(S.assertOrThrow(makeTestObject$1(), schema), undefined, undefined);
        U.assertCompiledCode(t, schema, "Assert", "i=>{if(typeof i!==\"object\"||!i||Array.isArray(i)){e[12](i)}let v0=i[\"number\"],v1=i[\"negNumber\"],v2=i[\"maxNumber\"],v3=i[\"string\"],v4=i[\"longString\"],v5=i[\"boolean\"],v6=i[\"deeplyNested\"],v11;if(typeof v0!==\"number\"){e[0](v0)}if(typeof v1!==\"number\"){e[1](v1)}if(typeof v2!==\"number\"){e[2](v2)}if(typeof v3!==\"string\"){e[3](v3)}if(typeof v4!==\"string\"){e[4](v4)}if(typeof v5!==\"boolean\"){e[5](v5)}if(typeof v6!==\"object\"||!v6||Array.isArray(v6)){e[6](v6)}let v7=v6[\"foo\"],v8=v6[\"num\"],v9=v6[\"bool\"],v10;if(typeof v7!==\"string\"){e[7](v7)}if(typeof v8!==\"number\"){e[8](v8)}if(typeof v9!==\"boolean\"){e[9](v9)}for(v10 in v6){if(v10!==\"foo\"&&v10!==\"num\"&&v10!==\"bool\"){e[10](v10)}}for(v11 in i){if(v11!==\"number\"&&v11!==\"negNumber\"&&v11!==\"maxNumber\"&&v11!==\"string\"&&v11!==\"longString\"&&v11!==\"boolean\"&&v11!==\"deeplyNested\"){e[11](v11)}}return void 0}", undefined);
        S.setGlobalConfig({});
      }));

Ava("Successfully serializes object from benchmark", (function (t) {
        S.setGlobalConfig({
              disableNanNumberValidation: true
            });
        var schema = makeSchema$1();
        t.deepEqual(S.reverseConvertOrThrow(makeTestObject$1(), schema), makeTestObject$1(), undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v0=i[\"deeplyNested\"];return i}", undefined);
        S.setGlobalConfig({});
      }));

var Benchmark = {
  makeTestObject: makeTestObject$1,
  makeSchema: makeSchema$1
};

Ava("Successfully parses object and serializes it back to the initial data", (function (t) {
        var any = {"Name":"Dmitry","Email":"dzakh.dev@gmail.com","Age":21};
        var schema = S.object(function (s) {
              return {
                      name: s.f("Name", S.string),
                      email: s.f("Email", S.string),
                      age: s.f("Age", S.$$int)
                    };
            });
        t.deepEqual(S.reverseConvertOrThrow(S.parseOrThrow(any, schema), schema), any, undefined);
      }));

Ava("Allows to create object schema with unused fields", (function (t) {
        var schema = S.object(function (s) {
              s.f("unused", S.string);
              return {
                      field: s.f("field", S.string)
                    };
            });
        t.deepEqual(S.parseOrThrow({"field": "foo", "unused": "bar"}, schema), {
              field: "foo"
            }, undefined);
      }));

Ava("Fails to create object schema with single field defined multiple times", (function (t) {
        t.throws((function () {
                return S.object(function (s) {
                            return {
                                    boo: s.f("field", S.string),
                                    zoo: s.f("field", S.$$int)
                                  };
                          });
              }), {
              message: "[Schema] The field \"field\" defined twice with incompatible schemas"
            }, undefined);
      }));

Ava("Successfully parses object schema with single field registered multiple times", (function (t) {
        var schema = S.object(function (s) {
              var field = s.f("field", S.string);
              return {
                      field1: field,
                      field2: field
                    };
            });
        t.deepEqual(S.parseOrThrow({"field": "foo"}, schema), {
              field1: "foo",
              field2: "foo"
            }, undefined);
      }));

Ava("Reverse convert of object schema with single field registered multiple times", (function (t) {
        var schema = S.object(function (s) {
              var field = s.f("field", S.string);
              return {
                      field1: field,
                      field2: field,
                      field3: field
                    };
            });
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return {\"field\":i[\"field3\"],}}", undefined);
        t.deepEqual(S.reverseConvertOrThrow({
                  field1: "foo",
                  field2: "foo",
                  field3: "foo"
                }, schema), {"field": "foo"}, undefined);
      }));

Ava("Can destructure fields of simple nested objects", (function (t) {
        var schema = S.object(function (s) {
              var nested = s.f("nested", S.object(function (s) {
                        return {
                                foo: s.f("foo", S.string),
                                bar: s.f("bar", S.string)
                              };
                      }));
              return {
                      baz: nested.bar,
                      foz: nested.foo
                    };
            });
        t.deepEqual(S.parseOrThrow({"nested": {"foo": "foo", "bar": "bar"}}, schema), {
              baz: "bar",
              foz: "foo"
            }, undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[3](i)}let v0=i[\"nested\"];if(typeof v0!==\"object\"||!v0){e[0](v0)}let v1=v0[\"foo\"],v2=v0[\"bar\"];if(typeof v1!==\"string\"){e[1](v1)}if(typeof v2!==\"string\"){e[2](v2)}return {\"baz\":v2,\"foz\":v1,}}", undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow({
                  baz: "bar",
                  foz: "foo"
                }, schema), {"nested": {"foo": "foo", "bar": "bar"}}, undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v0={\"foo\":i[\"foz\"],\"bar\":i[\"baz\"],};return {\"nested\":{\"foo\":v0[\"foo\"],\"bar\":v0[\"bar\"],},}}", undefined);
      }));

Ava("Object schema parsing checks order", (function (t) {
        var schema = S.strict(S.object(function (s) {
                  s.tag("tag", "value");
                  return {
                          key: s.f("key", S.string)
                        };
                }));
        U.assertThrows(t, (function () {
                return S.parseOrThrow("foo", schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: schema,
                received: "foo"
              },
              path: S.Path.empty
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow({tag: "wrong", key: 123, unknownKey: "value", unknownKey2: "value"}, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: schema,
                received: {tag: "wrong", key: 123, unknownKey: "value", unknownKey2: "value"}
              },
              path: S.Path.empty
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow({tag: "value", key: 123, unknownKey: "value", unknownKey2: "value"}, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.string,
                received: 123
              },
              path: S.Path.fromLocation("key")
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow({tag: "value", key: "value", unknownKey: "value2", unknownKey2: "value2"}, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "ExcessField",
                _0: "unknownKey"
              },
              path: S.Path.empty
            });
        t.deepEqual(S.parseOrThrow({tag: "value", key: "value"}, schema), {
              key: "value"
            }, undefined);
      }));

Ava("Compiled code snapshot for simple object", (function (t) {
        var schema = S.object(function (s) {
              return {
                      foo: s.f("foo", S.string),
                      bar: s.f("bar", S.bool)
                    };
            });
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[2](i)}let v0=i[\"foo\"],v1=i[\"bar\"];if(typeof v0!==\"string\"){e[0](v0)}if(typeof v1!==\"boolean\"){e[1](v1)}return {\"foo\":v0,\"bar\":v1,}}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return {\"foo\":i[\"foo\"],\"bar\":i[\"bar\"],}}", undefined);
      }));

Ava("Compiled code snapshot for refined nested object", (function (t) {
        var schema = S.object(function (s) {
              return {
                      foo: s.f("foo", S.literal(12)),
                      bar: s.f("bar", S.refine(S.object(function (s) {
                                    return {
                                            baz: s.f("baz", S.string)
                                          };
                                  }), (function (param) {
                                  return function (param) {
                                    
                                  };
                                })))
                    };
            });
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i||i[\"foo\"]!==12){e[3](i)}let v2;let v0=i[\"bar\"];if(typeof v0!==\"object\"||!v0){e[0](v0)}let v1=v0[\"baz\"];if(typeof v1!==\"string\"){e[1](v1)}v2={\"baz\":v1,};e[2](v2);return {\"foo\":i[\"foo\"],\"bar\":v2,}}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v0=i[\"foo\"],v1=i[\"bar\"];if(v0!==12){e[0](v0)}e[1](v1);return {\"foo\":v0,\"bar\":{\"baz\":v1[\"baz\"],},}}", undefined);
      }));

Ava("Compiled parse code snapshot for simple object with async", (function (t) {
        var schema = S.object(function (s) {
              return {
                      foo: s.f("foo", S.transform(S.unknown, (function (param) {
                                  return {
                                          a: (function (i) {
                                              return Promise.resolve(i);
                                            })
                                        };
                                }))),
                      bar: s.f("bar", S.bool)
                    };
            });
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[2](i)}let v0=i[\"bar\"];if(typeof v0!==\"boolean\"){e[1](v0)}return Promise.all([e[0](i[\"foo\"]),]).then(a=>({\"foo\":a[0],\"bar\":v0,}))}", undefined);
      }));

Ava("Compiled parse code snapshot with async field registered as return", (function (t) {
        var schema = S.object(function (s) {
              return s.f("foo", S.transform(S.unknown, (function (param) {
                                return {
                                        a: (function (i) {
                                            return Promise.resolve(i);
                                          })
                                      };
                              })));
            });
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[1](i)}return e[0](i[\"foo\"])}", undefined);
      }));

Ava("Compiled parse code snapshot for simple object with strict unknown keys", (function (t) {
        var schema = S.strict(S.object(function (s) {
                  return {
                          foo: s.f("foo", S.string),
                          bar: s.f("bar", S.bool)
                        };
                }));
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i||Array.isArray(i)){e[3](i)}let v0=i[\"foo\"],v1=i[\"bar\"],v2;if(typeof v0!==\"string\"){e[0](v0)}if(typeof v1!==\"boolean\"){e[1](v1)}for(v2 in i){if(v2!==\"foo\"&&v2!==\"bar\"){e[2](v2)}}return {\"foo\":v0,\"bar\":v1,}}", undefined);
      }));

Ava("Compiled serialize code snapshot for simple object with strict unknown keys", (function (t) {
        var schema = S.strict(S.object(function (s) {
                  return {
                          foo: s.f("foo", S.string),
                          bar: s.f("bar", S.bool)
                        };
                }));
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return {\"foo\":i[\"foo\"],\"bar\":i[\"bar\"],}}", undefined);
      }));

Ava("Compiled code snapshot for nested empty object with strict unknown keys", (function (t) {
        var schema = S.schema(function (s) {
              return {
                      nested: s.m(S.strict(S.object(function (param) {
                                    
                                  })))
                    };
            });
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[3](i)}let v0=i[\"nested\"];if(typeof v0!==\"object\"||!v0||Array.isArray(v0)){e[0](v0)}let v1;for(v1 in v0){if(true){e[1](v1)}}return {\"nested\":e[2],}}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v0=i[\"nested\"];if(v0!==void 0){e[0](v0)}return {\"nested\":{},}}", undefined);
      }));

Ava("Compiled parse code snapshot for simple object with strict unknown keys, renamed fields, constants and discriminants", (function (t) {
        var schema = S.strict(S.object(function (s) {
                  s.tag("tag", 0);
                  return {
                          foo: s.f("FOO", S.string),
                          bar: s.f("BAR", S.bool),
                          zoo: 1
                        };
                }));
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i||Array.isArray(i)||i[\"tag\"]!==0){e[4](i)}let v0=i[\"FOO\"],v1=i[\"BAR\"],v2;if(typeof v0!==\"string\"){e[0](v0)}if(typeof v1!==\"boolean\"){e[1](v1)}for(v2 in i){if(v2!==\"tag\"&&v2!==\"FOO\"&&v2!==\"BAR\"){e[2](v2)}}return {\"foo\":v0,\"bar\":v1,\"zoo\":e[3],}}", undefined);
      }));

Ava("Compiled serialize code snapshot for simple object with strict unknown keys, renamed fields, constants and discriminants", (function (t) {
        var schema = S.strict(S.object(function (s) {
                  s.tag("tag", 0);
                  return {
                          foo: s.f("FOO", S.string),
                          bar: s.f("BAR", S.bool),
                          zoo: 1
                        };
                }));
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v0=i[\"zoo\"];if(v0!==1){e[0](v0)}return {\"tag\":e[1],\"FOO\":i[\"foo\"],\"BAR\":i[\"bar\"],}}", undefined);
      }));

var Compiled = {};

Ava("Works with object schema used multiple times as a child schema. See: https://github.com/DZakh/rescript-schema/issues/63", (function (t) {
        var appVersionSpecSchema = S.object(function (s) {
              return {
                      current: s.f("current", S.string),
                      minimum: s.f("minimum", S.string)
                    };
            });
        var appVersionsSchema = S.object(function (s) {
              return {
                      ios: s.f("ios", appVersionSpecSchema),
                      android: s.f("android", appVersionSpecSchema)
                    };
            });
        var appVersions = {
          ios: {
            current: "1.1",
            minimum: "1.0"
          },
          android: {
            current: "1.2",
            minimum: "1.1"
          }
        };
        var value = S.parseOrThrow(appVersions, appVersionsSchema);
        t.deepEqual(value, appVersions, undefined);
        var data = S.reverseConvertToJsonOrThrow(appVersions, appVersionsSchema);
        t.deepEqual(data, appVersions, undefined);
      }));

Ava("Reverse empty object schema to literal", (function (t) {
        var schema = S.object(function (param) {
              
            });
        U.assertEqualSchemas(t, S.reverse(schema), S.unit, undefined);
        U.assertReverseParsesBack(t, schema, undefined);
      }));

Ava("Compiles to async serialize operation with the sync object schema", (function (t) {
        var schema = S.object(function (param) {
              
            });
        U.assertCompiledCode(t, schema, "ReverseConvertAsync", "i=>{if(i!==void 0){e[0](i)}return Promise.resolve({})}", undefined);
      }));

Ava("Reverse tagged object to literal without payload", (function (t) {
        var schema = S.object(function (s) {
              s.tag("kind", "test");
              return "Test";
            });
        U.assertEqualSchemas(t, S.reverse(schema), S.literal("Test"), undefined);
        U.assertReverseParsesBack(t, schema, "Test");
      }));

Ava("Reverse tagged object to primitive schema", (function (t) {
        var schema = S.object(function (s) {
              s.tag("kind", "test");
              return s.f("field", S.bool);
            });
        U.assertEqualSchemas(t, S.reverse(schema), S.bool, undefined);
        U.assertReverseParsesBack(t, schema, true);
      }));

Ava("Reverse object with discriminant which is an object transformed to literal", (function (t) {
        var schema = S.object(function (s) {
              s.f("kind", S.object(function (s) {
                        s.tag("nestedKind", "test");
                        return "foo";
                      }));
              return s.f("field", S.bool);
            });
        U.assertEqualSchemas(t, S.reverse(schema), S.bool, undefined);
        U.assertReverseParsesBack(t, schema, true);
      }));

Ava("Reverse with output of nested object/tuple schema", (function (t) {
        var schema = S.object(function (s) {
              s.tag("kind", "test");
              return {
                      nested: {
                        field: [
                          s.f("raw_field", S.bool),
                          true
                        ]
                      }
                    };
            });
        U.assertEqualSchemas(t, S.reverse(schema), S.object(function (s) {
                  s.f("nested", S.object(function (s) {
                            s.f("field", S.tuple(function (s) {
                                      s.item(0, S.bool);
                                      s.tag(1, true);
                                    }));
                          }));
                }), undefined);
        U.assertReverseParsesBack(t, schema, {
              nested: {
                field: [
                  true,
                  true
                ]
              }
            });
      }));

export {
  BenchmarkWithSObject ,
  Benchmark ,
  Compiled ,
}
/*  Not a pure module */

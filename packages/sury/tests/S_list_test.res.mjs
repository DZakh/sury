// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import Ava from "ava";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

var value = {
  hd: "Hello world!",
  tl: {
    hd: "",
    tl: /* [] */0
  }
};

var any = ["Hello world!", ""];

var invalidAny = true;

var nestedInvalidAny = ["Hello world!", 1];

function factory() {
  return S.list(S.string);
}

Ava("Successfully parses", (function (t) {
        var schema = S.list(S.string);
        t.deepEqual(S.parseOrThrow(any, schema), value, undefined);
      }));

Ava("Fails to parse", (function (t) {
        var schema = S.list(S.string);
        var val;
        try {
          val = S.parseOrThrow(invalidAny, schema);
        }
        catch (raw_e){
          var e = Caml_js_exceptions.internalToOCamlException(raw_e);
          if (e.RE_EXN_ID === S.$$Error) {
            var e$1 = e._1;
            t.deepEqual(e$1.flag, S.Flag.typeValidation, undefined);
            t.deepEqual(e$1.path, S.Path.empty, undefined);
            var match = e$1.code;
            if (typeof match !== "object") {
              return t.fail("Unexpected code.");
            }
            if (match.TAG !== "InvalidType") {
              return t.fail("Unexpected code.");
            }
            t.deepEqual(match.received, invalidAny, undefined);
            return U.unsafeAssertEqualSchemas(t, match.expected, schema, undefined);
          } else {
            throw e;
          }
        }
        t.fail("Unexpected result.");
      }));

Ava("Fails to parse nested", (function (t) {
        var schema = S.list(S.string);
        U.assertThrows(t, (function () {
                return S.parseOrThrow(nestedInvalidAny, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.string,
                received: 1
              },
              path: S.Path.fromArray(["1"])
            });
      }));

Ava("Successfully serializes", (function (t) {
        var schema = S.list(S.string);
        t.deepEqual(S.reverseConvertOrThrow(value, schema), any, undefined);
      }));

var CommonWithNested = {
  value: value,
  any: any,
  invalidAny: invalidAny,
  nestedInvalidAny: nestedInvalidAny,
  factory: factory
};

Ava("Successfully parses list of optional items", (function (t) {
        var schema = S.list(S.option(S.string));
        t.deepEqual(S.parseOrThrow(["a", undefined, undefined, "b"], schema), {
              hd: "a",
              tl: {
                hd: undefined,
                tl: {
                  hd: undefined,
                  tl: {
                    hd: "b",
                    tl: /* [] */0
                  }
                }
              }
            }, undefined);
      }));

export {
  CommonWithNested ,
}
/*  Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import Ava from "ava";

Ava("Uses default value when parsing optional unknown primitive", (function (t) {
        var any = undefined;
        var schema = S.$$Option.getOrWith(S.option(S.$$float), (function () {
                return 123;
              }));
        t.deepEqual(S.parseOrThrow(any, schema), 123, undefined);
      }));

Ava("Uses default value when nullable optional unknown primitive", (function (t) {
        var any = null;
        var schema = S.$$Option.getOrWith(S.$$null(S.$$float), (function () {
                return 123;
              }));
        t.deepEqual(S.parseOrThrow(any, schema), 123, undefined);
      }));

Ava("Successfully parses with default when provided JS undefined", (function (t) {
        var schema = S.$$Option.getOrWith(S.option(S.bool), (function () {
                return false;
              }));
        t.deepEqual(S.parseOrThrow(undefined, schema), false, undefined);
      }));

Ava("Successfully parses with default when provided primitive", (function (t) {
        var schema = S.$$Option.getOrWith(S.option(S.bool), (function () {
                return false;
              }));
        t.deepEqual(S.parseOrThrow(true, schema), true, undefined);
      }));

Ava("Successfully parses nested option with default value", (function (t) {
        var schema = S.$$Option.getOrWith(S.option(S.option(S.bool)), (function () {
                return true;
              }));
        t.deepEqual(S.parseOrThrow(undefined, schema), true, undefined);
      }));

Ava("Fails to parse data with default", (function (t) {
        var schema = S.$$Option.getOrWith(S.option(S.bool), (function () {
                return false;
              }));
        U.assertThrows(t, (function () {
                return S.parseOrThrow("string", schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: schema,
                received: "string"
              },
              path: S.Path.empty
            });
      }));

Ava("Successfully serializes schema with transformation", (function (t) {
        var schema = S.$$Option.getOrWith(S.option(S.trim(S.string)), (function () {
                return "default";
              }));
        t.deepEqual(S.reverseConvertOrThrow(" abc", schema), "abc", undefined);
      }));

Ava("Compiled parse code snapshot", (function (t) {
        var schema = S.$$Option.getOrWith(S.option(S.bool), (function () {
                return false;
              }));
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(!(typeof i===\"boolean\"||i===void 0)){e[0](i)}return i===void 0?e[1]():i}", undefined);
      }));

Ava("Compiled async parse code snapshot", (function (t) {
        var schema = S.$$Option.getOrWith(S.option(S.transform(S.bool, (function (param) {
                        return {
                                a: (function (i) {
                                    return Promise.resolve(i);
                                  })
                              };
                      }))), (function () {
                return false;
              }));
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i===\"boolean\"){i=e[0](i)}else if(!(i===void 0)){e[1](i)}return Promise.resolve(i).then(v0=>{return v0===void 0?e[2]():v0})}", undefined);
      }));

Ava("Compiled serialize code snapshot", (function (t) {
        var schema = S.$$Option.getOrWith(S.option(S.bool), (function () {
                return false;
              }));
        U.assertCompiledCodeIsNoop(t, schema, "ReverseConvert", undefined);
      }));

export {
  
}
/*  Not a pure module */

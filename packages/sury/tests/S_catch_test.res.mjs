// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import Ava from "ava";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

Ava("Doesn't affect valid parsing", (function (t) {
        var schema = S.$$catch(S.string, (function (param) {
                return "fallback";
              }));
        t.deepEqual(S.parseOrThrow("abc", schema), "abc", undefined);
      }));

Ava("Doesn't do anything with unknown schema", (function (t) {
        var schema = S.$$catch(S.unknown, (function (param) {
                return "fallback";
              }));
        t.deepEqual(S.parseOrThrow("abc", schema), "abc", undefined);
      }));

Ava("Uses fallback value when parsing failed", (function (t) {
        var schema = S.$$catch(S.string, (function (param) {
                return "fallback";
              }));
        t.deepEqual(S.parseOrThrow(123, schema), "fallback", undefined);
      }));

Ava("Doesn't affect serializing in any way", (function (t) {
        var schema = S.$$catch(S.port(S.$$int, undefined), (function (param) {
                return 8080;
              }));
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow(-1, schema);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "InvalidOperation",
                description: "Invalid port"
              },
              path: S.Path.empty
            });
      }));

Ava("Provides ctx to use in catch", (function (t) {
        t.plan(3);
        var schema = S.$$catch(S.string, (function (s) {
                t.deepEqual(s.e, U.error({
                          operation: "Parse",
                          code: {
                            TAG: "InvalidType",
                            expected: S.string,
                            received: 123
                          },
                          path: S.Path.empty
                        }), undefined);
                t.deepEqual(s.i, 123, undefined);
                return "fallback";
              }));
        t.deepEqual(S.parseOrThrow(123, schema), "fallback", undefined);
      }));

Ava("Can use s.fail inside of S.catch", (function (t) {
        var schema = S.$$catch(S.port(S.$$int, undefined), (function (s) {
                try {
                  S.parseOrThrow(s.i, S.string);
                  return 8080;
                }
                catch (raw_exn){
                  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn.RE_EXN_ID === S.$$Error) {
                    return s.f("Fallback value only supported for strings.", undefined);
                  }
                  throw exn;
                }
              }));
        t.deepEqual(S.parseOrThrow(3000, schema), 3000, undefined);
        t.deepEqual(S.parseOrThrow("3000", schema), 8080, undefined);
        U.assertThrows(t, (function () {
                return S.parseOrThrow(true, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "OperationFailed",
                _0: "Fallback value only supported for strings."
              },
              path: S.Path.empty
            });
        t.deepEqual(S.reverseConvertOrThrow(3000, schema), 3000, undefined);
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow(-1, schema);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "InvalidOperation",
                description: "Invalid port"
              },
              path: S.Path.empty
            });
      }));

Ava("Uses fallback value when async schema parsing failed during the sync part", (async function (t) {
        var schema = S.$$catch(S.transform(S.string, (function (param) {
                    return {
                            a: (function (i) {
                                return Promise.resolve(i);
                              })
                          };
                  })), (function (param) {
                return "fallback";
              }));
        t.deepEqual(await S.parseAsyncOrThrow(123, schema), "fallback", undefined);
      }));

Ava("Uses fallback value when async schema parsing failed during the async part", (async function (t) {
        var schema = S.$$catch(S.transform(S.string, (function (s) {
                    return {
                            a: (function (param) {
                                return s.fail("foo", undefined);
                              })
                          };
                  })), (function (param) {
                return "fallback";
              }));
        t.deepEqual(await S.parseAsyncOrThrow("123", schema), "fallback", undefined);
      }));

Ava("Uses fallback value when async schema parsing failed during the async part in promise", (async function (t) {
        var schema = S.$$catch(S.transform(S.string, (function (s) {
                    return {
                            a: (function (param) {
                                return Promise.resolve().then(function () {
                                            return s.fail("fail", undefined);
                                          });
                              })
                          };
                  })), (function (param) {
                return "fallback";
              }));
        t.deepEqual(await S.parseAsyncOrThrow("123", schema), "fallback", undefined);
      }));

Ava("Compiled parse code snapshot", (function (t) {
        var schema = S.$$catch(S.bool, (function (param) {
                return false;
              }));
        U.assertCompiledCode(t, schema, "Parse", "i=>{try{if(typeof i!==\"boolean\"){e[1](i)}}catch(v0){if(v0&&v0.s===s){i=e[0](i,v0)}else{throw v0}}return i}", undefined);
      }));

Ava("Compiled async parse code snapshot", (function (t) {
        var schema = S.$$catch(S.transform(S.bool, (function (param) {
                    return {
                            a: (function (i) {
                                return Promise.resolve(i);
                              })
                          };
                  })), (function (param) {
                return false;
              }));
        U.assertCompiledCode(t, schema, "Parse", "i=>{let v1;try{if(typeof i!==\"boolean\"){e[1](i)}v1=e[2](i).catch(v0=>{if(v0&&v0.s===s){return e[0](i,v0)}else{throw v0}})}catch(v0){if(v0&&v0.s===s){v1=Promise.resolve(e[0](i,v0))}else{throw v0}}return v1}", undefined);
      }));

Ava("Compiled serialize code snapshot", (function (t) {
        var schema = S.$$catch(S.bool, (function (param) {
                return false;
              }));
        U.assertCompiledCodeIsNoop(t, schema, "ReverseConvert", undefined);
      }));

export {
  
}
/*  Not a pure module */

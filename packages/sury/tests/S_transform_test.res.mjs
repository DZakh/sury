// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import Ava from "ava";
import * as Js_exn from "rescript/lib/es6/js_exn.js";

Ava("Parses unknown primitive with transformation to the same type", (function (t) {
        var schema = S.transform(S.string, (function (param) {
                return {
                        p: (function (value) {
                            return value.trim();
                          })
                      };
              }));
        t.deepEqual(S.parseOrThrow("  Hello world!", schema), "Hello world!", undefined);
      }));

Ava("Parses unknown primitive with transformation to another type", (function (t) {
        var schema = S.transform(S.$$int, (function (param) {
                return {
                        p: (function (value) {
                            return value;
                          })
                      };
              }));
        t.deepEqual(S.parseOrThrow(123, schema), 123, undefined);
      }));

Ava("Asynchronously parses unknown primitive with transformation to another type", (async function (t) {
        var schema = S.transform(S.$$int, (function (param) {
                return {
                        a: (function (value) {
                            return Promise.resolve().then(function () {
                                        return value;
                                      });
                          })
                      };
              }));
        t.deepEqual(await S.parseAsyncOrThrow(123, schema), 123, undefined);
      }));

Ava("Fails to parse primitive with transform when parser isn't provided", (function (t) {
        var schema = S.transform(S.string, (function (param) {
                return {
                        s: (function (value) {
                            return value;
                          })
                      };
              }));
        U.assertThrows(t, (function () {
                return S.parseOrThrow("Hello world!", schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidOperation",
                description: "The S.transform parser is missing"
              },
              path: S.Path.empty
            });
      }));

Ava("Fails to parse when user raises error in a Transformed Primitive parser", (function (t) {
        var schema = S.transform(S.string, (function (s) {
                return {
                        p: (function (param) {
                            return s.fail("User error", undefined);
                          })
                      };
              }));
        U.assertThrows(t, (function () {
                return S.parseOrThrow("Hello world!", schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "OperationFailed",
                _0: "User error"
              },
              path: S.Path.empty
            });
      }));

Ava("Uses the path from S.Error.raise called in the transform parser", (function (t) {
        var schema = S.array(S.transform(S.string, (function (param) {
                    return {
                            p: (function (param) {
                                return U.raiseError(U.error({
                                                operation: "Parse",
                                                code: {
                                                  TAG: "OperationFailed",
                                                  _0: "User error"
                                                },
                                                path: S.Path.fromArray([
                                                      "a",
                                                      "b"
                                                    ])
                                              }));
                              })
                          };
                  })));
        U.assertThrows(t, (function () {
                return S.parseOrThrow(["Hello world!"], schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "OperationFailed",
                _0: "User error"
              },
              path: S.Path.fromArray([
                    "0",
                    "a",
                    "b"
                  ])
            });
      }));

Ava("Uses the path from S.Error.raise called in the transform serializer", (function (t) {
        var schema = S.array(S.transform(S.string, (function (param) {
                    return {
                            s: (function (param) {
                                return U.raiseError(U.error({
                                                operation: "ReverseConvert",
                                                code: {
                                                  TAG: "OperationFailed",
                                                  _0: "User error"
                                                },
                                                path: S.Path.fromArray([
                                                      "a",
                                                      "b"
                                                    ])
                                              }));
                              })
                          };
                  })));
        U.assertThrows(t, (function () {
                return S.reverseConvertToJsonOrThrow(["Hello world!"], schema);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "OperationFailed",
                _0: "User error"
              },
              path: S.Path.fromArray([
                    "0",
                    "a",
                    "b"
                  ])
            });
      }));

Ava("Transform parser passes through non rescript-schema errors", (function (t) {
        var schema = S.array(S.transform(S.string, (function (param) {
                    return {
                            p: (function (param) {
                                return Js_exn.raiseError("Application crashed");
                              })
                          };
                  })));
        t.throws((function () {
                return S.parseOrThrow(["Hello world!"], schema);
              }), {
              message: "Application crashed"
            }, undefined);
      }));

Ava("Transform parser passes through other rescript exceptions", (function (t) {
        var schema = S.array(S.transform(S.string, (function (param) {
                    return {
                            p: (function (param) {
                                return U.raiseTestException();
                              })
                          };
                  })));
        U.assertThrowsTestException(t, (function () {
                return S.parseOrThrow(["Hello world!"], schema);
              }), undefined, undefined);
      }));

Ava("Transform definition passes through non rescript-schema errors", (function (t) {
        var schema = S.array(S.transform(S.string, (function (param) {
                    return Js_exn.raiseError("Application crashed");
                  })));
        t.throws((function () {
                return S.parseOrThrow(["Hello world!"], schema);
              }), {
              message: "Application crashed"
            }, undefined);
      }));

Ava("Transform definition passes through other rescript exceptions", (function (t) {
        var schema = S.array(S.transform(S.string, (function (param) {
                    return U.raiseTestException();
                  })));
        U.assertThrowsTestException(t, (function () {
                return S.parseOrThrow(["Hello world!"], schema);
              }), undefined, undefined);
      }));

Ava("Successfully serializes primitive with transformation to the same type", (function (t) {
        var schema = S.transform(S.string, (function (param) {
                return {
                        s: (function (value) {
                            return value.trim();
                          })
                      };
              }));
        t.deepEqual(S.reverseConvertOrThrow("  Hello world!", schema), "Hello world!", undefined);
      }));

Ava("Successfully serializes primitive with transformation to another type", (function (t) {
        var schema = S.transform(S.$$float, (function (param) {
                return {
                        s: (function (value) {
                            return value;
                          })
                      };
              }));
        t.deepEqual(S.reverseConvertOrThrow(123, schema), 123, undefined);
      }));

Ava("Transformed Primitive serializing fails when serializer isn't provided", (function (t) {
        var schema = S.transform(S.string, (function (param) {
                return {
                        p: (function (value) {
                            return value;
                          })
                      };
              }));
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow("Hello world!", schema);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "InvalidOperation",
                description: "The S.transform serializer is missing"
              },
              path: S.Path.empty
            });
      }));

Ava("Fails to serialize when user raises error in a Transformed Primitive serializer", (function (t) {
        var schema = S.transform(S.string, (function (s) {
                return {
                        s: (function (param) {
                            return s.fail("User error", undefined);
                          })
                      };
              }));
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow("Hello world!", schema);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "OperationFailed",
                _0: "User error"
              },
              path: S.Path.empty
            });
      }));

Ava("Transform operations applyed in the right order when parsing", (function (t) {
        var schema = S.transform(S.transform(S.$$int, (function (s) {
                    return {
                            p: (function (param) {
                                return s.fail("First transform", undefined);
                              })
                          };
                  })), (function (s) {
                return {
                        p: (function (param) {
                            return s.fail("Second transform", undefined);
                          })
                      };
              }));
        U.assertThrows(t, (function () {
                return S.parseOrThrow(123, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "OperationFailed",
                _0: "First transform"
              },
              path: S.Path.empty
            });
      }));

Ava("Transform operations applyed in the right order when serializing", (function (t) {
        var schema = S.transform(S.transform(S.$$int, (function (s) {
                    return {
                            s: (function (param) {
                                return s.fail("First transform", undefined);
                              })
                          };
                  })), (function (s) {
                return {
                        s: (function (param) {
                            return s.fail("Second transform", undefined);
                          })
                      };
              }));
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow(123, schema);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "OperationFailed",
                _0: "Second transform"
              },
              path: S.Path.empty
            });
      }));

Ava("Successfully parses a Transformed Primitive and serializes it back to the initial state", (function (t) {
        var any = 123;
        var schema = S.transform(S.$$int, (function (param) {
                return {
                        p: (function ($$int) {
                            return $$int;
                          }),
                        s: (function (value) {
                            return value | 0;
                          })
                      };
              }));
        t.deepEqual(S.reverseConvertOrThrow(S.parseOrThrow(any, schema), schema), any, undefined);
      }));

Ava("Fails to parse schema with transform having both parser and asyncParser", (function (t) {
        var schema = S.transform(S.string, (function (param) {
                return {
                        p: (function (param) {
                            
                          }),
                        a: (function (param) {
                            return Promise.resolve();
                          })
                      };
              }));
        U.assertThrows(t, (function () {
                S.parseOrThrow("foo", schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidOperation",
                description: "The S.transform doesn\'t allow parser and asyncParser at the same time. Remove parser in favor of asyncParser"
              },
              path: S.Path.empty
            });
      }));

Ava("Fails to parse async using parseOrThrow", (function (t) {
        var schema = S.transform(S.string, (function (param) {
                return {
                        a: (function (value) {
                            return Promise.resolve(value);
                          })
                      };
              }));
        U.assertThrows(t, (function () {
                return S.parseOrThrow("Hello world!", schema);
              }), {
              operation: "Parse",
              code: "UnexpectedAsync",
              path: S.Path.empty
            });
      }));

Ava("Successfully parses with empty transform", (function (t) {
        var schema = S.transform(S.string, (function (param) {
                return {};
              }));
        t.deepEqual(S.parseOrThrow("Hello world!", schema), "Hello world!", undefined);
      }));

Ava("Successfully serializes with empty transform", (function (t) {
        var schema = S.transform(S.string, (function (param) {
                return {};
              }));
        t.deepEqual(S.reverseConvertOrThrow("Hello world!", schema), "Hello world!", undefined);
      }));

Ava("Successfully parses async using parseAsyncOrThrow", (function (t) {
        var schema = S.transform(S.string, (function (param) {
                return {
                        a: (function (value) {
                            return Promise.resolve(value);
                          })
                      };
              }));
        return S.parseAsyncOrThrow("Hello world!", schema).then(function (result) {
                    t.deepEqual(result, "Hello world!", undefined);
                  });
      }));

Ava("Fails to parse async with user error", (function (t) {
        var schema = S.transform(S.string, (function (s) {
                return {
                        a: (function (param) {
                            return s.fail("User error", undefined);
                          })
                      };
              }));
        return U.assertThrowsAsync(t, (function () {
                      return S.parseAsyncOrThrow("Hello world!", schema);
                    }), {
                    operation: "ParseAsync",
                    code: {
                      TAG: "OperationFailed",
                      _0: "User error"
                    },
                    path: S.Path.empty
                  });
      }));

Ava("Can apply other actions after async transform", (function (t) {
        var schema = S.transform(S.trim(S.transform(S.string, (function (param) {
                        return {
                                a: (function (value) {
                                    return Promise.resolve(value);
                                  })
                              };
                      }))), (function (param) {
                return {
                        a: (function (value) {
                            return Promise.resolve(value);
                          })
                      };
              }));
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"string\"){e[3](i)}return e[0](i).then(e[1]).then(e[2])}", undefined);
        return S.parseAsyncOrThrow("    Hello world!", schema).then(function (result) {
                    t.deepEqual(result, "Hello world!", undefined);
                  });
      }));

Ava("Compiled parse code snapshot", (function (t) {
        var schema = S.transform(S.$$int, (function (param) {
                return {
                        p: (function ($$int) {
                            return $$int;
                          }),
                        s: (function (value) {
                            return value | 0;
                          })
                      };
              }));
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"number\"||i>2147483647||i<-2147483648||i%1!==0){e[1](i)}return e[0](i)}", undefined);
      }));

Ava("Compiled async parse code snapshot", (function (t) {
        var schema = S.transform(S.$$int, (function (param) {
                return {
                        a: (function ($$int) {
                            return Promise.resolve($$int);
                          }),
                        s: (function (value) {
                            return value | 0;
                          })
                      };
              }));
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"number\"||i>2147483647||i<-2147483648||i%1!==0){e[1](i)}return e[0](i)}", undefined);
      }));

Ava("Compiled serialize code snapshot", (function (t) {
        var schema = S.transform(S.$$int, (function (param) {
                return {
                        p: (function ($$int) {
                            return $$int;
                          }),
                        s: (function (value) {
                            return value | 0;
                          })
                      };
              }));
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return e[0](i)}", undefined);
      }));

Ava("Reverse schema to the original schema", (function (t) {
        var schema = S.transform(S.$$int, (function (param) {
                return {
                        p: (function ($$int) {
                            return $$int;
                          }),
                        s: (function (value) {
                            return value | 0;
                          })
                      };
              }));
        U.assertEqualSchemas(t, S.reverse(schema), S.unknown, undefined);
      }));

Ava("Succesfully uses reversed schema for parsing back to initial value", (function (t) {
        var schema = S.transform(S.$$int, (function (param) {
                return {
                        p: (function ($$int) {
                            return $$int;
                          }),
                        s: (function (value) {
                            return value | 0;
                          })
                      };
              }));
        U.assertReverseParsesBack(t, schema, 12);
      }));

export {
  
}
/*  Not a pure module */

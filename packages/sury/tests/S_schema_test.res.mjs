// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import Ava from "ava";

Ava("Literal schema", (function (t) {
        U.assertEqualSchemas(t, S.schema(function (param) {
                  return 1;
                }), S.literal(1), undefined);
        U.assertEqualSchemas(t, S.schema(function (param) {
                  
                }), S.literal(), undefined);
        U.assertEqualSchemas(t, S.schema(function (param) {
                  return "foo";
                }), S.literal("foo"), undefined);
      }));

Ava("Object of literals schema", (function (t) {
        U.assertEqualSchemas(t, S.schema(function (param) {
                  return {
                          foo: "bar",
                          zoo: 123
                        };
                }), S.object(function (s) {
                  return {
                          foo: s.f("foo", S.literal("bar")),
                          zoo: s.f("zoo", S.literal(123))
                        };
                }), undefined);
      }));

Ava("Tuple of literals schema", (function (t) {
        U.assertEqualSchemas(t, S.schema(function (param) {
                  return [
                          1,
                          undefined,
                          "bar"
                        ];
                }), S.tuple3(S.literal(1), S.literal(), S.literal("bar")), undefined);
      }));

Ava("Object with embeded schema", (function (t) {
        var schema = S.schema(function (s) {
              return {
                      foo: "bar",
                      zoo: s.m(S.$$int)
                    };
            });
        var objectSchema = S.object(function (s) {
              return {
                      foo: s.f("foo", S.literal("bar")),
                      zoo: s.f("zoo", S.$$int)
                    };
            });
        U.assertEqualSchemas(t, schema, objectSchema, undefined);
        t.is(U.getCompiledCodeString(schema, "Parse"), U.getCompiledCodeString(objectSchema, "Parse"), undefined);
        t.is(U.getCompiledCodeString(schema, "ReverseConvert"), "i=>{let v0=i[\"foo\"];if(v0!==\"bar\"){e[0](v0)}return i}", undefined);
        t.is(U.getCompiledCodeString(objectSchema, "ReverseConvert"), "i=>{let v0=i[\"foo\"];if(v0!==\"bar\"){e[0](v0)}return {\"foo\":v0,\"zoo\":i[\"zoo\"],}}", undefined);
      }));

Ava("Object with embeded transformed schema", (function (t) {
        var schema = S.schema(function (s) {
              return {
                      foo: "bar",
                      zoo: s.m(S.$$null(S.$$int))
                    };
            });
        var objectSchema = S.object(function (s) {
              return {
                      foo: s.f("foo", S.literal("bar")),
                      zoo: s.f("zoo", S.$$null(S.$$int))
                    };
            });
        U.assertEqualSchemas(t, schema, objectSchema, undefined);
        t.is(U.getCompiledCodeString(schema, "Parse"), U.getCompiledCodeString(objectSchema, "Parse"), undefined);
        t.is(U.getCompiledCodeString(schema, "ReverseConvert"), "i=>{let v0=i[\"foo\"],v1=i[\"zoo\"];if(v0!==\"bar\"){e[0](v0)}if(v1===void 0){v1=null}return {\"foo\":v0,\"zoo\":v1,}}", undefined);
        t.is(U.getCompiledCodeString(schema, "ReverseConvert"), U.getCompiledCodeString(objectSchema, "ReverseConvert"), undefined);
      }));

Ava("Strict object with embeded returns input without object recreation", (function (t) {
        S.setGlobalConfig({
              defaultAdditionalItems: "strict"
            });
        var schema = S.schema(function (s) {
              return {
                      foo: "bar",
                      zoo: s.m(S.$$int)
                    };
            });
        S.setGlobalConfig({});
        t.is(U.getCompiledCodeString(schema, "Parse"), "i=>{if(typeof i!==\"object\"||!i||Array.isArray(i)||i[\"foo\"]!==\"bar\"){e[2](i)}let v0=i[\"zoo\"],v1;if(typeof v0!==\"number\"||v0>2147483647||v0<-2147483648||v0%1!==0){e[0](v0)}for(v1 in i){if(v1!==\"foo\"&&v1!==\"zoo\"){e[1](v1)}}return i}", undefined);
        t.is(U.getCompiledCodeString(schema, "ReverseConvert"), "i=>{let v0=i[\"foo\"];if(v0!==\"bar\"){e[0](v0)}return i}", undefined);
      }));

Ava("Tuple with embeded schema", (function (t) {
        var schema = S.schema(function (s) {
              return [
                      s.m(S.string),
                      undefined,
                      "bar"
                    ];
            });
        var tupleSchema = S.tuple(function (s) {
              return [
                      s.item(0, S.string),
                      s.item(1, S.literal()),
                      s.item(2, S.literal("bar"))
                    ];
            });
        U.assertEqualSchemas(t, schema, tupleSchema, undefined);
        t.is(U.getCompiledCodeString(schema, "Parse"), "i=>{if(!Array.isArray(i)||i.length!==3||i[\"1\"]!==void 0||i[\"2\"]!==\"bar\"){e[1](i)}let v0=i[\"0\"];if(typeof v0!==\"string\"){e[0](v0)}return i}", undefined);
        t.is(U.getCompiledCodeString(tupleSchema, "Parse"), "i=>{if(!Array.isArray(i)||i.length!==3||i[\"1\"]!==void 0||i[\"2\"]!==\"bar\"){e[1](i)}let v0=i[\"0\"];if(typeof v0!==\"string\"){e[0](v0)}return [v0,i[\"1\"],i[\"2\"],]}", undefined);
        t.is(U.getCompiledCodeString(schema, "ReverseConvert"), "i=>{let v0=i[\"1\"],v1=i[\"2\"];if(v0!==void 0){e[0](v0)}if(v1!==\"bar\"){e[1](v1)}return i}", undefined);
        t.is(U.getCompiledCodeString(tupleSchema, "ReverseConvert"), "i=>{let v0=i[\"1\"],v1=i[\"2\"];if(v0!==void 0){e[0](v0)}if(v1!==\"bar\"){e[1](v1)}return [i[\"0\"],v0,v1,]}", undefined);
      }));

Ava("Tuple with embeded transformed schema", (function (t) {
        var schema = S.schema(function (s) {
              return [
                      s.m(S.$$null(S.string)),
                      undefined,
                      "bar"
                    ];
            });
        var tupleSchema = S.tuple(function (s) {
              return [
                      s.item(0, S.$$null(S.string)),
                      s.item(1, S.literal()),
                      s.item(2, S.literal("bar"))
                    ];
            });
        U.assertEqualSchemas(t, schema, tupleSchema, undefined);
        t.is(U.getCompiledCodeString(schema, "Parse"), U.getCompiledCodeString(tupleSchema, "Parse"), undefined);
        t.is(U.getCompiledCodeString(schema, "ReverseConvert"), "i=>{let v0=i[\"0\"],v1=i[\"1\"],v2=i[\"2\"];if(v0===void 0){v0=null}if(v1!==void 0){e[0](v1)}if(v2!==\"bar\"){e[1](v2)}return [v0,v1,v2,]}", undefined);
        t.is(U.getCompiledCodeString(schema, "ReverseConvert"), U.getCompiledCodeString(tupleSchema, "ReverseConvert"), undefined);
      }));

Ava("Nested object with embeded schema", (function (t) {
        var schema = S.schema(function (s) {
              return {
                      nested: {
                        foo: "bar",
                        zoo: s.m(S.$$int)
                      }
                    };
            });
        var objectSchema = S.object(function (s) {
              return {
                      nested: s.f("nested", S.object(function (s) {
                                return {
                                        foo: s.f("foo", S.literal("bar")),
                                        zoo: s.f("zoo", S.$$int)
                                      };
                              }))
                    };
            });
        U.assertEqualSchemas(t, schema, objectSchema, undefined);
        t.is(U.getCompiledCodeString(schema, "Parse"), U.getCompiledCodeString(objectSchema, "Parse"), undefined);
        t.is(U.getCompiledCodeString(schema, "ReverseConvert"), "i=>{let v0=i[\"nested\"];let v1=v0[\"foo\"];if(v1!==\"bar\"){e[0](v1)}return i}", undefined);
        t.is(U.getCompiledCodeString(objectSchema, "ReverseConvert"), "i=>{let v0=i[\"nested\"],v1=v0[\"foo\"];if(v1!==\"bar\"){e[0](v1)}return {\"nested\":{\"foo\":v1,\"zoo\":v0[\"zoo\"],},}}", undefined);
      }));

Ava("Example", (function (t) {
        U.assertEqualSchemas(t, S.schema(function (s) {
                  return s.m(S.string);
                }), S.shape(S.string, (function (string) {
                    return string;
                  })), undefined);
        U.assertEqualSchemas(t, S.schema(function (s) {
                  return s.m(S.array(S.string));
                }), S.shape(S.array(S.string), (function (array) {
                    return array;
                  })), undefined);
        U.assertEqualSchemas(t, S.schema(function (s) {
                  return {
                          value: s.m(S.string),
                          description: s.m(S.option(S.string))
                        };
                }), S.object(function (s) {
                  return {
                          value: s.f("value", S.string),
                          description: s.f("description", S.option(S.string))
                        };
                }), undefined);
        U.assertEqualSchemas(t, S.schema(function (s) {
                  return [
                          "id",
                          s.m(S.string)
                        ];
                }), S.tuple(function (s) {
                  return [
                          s.item(0, S.literal("id")),
                          s.item(1, S.string)
                        ];
                }), undefined);
      }));

Ava("Strict object schema should also check that object is not Array. Otherwise it will incorrectly return array input", (function (t) {
        var schema = S.schema(function (s) {
              return {
                      "0": s.m(S.string),
                      "1": s.m(S.bool)
                    };
            });
        t.deepEqual(S.parseOrThrow(["foo", true], schema), {
              "0": "foo",
              "1": true
            }, undefined);
        U.assertThrows(t, (function () {
                return S.parseOrThrow(["foo", true], S.strict(schema));
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.strict(schema),
                received: ["foo", true]
              },
              path: S.Path.empty
            });
      }));

Ava("Strict tuple schema should check the exact number of items, but it can optimize input recreation", (function (t) {
        var schema = S.strict(S.schema(function (s) {
                  return [
                          s.m(S.string),
                          s.m(S.bool)
                        ];
                }));
        t.deepEqual(S.parseOrThrow(["foo", true], schema), [
              "foo",
              true
            ], undefined);
        U.assertThrows(t, (function () {
                return S.parseOrThrow(["foo", true, 1], schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.strict(schema),
                received: ["foo", true, 1]
              },
              path: S.Path.empty
            });
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(!Array.isArray(i)||i.length!==2){e[2](i)}let v0=i[\"0\"],v1=i[\"1\"];if(typeof v0!==\"string\"){e[0](v0)}if(typeof v1!==\"boolean\"){e[1](v1)}return i}", undefined);
        U.assertCompiledCode(t, schema, "Convert", "i=>{return i}", undefined);
      }));

export {
  
}
/*  Not a pure module */

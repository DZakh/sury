// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import Ava from "ava";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

Ava("Successfully refines on parsing", (function (t) {
        var schema = S.refine(S.$$int, (function (s) {
                return function (value) {
                  if (value < 0) {
                    return s.fail("Should be positive", undefined);
                  }
                  
                };
              }));
        t.deepEqual(S.parseOrThrow(12, schema), 12, undefined);
        U.assertThrows(t, (function () {
                return S.parseOrThrow(-12, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "OperationFailed",
                _0: "Should be positive"
              },
              path: S.Path.empty
            });
      }));

Ava("Fails with custom path", (function (t) {
        var schema = S.refine(S.$$int, (function (s) {
                return function (value) {
                  if (value < 0) {
                    return s.fail("Should be positive", Caml_option.some(S.Path.fromArray([
                                        "data",
                                        "myInt"
                                      ])));
                  }
                  
                };
              }));
        U.assertThrows(t, (function () {
                return S.parseOrThrow(-12, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "OperationFailed",
                _0: "Should be positive"
              },
              path: S.Path.fromArray([
                    "data",
                    "myInt"
                  ])
            });
      }));

Ava("Successfully refines on serializing", (function (t) {
        var schema = S.refine(S.$$int, (function (s) {
                return function (value) {
                  if (value < 0) {
                    return s.fail("Should be positive", undefined);
                  }
                  
                };
              }));
        t.deepEqual(S.reverseConvertOrThrow(12, schema), 12, undefined);
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow(-12, schema);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "OperationFailed",
                _0: "Should be positive"
              },
              path: S.Path.empty
            });
      }));

Ava("Successfully parses simple object with empty refine", (function (t) {
        var schema = S.refine(S.object(function (s) {
                  return {
                          foo: s.f("foo", S.string),
                          bar: s.f("bar", S.bool)
                        };
                }), (function (param) {
                return function (param) {
                  
                };
              }));
        t.deepEqual(S.parseOrThrow({
      "foo": "string",
      "bar": true,
    }, schema), {
              foo: "string",
              bar: true
            }, undefined);
      }));

Ava("Compiled parse code snapshot for simple object with refine", (function (t) {
        var schema = S.refine(S.object(function (s) {
                  return {
                          foo: s.f("foo", S.string),
                          bar: s.f("bar", S.bool)
                        };
                }), (function (s) {
                return function (param) {
                  s.fail("foo", undefined);
                };
              }));
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[3](i)}let v2;let v0=i[\"foo\"],v1=i[\"bar\"];if(typeof v0!==\"string\"){e[0](v0)}if(typeof v1!==\"boolean\"){e[1](v1)}v2={\"foo\":v0,\"bar\":v1,};e[2](v2);return v2}", undefined);
      }));

Ava("Reverse schema to the original schema", (function (t) {
        var schema = S.refine(S.$$int, (function (s) {
                return function (value) {
                  if (value < 0) {
                    return s.fail("Should be positive", undefined);
                  }
                  
                };
              }));
        t.not(S.reverse(schema), schema, undefined);
        U.assertEqualSchemas(t, S.reverse(schema), S.$$int, undefined);
      }));

Ava("Succesfully uses reversed schema for parsing back to initial value", (function (t) {
        var schema = S.refine(S.$$int, (function (s) {
                return function (value) {
                  if (value < 0) {
                    return s.fail("Should be positive", undefined);
                  }
                  
                };
              }));
        U.assertReverseParsesBack(t, schema, 12);
      }));

Ava("Successfully parses", (function (t) {
        var schema = S.refine(S.object(function (s) {
                  return s.f("myField", S.nullish(S.string));
                }), (function (param) {
                return function (param) {
                  
                };
              }));
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[2](i)}let v0=i[\"myField\"];if(!(typeof v0===\"string\"||v0===void 0||v0===null)){e[0](v0)}e[1](v0);return v0}", undefined);
        U.assertCompiledCode(t, schema, "Convert", "i=>{let v1;v1=i[\"myField\"];e[0](v1);return v1}", undefined);
        t.deepEqual(S.parseJsonStringOrThrow("{\"myField\": \"test\"}", schema), "test", undefined);
      }));

var Issue79 = {};

export {
  Issue79 ,
}
/*  Not a pure module */

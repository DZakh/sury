// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as Stdlib_Dict from "rescript/lib/es6/Stdlib_Dict.js";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";
import * as Primitive_exceptions from "rescript/lib/es6/Primitive_exceptions.js";

let noopOpCode = S.compile(S.unknown, "Any", "Input", "Sync", false).toString();

function throwError(error) {
  throw error;
}

function unsafeGetVariantPayload(variant) {
  return variant._0;
}

let Test = /* @__PURE__ */Primitive_exceptions.create("U.Test");

function throwTestException() {
  throw {
    RE_EXN_ID: Test,
    Error: new Error()
  };
}

function error(param) {
  let tmp;
  switch (param.operation) {
    case "Parse" :
      tmp = S.Flag.typeValidation;
      break;
    case "ParseAsync" :
      tmp = S.Flag.typeValidation | S.Flag.async;
      break;
    case "ReverseConvertToJson" :
      tmp = S.Flag.reverse | S.Flag.jsonableOutput;
      break;
    case "ReverseParse" :
      tmp = S.Flag.reverse | S.Flag.typeValidation;
      break;
    case "ReverseConvert" :
      tmp = S.Flag.reverse;
      break;
    case "Assert" :
      tmp = S.Flag.typeValidation | S.Flag.assertOutput;
      break;
  }
  return S.ErrorClass.constructor(param.code, tmp, param.path);
}

function assertThrowsTestException(t, fn, message) {
  try {
    fn();
    return t.fail("Didn't throw");
  } catch (raw_exn) {
    let exn = Primitive_exceptions.internalToException(raw_exn);
    if (exn.RE_EXN_ID === Test) {
      t.pass(message !== undefined ? Primitive_option.valFromOption(message) : undefined);
      return;
    } else {
      return t.fail("Thrown another exception");
    }
  }
}

function assertThrows(t, cb, errorPayload) {
  let any;
  try {
    any = cb();
  } catch (raw_exn) {
    let exn = Primitive_exceptions.internalToException(raw_exn);
    if (exn.RE_EXN_ID === S.$$Error) {
      t.is(exn._1.message, error(errorPayload).message);
      return;
    }
    throw exn;
  }
  t.fail("Asserted result is not Error. Recieved: " + JSON.stringify(any));
}

function assertThrowsMessage(t, cb, errorMessage, message) {
  let any;
  try {
    any = cb();
  } catch (raw_exn) {
    let exn = Primitive_exceptions.internalToException(raw_exn);
    if (exn.RE_EXN_ID === S.$$Error) {
      t.is(exn._1.message, errorMessage, message !== undefined ? Primitive_option.valFromOption(message) : undefined);
      return;
    }
    throw exn;
  }
  t.fail("Asserted result is not S.Error \"" + errorMessage + "\". Instead got: " + JSON.stringify(any));
}

async function assertThrowsAsync(t, cb, errorPayload) {
  let any;
  try {
    any = await cb();
  } catch (raw_exn) {
    let exn = Primitive_exceptions.internalToException(raw_exn);
    if (exn.RE_EXN_ID === S.$$Error) {
      t.is(exn._1.message, error(errorPayload).message);
      return;
    }
    throw exn;
  }
  return t.fail("Asserted result is not Error. Recieved: " + JSON.stringify(any));
}

function getCompiledCodeString(schema, op) {
  let toCode = schema => (
    op === "Parse" || op === "ParseAsync" ? (
        op === "ParseAsync" || S.isAsync(schema) ? S.compile(schema, "Any", "Output", "Async", true) : S.compile(schema, "Any", "Output", "Sync", true)
      ) : (
        op === "ReverseConvertToJson" ? S.compile(schema, "Output", "Json", "Sync", false) : (
            op === "ReverseConvert" ? S.compile(schema, "Output", "Input", "Sync", false) : (
                op === "Convert" ? S.compile(schema, "Any", "Output", "Sync", false) : (
                    op === "Assert" ? S.compile(schema, "Any", "Assert", "Sync", true) : (
                        op === "ReverseParse" ? S.compile(schema, "Output", "Input", "Sync", true) : (
                            op === "ConvertAsync" ? S.compile(schema, "Any", "Output", "Async", false) : S.compile(schema, "Output", "Input", "Async", false)
                          )
                      )
                  )
              )
          )
      )
  ).toString();
  let code = {
    contents: toCode(schema)
  };
  let defs = schema.$defs;
  if (defs !== undefined) {
    Stdlib_Dict.forEachWithKey(defs, (schema, key) => {
      try {
        code.contents = code.contents + "\n" + (key + ": " + toCode(schema));
        return;
      } catch (raw_exn) {
        let exn = Primitive_exceptions.internalToException(raw_exn);
        console.error(exn);
        return;
      }
    });
  }
  return code.contents;
}

function cleanUpSchema(schema) {
  let $$new = {};
  Object.entries(schema).forEach(param => {
    let value = param[1];
    let key = param[0];
    switch (key) {
      case "isAsync" :
      case "k" :
      case "of" :
      case "output" :
      case "p" :
      case "r" :
        return;
      default:
        if (typeof value === "function") {
          return;
        } else {
          if (typeof value === "object" && value !== null) {
            $$new[key] = cleanUpSchema(value);
          } else {
            $$new[key] = value;
          }
          return;
        }
    }
  });
  return $$new;
}

function unsafeAssertEqualSchemas(t, s1, s2, message) {
  t.deepEqual(cleanUpSchema(s1), cleanUpSchema(s2), message !== undefined ? Primitive_option.valFromOption(message) : undefined);
}

function assertCompiledCode(t, schema, op, code, message) {
  t.is(getCompiledCodeString(schema, op), code, message !== undefined ? Primitive_option.valFromOption(message) : undefined);
}

function assertCompiledCodeIsNoop(t, schema, op, message) {
  assertCompiledCode(t, schema, op, noopOpCode, message);
}

function assertReverseParsesBack(t, schema, value) {
  t.deepEqual(S.parseOrThrow(S.reverseConvertOrThrow(value, schema), schema), value);
}

function assertReverseReversesBack(t, schema) {
  unsafeAssertEqualSchemas(t, schema, S.reverse(S.reverse(schema)), undefined);
}

let assertEqualSchemas = unsafeAssertEqualSchemas;

export {
  noopOpCode,
  throwError,
  unsafeGetVariantPayload,
  Test,
  throwTestException,
  error,
  assertThrowsTestException,
  assertThrows,
  assertThrowsMessage,
  assertThrowsAsync,
  getCompiledCodeString,
  cleanUpSchema,
  unsafeAssertEqualSchemas,
  assertCompiledCode,
  assertCompiledCodeIsNoop,
  assertEqualSchemas,
  assertReverseParsesBack,
  assertReverseReversesBack,
}
/* noopOpCode Not a pure module */

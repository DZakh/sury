// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import Ava from "ava";

Ava("Has correct tagged type", (function (t) {
        var schema = S.object(function (s) {
              return {
                      bar: s.flatten(S.object(function (s) {
                                return s.f("bar", S.string);
                              })),
                      foo: s.f("foo", S.string)
                    };
            });
        U.unsafeAssertEqualSchemas(t, schema, S.object(function (s) {
                  return {
                          bar: s.f("bar", S.string),
                          foo: s.f("foo", S.string)
                        };
                }), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[2](i)}let v0=i[\"bar\"],v1=i[\"foo\"];if(typeof v0!==\"string\"){e[0](v0)}if(typeof v1!==\"string\"){e[1](v1)}return {\"bar\":v0,\"foo\":v1,}}", undefined);
      }));

Ava("Can flatten S.schema", (function (t) {
        var schema = S.object(function (s) {
              return {
                      baz: s.flatten(S.schema(function (s) {
                                return {
                                        bar: s.m(S.string)
                                      };
                              })),
                      foo: s.f("foo", S.string)
                    };
            });
        U.unsafeAssertEqualSchemas(t, schema, S.object(function (s) {
                  return {
                          bar: s.f("bar", S.string),
                          foo: s.f("foo", S.string)
                        };
                }), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[2](i)}let v0=i[\"bar\"],v1=i[\"foo\"];if(typeof v0!==\"string\"){e[0](v0)}if(typeof v1!==\"string\"){e[1](v1)}return {\"baz\":{\"bar\":v0,},\"foo\":v1,}}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v0=i[\"baz\"];return {\"bar\":v0[\"bar\"],\"foo\":i[\"foo\"],}}", undefined);
      }));

Ava("Can flatten & destructure S.schema", (function (t) {
        var schema = S.object(function (s) {
              var flattened = s.flatten(S.schema(function (s) {
                        return {
                                bar: s.m(S.string)
                              };
                      }));
              return {
                      bar: flattened.bar,
                      foo: s.f("foo", S.string)
                    };
            });
        U.unsafeAssertEqualSchemas(t, schema, S.object(function (s) {
                  return {
                          bar: s.f("bar", S.string),
                          foo: s.f("foo", S.string)
                        };
                }), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[2](i)}let v0=i[\"bar\"],v1=i[\"foo\"];if(typeof v0!==\"string\"){e[0](v0)}if(typeof v1!==\"string\"){e[1](v1)}return {\"bar\":v0,\"foo\":v1,}}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return {\"bar\":i[\"bar\"],\"foo\":i[\"foo\"],}}", undefined);
      }));

Ava("Can flatten strict object", (function (t) {
        var schema = S.object(function (s) {
              return {
                      bar: s.flatten(S.strict(S.object(function (s) {
                                    return s.f("bar", S.string);
                                  }))),
                      foo: s.f("foo", S.string)
                    };
            });
        var tmp;
        if (schema.type === "object") {
          tmp = schema.additionalItems;
        } else {
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "S_object_flatten_test.res",
                  104,
                  11
                ],
                Error: new Error()
              };
        }
        t.deepEqual(tmp, "strip", undefined);
        U.unsafeAssertEqualSchemas(t, schema, S.object(function (s) {
                  return {
                          bar: s.f("bar", S.string),
                          foo: s.f("foo", S.string)
                        };
                }), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[2](i)}let v0=i[\"bar\"],v1=i[\"foo\"];if(typeof v0!==\"string\"){e[0](v0)}if(typeof v1!==\"string\"){e[1](v1)}return {\"bar\":v0,\"foo\":v1,}}", undefined);
      }));

Ava("Flatten inside of a strict object", (function (t) {
        var schema = S.strict(S.object(function (s) {
                  return {
                          bar: s.flatten(S.object(function (s) {
                                    return s.f("bar", S.string);
                                  })),
                          foo: s.f("foo", S.string)
                        };
                }));
        U.unsafeAssertEqualSchemas(t, schema, S.strict(S.object(function (s) {
                      return {
                              bar: s.f("bar", S.string),
                              foo: s.f("foo", S.string)
                            };
                    })), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i||Array.isArray(i)){e[3](i)}let v0=i[\"bar\"],v1=i[\"foo\"],v2;if(typeof v0!==\"string\"){e[0](v0)}if(typeof v1!==\"string\"){e[1](v1)}for(v2 in i){if(v2!==\"bar\"&&v2!==\"foo\"){e[2](v2)}}return {\"bar\":v0,\"foo\":v1,}}", undefined);
      }));

Ava("Flatten schema with duplicated field of the same type (flatten first)", (function (t) {
        t.throws((function () {
                return S.object(function (s) {
                            return {
                                    bar: s.flatten(S.object(function (s) {
                                              return s.f("foo", S.string);
                                            })),
                                    foo: s.f("foo", S.string)
                                  };
                          });
              }), {
              message: "[Schema] The field \"foo\" defined twice with incompatible schemas"
            }, undefined);
      }));

Ava("Flatten schema with duplicated field of the same type (flatten last)", (function (t) {
        var schema = S.object(function (s) {
              return {
                      foo: s.f("foo", S.string),
                      bar: s.flatten(S.object(function (s) {
                                return s.f("foo", S.string);
                              }))
                    };
            });
        U.unsafeAssertEqualSchemas(t, schema, S.object(function (s) {
                  return {
                          foo: s.f("foo", S.string)
                        };
                }), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[1](i)}let v0=i[\"foo\"];if(typeof v0!==\"string\"){e[0](v0)}return {\"foo\":v0,\"bar\":v0,}}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return {\"foo\":i[\"bar\"],}}", undefined);
      }));

Ava("Flatten schema with duplicated field of different type", (function (t) {
        t.throws((function () {
                return S.object(function (s) {
                            return {
                                    bar: s.flatten(S.object(function (s) {
                                              return s.f("foo", S.string);
                                            })),
                                    foo: s.f("foo", S.email(S.string, undefined))
                                  };
                          });
              }), {
              message: "[Schema] The field \"foo\" defined twice with incompatible schemas"
            }, undefined);
      }));

Ava("Can flatten renamed object schema", (function (t) {
        var schema = S.object(function (s) {
              return {
                      bar: s.flatten(S.meta(S.object(function (s) {
                                    return s.f("bar", S.string);
                                  }), {
                                name: "My Obj"
                              })),
                      foo: s.f("foo", S.string)
                    };
            });
        U.unsafeAssertEqualSchemas(t, schema, S.object(function (s) {
                  return {
                          bar: s.f("bar", S.string),
                          foo: s.f("foo", S.string)
                        };
                }), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[2](i)}let v0=i[\"bar\"],v1=i[\"foo\"];if(typeof v0!==\"string\"){e[0](v0)}if(typeof v1!==\"string\"){e[1](v1)}return {\"bar\":v0,\"foo\":v1,}}", undefined);
        t.is(S.toExpression(schema), "{ bar: string; foo: string; }", undefined);
      }));

Ava("Can flatten transformed object schema", (function (t) {
        var schema = S.object(function (s) {
              return {
                      bar: s.flatten(S.transform(S.object(function (s) {
                                    return s.f("bar", S.string);
                                  }), (function (param) {
                                  return {
                                          p: (function (i) {
                                              return i;
                                            })
                                        };
                                }))),
                      foo: s.f("foo", S.string)
                    };
            });
        U.unsafeAssertEqualSchemas(t, schema, S.object(function (s) {
                  return {
                          bar: s.f("bar", S.string),
                          foo: s.f("foo", S.string)
                        };
                }), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[3](i)}let v0=i[\"bar\"],v1=i[\"foo\"];if(typeof v0!==\"string\"){e[0](v0)}if(typeof v1!==\"string\"){e[1](v1)}return {\"bar\":e[2](v0),\"foo\":v1,}}", undefined);
      }));

Ava("Fails to flatten non-object schema", (function (t) {
        t.throws((function () {
                return S.object(function (s) {
                            return {
                                    foo: s.f("foo", S.string),
                                    bar: s.flatten(S.string)
                                  };
                          });
              }), {
              message: "[Schema] The 'string' schema can\'t be flattened"
            }, undefined);
      }));

Ava("Successfully serializes simple object with flatten", (function (t) {
        var schema = S.object(function (s) {
              return {
                      foo: s.f("foo", S.string),
                      bar: s.flatten(S.object(function (s) {
                                return s.f("bar", S.string);
                              }))
                    };
            });
        t.deepEqual(S.reverseConvertOrThrow({
                  foo: "foo",
                  bar: "bar"
                }, schema), {"foo": "foo", "bar": "bar"}, undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return {\"bar\":i[\"bar\"],\"foo\":i[\"foo\"],}}", undefined);
      }));

Ava("Can destructure flattened schema", (function (t) {
        var entityDataSchema = S.object(function (s) {
              return {
                      name: s.f("name", S.string),
                      age: s.f("age", S.$$int)
                    };
            });
        var entitySchema = S.object(function (s) {
              var match = s.flatten(entityDataSchema);
              return {
                      id: s.f("id", S.string),
                      name: match.name,
                      age: match.age
                    };
            });
        U.assertCompiledCode(t, entitySchema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[3](i)}let v0=i[\"name\"],v1=i[\"age\"],v2=i[\"id\"];if(typeof v0!==\"string\"){e[0](v0)}if(typeof v1!==\"number\"||v1>2147483647||v1<-2147483648||v1%1!==0){e[1](v1)}if(typeof v2!==\"string\"){e[2](v2)}return {\"id\":v2,\"name\":v0,\"age\":v1,}}", undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow({
                  id: "1",
                  name: "Dmitry",
                  age: 23
                }, entitySchema), {id: "1", name: "Dmitry", age: 23}, undefined);
        U.assertCompiledCode(t, entitySchema, "ReverseConvert", "i=>{let v0={\"name\":i[\"name\"],\"age\":i[\"age\"],};return {\"name\":v0[\"name\"],\"age\":v0[\"age\"],\"id\":i[\"id\"],}}", undefined);
      }));

export {
  
}
/*  Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import Ava from "ava";

Ava("Coerce from string to string", (function (t) {
        var schema = S.to(S.string, S.string);
        t.is(schema, S.string, undefined);
      }));

Ava("Coerce from string to bool", (function (t) {
        var schema = S.to(S.string, S.bool);
        t.deepEqual(S.parseOrThrow("false", schema), false, undefined);
        t.deepEqual(S.parseOrThrow("true", schema), true, undefined);
        U.assertThrows(t, (function () {
                return S.parseOrThrow("tru", schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.bool,
                received: "tru"
              },
              path: S.Path.empty
            });
        t.deepEqual(S.reverseConvertOrThrow(false, schema), "false", undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"string\"){e[1](i)}let v0;(v0=i===\"true\")||i===\"false\"||e[0](i);return v0}", undefined);
        U.assertCompiledCode(t, schema, "Convert", "i=>{let v0;(v0=i===\"true\")||i===\"false\"||e[0](i);return v0}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return \"\"+i}", undefined);
      }));

Ava("Coerce from bool to string", (function (t) {
        var schema = S.to(S.bool, S.string);
        t.deepEqual(S.parseOrThrow(false, schema), "false", undefined);
        t.deepEqual(S.parseOrThrow(true, schema), "true", undefined);
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow("tru", schema);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "InvalidType",
                expected: S.bool,
                received: "tru"
              },
              path: S.Path.empty
            });
        t.deepEqual(S.reverseConvertOrThrow("false", schema), false, undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"boolean\"){e[1](i)}return \"\"+i}", undefined);
        U.assertCompiledCode(t, schema, "Convert", "i=>{return \"\"+i}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v0;(v0=i===\"true\")||i===\"false\"||e[0](i);return v0}", undefined);
      }));

Ava("Coerce from string to bool literal", (function (t) {
        var schema = S.to(S.string, S.literal(false));
        t.deepEqual(S.parseOrThrow("false", schema), false, undefined);
        U.assertThrows(t, (function () {
                return S.parseOrThrow("true", schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.literal(false),
                received: "true"
              },
              path: S.Path.empty
            });
        t.deepEqual(S.reverseConvertOrThrow(false, schema), "false", undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"string\"){e[1](i)}i===\"false\"||e[0](i);return false}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{if(i!==false){e[1](i)}return \"false\"}", undefined);
      }));

Ava("Coerce from string to null literal", (function (t) {
        var schema = S.to(S.string, S.literal(null));
        t.deepEqual(S.parseOrThrow("null", schema), null, undefined);
        U.assertThrows(t, (function () {
                return S.parseOrThrow("true", schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.literal(null),
                received: "true"
              },
              path: S.Path.empty
            });
        t.deepEqual(S.reverseConvertOrThrow(null, schema), "null", undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"string\"){e[1](i)}i===\"null\"||e[0](i);return null}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{if(i!==null){e[1](i)}return \"null\"}", undefined);
      }));

Ava("Coerce from string to undefined literal", (function (t) {
        var schema = S.to(S.string, S.literal(undefined));
        t.deepEqual(S.parseOrThrow("undefined", schema), undefined, undefined);
        U.assertThrows(t, (function () {
                return S.parseOrThrow("true", schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.literal(undefined),
                received: "true"
              },
              path: S.Path.empty
            });
        t.deepEqual(S.reverseConvertOrThrow(undefined, schema), "undefined", undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"string\"){e[1](i)}i===\"undefined\"||e[0](i);return void 0}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{if(i!==void 0){e[1](i)}return \"undefined\"}", undefined);
      }));

Ava("Coerce from string to NaN literal", (function (t) {
        var schema = S.to(S.string, S.literal(NaN));
        t.deepEqual(S.parseOrThrow("NaN", schema), NaN, undefined);
        U.assertThrows(t, (function () {
                return S.parseOrThrow("true", schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.literal(NaN),
                received: "true"
              },
              path: S.Path.empty
            });
        t.deepEqual(S.reverseConvertOrThrow(NaN, schema), "NaN", undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"string\"){e[1](i)}i===\"NaN\"||e[0](i);return NaN}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{if(!Number.isNaN(i)){e[1](i)}return \"NaN\"}", undefined);
      }));

Ava("Coerce from string to string literal", (function (t) {
        var quotedString = "\"'\`";
        var schema = S.to(S.string, S.literal(quotedString));
        t.deepEqual(S.parseOrThrow(quotedString, schema), quotedString, undefined);
        U.assertThrows(t, (function () {
                return S.parseOrThrow("bar", schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.literal(quotedString),
                received: "bar"
              },
              path: S.Path.empty
            });
        t.deepEqual(S.reverseConvertOrThrow(quotedString, schema), quotedString, undefined);
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow("bar", schema);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "InvalidType",
                expected: S.literal(quotedString),
                received: "bar"
              },
              path: S.Path.empty
            });
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"string\"){e[1](i)}if(i!==\"\\\"\'\`\"){e[0](i)}return i}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{if(i!==\"\\\"\'\`\"){e[0](i)}return i}", undefined);
      }));

Ava("Coerce from object shaped as string to float", (function (t) {
        var schema = S.to(S.object(function (s) {
                  return s.f("foo", S.string);
                }), S.$$float);
        t.deepEqual(S.parseOrThrow({
                  foo: "123"
                }, schema), 123, undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[2](i)}let v0=i[\"foo\"];if(typeof v0!==\"string\"){e[0](v0)}let v1=+v0;Number.isNaN(v1)&&e[1](v0);return v1}", undefined);
        t.deepEqual(S.reverseConvertOrThrow(123, schema), {"foo": "123"}, undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return {\"foo\":\"\"+i,}}", undefined);
      }));

Ava("Coerce to literal can be used as tag and automatically embeded on reverse operation", (function (t) {
        var schema = S.object(function (s) {
              s.f("tag", S.to(S.string, S.literal(true)));
            });
        t.deepEqual(S.reverseConvertOrThrow(undefined, schema), {"tag": "true"}, undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{if(i!==void 0){e[2](i)}return {\"tag\":\"true\",}}", undefined);
        t.deepEqual(S.parseOrThrow({
                  tag: "true"
                }, schema), undefined, undefined);
        U.assertThrows(t, (function () {
                S.parseOrThrow({
                      tag: "false"
                    }, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.literal(true),
                received: "false"
              },
              path: S.Path.fromLocation("tag")
            });
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[3](i)}let v0=i[\"tag\"];if(typeof v0!==\"string\"){e[0](v0)}v0===\"true\"||e[1](v0);return e[2]}", undefined);
      }));

Ava("Coerce from string to float", (function (t) {
        var schema = S.to(S.string, S.$$float);
        t.deepEqual(S.parseOrThrow("10", schema), 10, undefined);
        t.deepEqual(S.parseOrThrow("10.2", schema), 10.2, undefined);
        U.assertThrows(t, (function () {
                return S.parseOrThrow("tru", schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.$$float,
                received: "tru"
              },
              path: S.Path.empty
            });
        t.deepEqual(S.reverseConvertOrThrow(10, schema), "10", undefined);
        t.deepEqual(S.reverseConvertOrThrow(10.2, schema), "10.2", undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"string\"){e[1](i)}let v0=+i;Number.isNaN(v0)&&e[0](i);return v0}", undefined);
        U.assertCompiledCode(t, schema, "Convert", "i=>{let v0=+i;Number.isNaN(v0)&&e[0](i);return v0}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return \"\"+i}", undefined);
      }));

Ava("Coerce from string to int32", (function (t) {
        var schema = S.to(S.string, S.$$int);
        t.deepEqual(S.parseOrThrow("10", schema), 10, undefined);
        U.assertThrows(t, (function () {
                return S.parseOrThrow("2147483648", schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.$$int,
                received: "2147483648"
              },
              path: S.Path.empty
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow("10.2", schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.$$int,
                received: "10.2"
              },
              path: S.Path.empty
            });
        t.deepEqual(S.reverseConvertOrThrow(10, schema), "10", undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"string\"){e[1](i)}let v0=+i;(v0>2147483647||v0<-2147483648||v0%1!==0)&&e[0](i);return v0}", undefined);
        U.assertCompiledCode(t, schema, "Convert", "i=>{let v0=+i;(v0>2147483647||v0<-2147483648||v0%1!==0)&&e[0](i);return v0}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return \"\"+i}", undefined);
      }));

Ava("Coerce from string to bigint literal", (function (t) {
        var schema = S.to(S.string, S.literal(10n));
        t.deepEqual(S.parseOrThrow("10", schema), 10n, undefined);
        U.assertThrows(t, (function () {
                return S.parseOrThrow("11", schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.literal(10n),
                received: "11"
              },
              path: S.Path.empty
            });
        t.deepEqual(S.reverseConvertOrThrow(10n, schema), "10", undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"string\"){e[1](i)}i===\"10\"||e[0](i);return 10n}", undefined);
        U.assertCompiledCode(t, schema, "Convert", "i=>{i===\"10\"||e[0](i);return 10n}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{if(i!==10n){e[1](i)}return \"10\"}", undefined);
      }));

Ava("Coerce from string to bigint", (function (t) {
        var schema = S.to(S.string, S.bigint);
        t.deepEqual(S.parseOrThrow("10", schema), 10n, undefined);
        U.assertThrows(t, (function () {
                return S.parseOrThrow("10.2", schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.bigint,
                received: "10.2"
              },
              path: S.Path.empty
            });
        t.deepEqual(S.reverseConvertOrThrow(10n, schema), "10", undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"string\"){e[1](i)}let v0;try{v0=BigInt(i)}catch(_){e[0](i)}return v0}", undefined);
        U.assertCompiledCode(t, schema, "Convert", "i=>{let v0;try{v0=BigInt(i)}catch(_){e[0](i)}return v0}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return \"\"+i}", undefined);
      }));

Ava("Coerce string after a transform", (function (t) {
        var schema = S.to(S.transform(S.string, (function (param) {
                    return {
                            p: (function (v) {
                                return v;
                              }),
                            s: (function (v) {
                                return v;
                              })
                          };
                  })), S.bool);
        U.assertThrowsMessage(t, (function () {
                return S.parseOrThrow("true", schema);
              }), "Failed parsing: Expected boolean, received \"true\"");
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"string\"){e[2](i)}let v0=e[0](i);if(typeof v0!==\"boolean\"){e[1](v0)}return v0}", undefined);
        var schema$1 = S.to(S.to(S.transform(S.string, (function (param) {
                        return {
                                p: (function (v) {
                                    return v;
                                  }),
                                s: (function (v) {
                                    return v;
                                  })
                              };
                      })), S.string), S.bool);
        t.deepEqual(S.parseOrThrow("true", schema$1), true, undefined);
        U.assertCompiledCode(t, schema$1, "Parse", "i=>{if(typeof i!==\"string\"){e[3](i)}let v0=e[0](i);if(typeof v0!==\"string\"){e[1](v0)}let v1;(v1=v0===\"true\")||v0===\"false\"||e[2](v0);return v1}", undefined);
      }));

Ava("Coerce string to unboxed union (each item separately)", (function (t) {
        var schema = S.to(S.string, S.union([
                  S.schema(function (s) {
                        return s.m(S.$$float);
                      }),
                  S.schema(function (s) {
                        return s.m(S.bool);
                      })
                ]));
        t.deepEqual(S.parseOrThrow("10", schema), 10, undefined);
        t.deepEqual(S.parseOrThrow("true", schema), true, undefined);
        t.throws((function () {
                return S.parseOrThrow("t", schema);
              }), {
              message: "Failed parsing: Expected string | string, received \"t\"\n- Expected number, received \"t\"\n- Expected boolean, received \"t\""
            }, undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i===\"string\"){try{let v0=+i;Number.isNaN(v0)&&e[0](i);i=v0}catch(e0){try{let v1;(v1=i===\"true\")||i===\"false\"||e[1](i);i=v1}catch(e1){e[2](i,e0,e1)}}}else{e[3](i)}return i}", undefined);
        t.deepEqual(S.reverseConvertOrThrow(10, schema), "10", undefined);
        t.deepEqual(S.reverseConvertOrThrow(true, schema), "true", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{if(typeof i===\"number\"&&!Number.isNaN(i)){i=\"\"+i}else if(typeof i===\"boolean\"){i=\"\"+i}return i}", undefined);
      }));

Ava("Keeps description of the schema we are coercing to (not working)", (function (t) {
        var schema = S.to(S.string, S.meta(S.string, {
                  description: "To descr"
                }));
        t.is(schema.description, undefined, undefined);
        var schema$1 = S.to(S.meta(S.string, {
                  description: "From descr"
                }), S.string);
        t.is(schema$1.description, "From descr", undefined);
      }));

Ava("Coerce from unit to null literal", (function (t) {
        var schema = S.to(S.unit, S.literal(null));
        t.deepEqual(S.parseOrThrow(undefined, schema), null, undefined);
        U.assertThrows(t, (function () {
                return S.parseOrThrow(null, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.unit,
                received: null
              },
              path: S.Path.empty
            });
        t.deepEqual(S.reverseConvertOrThrow(null, schema), undefined, undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(i!==void 0){e[1](i)}return null}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{if(i!==null){e[1](i)}return void 0}", undefined);
      }));

Ava("Coerce from string to optional bool", (function (t) {
        var schema = S.to(S.string, S.option(S.bool));
        t.deepEqual(S.parseOrThrow("undefined", schema), undefined, undefined);
        t.deepEqual(S.parseOrThrow("true", schema), true, undefined);
        U.assertThrows(t, (function () {
                return S.parseOrThrow(null, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: schema,
                received: null
              },
              path: S.Path.empty
            });
        t.deepEqual(S.reverseConvertOrThrow(true, schema), "true", undefined);
        t.deepEqual(S.reverseConvertOrThrow(undefined, schema), "undefined", undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i===\"string\"){try{let v0;(v0=i===\"true\")||i===\"false\"||e[0](i);i=v0}catch(e0){try{i===\"undefined\"||e[1](i);i=void 0}catch(e1){e[2](i,e0,e1)}}}else{e[3](i)}return i}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{if(typeof i===\"boolean\"){i=\"\"+i}else if(i===void 0){i=\"undefined\"}return i}", undefined);
      }));

export {
  
}
/*  Not a pure module */

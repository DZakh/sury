// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import Ava from "ava";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

Ava("Successfully parses recursive object", (function (t) {
        var nodeSchema = S.recursive(function (nodeSchema) {
              return S.object(function (s) {
                          return {
                                  id: s.f("Id", S.string),
                                  children: s.f("Children", S.array(nodeSchema))
                                };
                        });
            });
        t.deepEqual(S.parseOrThrow({
                  Id: "1",
                  Children: [
                    {
                      Id: "2",
                      Children: []
                    },
                    {
                      Id: "3",
                      Children: [{
                          Id: "4",
                          Children: []
                        }]
                    }
                  ]
                }, nodeSchema), {
              id: "1",
              children: [
                {
                  id: "2",
                  children: []
                },
                {
                  id: "3",
                  children: [{
                      id: "4",
                      children: []
                    }]
                }
              ]
            }, undefined);
      }));

Ava("Fails to parses recursive object when provided invalid type", (function (t) {
        var nodeSchema = S.recursive(function (nodeSchema) {
              return S.object(function (s) {
                          return {
                                  id: s.f("Id", S.string),
                                  children: s.f("Children", S.array(nodeSchema))
                                };
                        });
            });
        var tmp;
        try {
          S.parseOrThrow({
                Id: "1",
                Children: ["invalid"]
              }, nodeSchema);
          tmp = "Shouldn't pass";
        }
        catch (raw_exn){
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.RE_EXN_ID === S.$$Error) {
            tmp = exn._1.message;
          } else {
            throw exn;
          }
        }
        t.deepEqual(tmp, "Failed parsing at [\"Children\"][\"0\"]: Expected { Id: string; Children: Self[]; }, received \"invalid\"", undefined);
      }));

Ava("Successfully parses recursive object using S.parseAsyncOrThrow", (function (t) {
        var nodeSchema = S.recursive(function (nodeSchema) {
              return S.object(function (s) {
                          return {
                                  id: s.f("Id", S.string),
                                  children: s.f("Children", S.array(nodeSchema))
                                };
                        });
            });
        return S.parseAsyncOrThrow({
    "Id": "1",
    "Children": [
      {"Id": "2", "Children": []},
      {"Id": "3", "Children": [{"Id": "4", "Children": []}]},
    ],
  }, nodeSchema).then(function (result) {
                    t.deepEqual(result, {
                          id: "1",
                          children: [
                            {
                              id: "2",
                              children: []
                            },
                            {
                              id: "3",
                              children: [{
                                  id: "4",
                                  children: []
                                }]
                            }
                          ]
                        }, undefined);
                  });
      }));

Ava("Successfully serializes recursive object", (function (t) {
        S.setGlobalConfig({});
        var nodeSchema = S.recursive(function (nodeSchema) {
              return S.object(function (s) {
                          return {
                                  id: s.f("Id", S.string),
                                  children: s.f("Children", S.array(nodeSchema))
                                };
                        });
            });
        U.assertCompiledCode(t, nodeSchema, "ReverseConvert", "i=>{let r0=i=>{let v0=i[\"children\"],v4=new Array(v0.length);for(let v1=0;v1<v0.length;++v1){let v3;try{v3=r0(v0[v1])}catch(v2){if(v2&&v2.s===s){v2.path=\"[\\\"children\\\"]\"+\'[\"\'+v1+\'\"]\'+v2.path}throw v2}v4[v1]=v3}return {\"Id\":i[\"id\"],\"Children\":v4,}};return r0(i)}", undefined);
        t.deepEqual(S.reverseConvertOrThrow({
                  id: "1",
                  children: [
                    {
                      id: "2",
                      children: []
                    },
                    {
                      id: "3",
                      children: [{
                          id: "4",
                          children: []
                        }]
                    }
                  ]
                }, nodeSchema), {
        "Id": "1",
        "Children": [
          {"Id": "2", "Children": []},
          {"Id": "3", "Children": [{"Id": "4", "Children": []}]},
        ],
      }, undefined);
      }));

Ava("Fails to parse nested recursive object", (function (t) {
        var nodeSchema = S.recursive(function (nodeSchema) {
              return S.object(function (s) {
                          return {
                                  id: s.f("Id", S.refine(S.string, (function (s) {
                                              return function (id) {
                                                if (id === "4") {
                                                  return s.fail("Invalid id", undefined);
                                                }
                                                
                                              };
                                            }))),
                                  children: s.f("Children", S.array(nodeSchema))
                                };
                        });
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow({
                            Id: "1",
                            Children: [
                              {
                                Id: "2",
                                Children: []
                              },
                              {
                                Id: "3",
                                Children: [{
                                    Id: "4",
                                    Children: []
                                  }]
                              }
                            ]
                          }, nodeSchema);
              }), {
              operation: "Parse",
              code: {
                TAG: "OperationFailed",
                _0: "Invalid id"
              },
              path: S.Path.fromArray([
                    "Children",
                    "1",
                    "Children",
                    "0",
                    "Id"
                  ])
            });
      }));

Ava("Fails to parse nested recursive object inside of another object", (function (t) {
        var schema = S.object(function (s) {
              return s.f("recursive", S.recursive(function (nodeSchema) {
                              return S.object(function (s) {
                                          return {
                                                  id: s.f("Id", S.refine(S.string, (function (s) {
                                                              return function (id) {
                                                                if (id === "4") {
                                                                  return s.fail("Invalid id", undefined);
                                                                }
                                                                
                                                              };
                                                            }))),
                                                  children: s.f("Children", S.array(nodeSchema))
                                                };
                                        });
                            }));
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow({
                            recursive: {
                              Id: "1",
                              Children: [
                                {
                                  Id: "2",
                                  Children: []
                                },
                                {
                                  Id: "3",
                                  Children: [{
                                      Id: "4",
                                      Children: []
                                    }]
                                }
                              ]
                            }
                          }, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "OperationFailed",
                _0: "Invalid id"
              },
              path: S.Path.fromArray([
                    "recursive",
                    "Children",
                    "1",
                    "Children",
                    "0",
                    "Id"
                  ])
            });
      }));

Ava("Parses multiple nested recursive object inside of another object", (function (t) {
        S.setGlobalConfig({});
        var schema = S.object(function (s) {
              return {
                      recursive1: s.f("recursive1", S.recursive(function (nodeSchema) {
                                return S.object(function (s) {
                                            return {
                                                    id: s.f("Id", S.string),
                                                    children: s.f("Children", S.array(nodeSchema))
                                                  };
                                          });
                              })),
                      recursive2: s.f("recursive2", S.recursive(function (nodeSchema) {
                                return S.object(function (s) {
                                            return {
                                                    id: s.f("Id", S.string),
                                                    children: s.f("Children", S.array(nodeSchema))
                                                  };
                                          });
                              }))
                    };
            });
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[8](i)}let v0=i[\"recursive1\"],v9,v10=i[\"recursive2\"],v19;if(typeof v0!==\"object\"||!v0){e[0](v0)}let r0=v0=>{let v1=v0[\"Id\"],v2=v0[\"Children\"],v7=new Array(v2.length);if(typeof v1!==\"string\"){e[1](v1)}if(!Array.isArray(v2)){e[2](v2)}for(let v3=0;v3<v2.length;++v3){let v5=v2[v3],v6;try{if(typeof v5!==\"object\"||!v5){e[3](v5)}v6=r0(v5)}catch(v4){if(v4&&v4.s===s){v4.path=\"[\\\"Children\\\"]\"+\'[\"\'+v3+\'\"]\'+v4.path}throw v4}v7[v3]=v6}return {\"id\":v1,\"children\":v7,}};try{v9=r0(v0)}catch(v8){if(v8&&v8.s===s){v8.path=\"[\\\"recursive1\\\"]\"+v8.path}throw v8}if(typeof v10!==\"object\"||!v10){e[4](v10)}let r1=v10=>{let v11=v10[\"Id\"],v12=v10[\"Children\"],v17=new Array(v12.length);if(typeof v11!==\"string\"){e[5](v11)}if(!Array.isArray(v12)){e[6](v12)}for(let v13=0;v13<v12.length;++v13){let v15=v12[v13],v16;try{if(typeof v15!==\"object\"||!v15){e[7](v15)}v16=r1(v15)}catch(v14){if(v14&&v14.s===s){v14.path=\"[\\\"Children\\\"]\"+\'[\"\'+v13+\'\"]\'+v14.path}throw v14}v17[v13]=v16}return {\"id\":v11,\"children\":v17,}};try{v19=r1(v10)}catch(v18){if(v18&&v18.s===s){v18.path=\"[\\\"recursive2\\\"]\"+v18.path}throw v18}return {\"recursive1\":v9,\"recursive2\":v19,}}", undefined);
        t.deepEqual(S.parseOrThrow({
                  recursive1: {
                    Id: "1",
                    Children: [
                      {
                        Id: "2",
                        Children: []
                      },
                      {
                        Id: "3",
                        Children: [{
                            Id: "4",
                            Children: []
                          }]
                      }
                    ]
                  },
                  recursive2: {
                    Id: "1",
                    Children: [
                      {
                        Id: "2",
                        Children: []
                      },
                      {
                        Id: "3",
                        Children: [{
                            Id: "4",
                            Children: []
                          }]
                      }
                    ]
                  }
                }, schema), {
              recursive1: {
                id: "1",
                children: [
                  {
                    id: "2",
                    children: []
                  },
                  {
                    id: "3",
                    children: [{
                        id: "4",
                        children: []
                      }]
                  }
                ]
              },
              recursive2: {
                id: "1",
                children: [
                  {
                    id: "2",
                    children: []
                  },
                  {
                    id: "3",
                    children: [{
                        id: "4",
                        children: []
                      }]
                  }
                ]
              }
            }, undefined);
      }));

Ava("Fails to serialise nested recursive object", (function (t) {
        var nodeSchema = S.recursive(function (nodeSchema) {
              return S.object(function (s) {
                          return {
                                  id: s.f("Id", S.refine(S.string, (function (s) {
                                              return function (id) {
                                                if (id === "4") {
                                                  return s.fail("Invalid id", undefined);
                                                }
                                                
                                              };
                                            }))),
                                  children: s.f("Children", S.array(nodeSchema))
                                };
                        });
            });
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow({
                            id: "1",
                            children: [
                              {
                                id: "2",
                                children: []
                              },
                              {
                                id: "3",
                                children: [{
                                    id: "4",
                                    children: []
                                  }]
                              }
                            ]
                          }, nodeSchema);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "OperationFailed",
                _0: "Invalid id"
              },
              path: S.Path.fromArray([
                    "children",
                    "1",
                    "children",
                    "0",
                    "id"
                  ])
            });
      }));

Ava("Recursively transforms all objects when added transform to the recursive's function returned schema", (function (t) {
        var nodeSchema = S.recursive(function (nodeSchema) {
              return S.transform(S.object(function (s) {
                              return {
                                      id: s.f("Id", S.string),
                                      children: s.f("Children", S.array(nodeSchema))
                                    };
                            }), (function (param) {
                            return {
                                    p: (function (node) {
                                        return {
                                                id: "node_" + node.id,
                                                children: node.children
                                              };
                                      }),
                                    s: (function (node) {
                                        return {
                                                id: node.id.slice(5),
                                                children: node.children
                                              };
                                      })
                                  };
                          }));
            });
        U.assertCompiledCode(t, nodeSchema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[4](i)}let r3=i=>{let v0=i[\"Id\"],v1=i[\"Children\"],v6=new Array(v1.length);if(typeof v0!==\"string\"){e[0](v0)}if(!Array.isArray(v1)){e[1](v1)}for(let v2=0;v2<v1.length;++v2){let v4=v1[v2],v5;try{if(typeof v4!==\"object\"||!v4){e[2](v4)}v5=r3(v4)}catch(v3){if(v3&&v3.s===s){v3.path=\"[\\\"Children\\\"]\"+\'[\"\'+v2+\'\"]\'+v3.path}throw v3}v6[v2]=v5}return e[3]({\"id\":v0,\"children\":v6,})};return r3(i)}", undefined);
        t.deepEqual(S.parseOrThrow({
                  Id: "1",
                  Children: [
                    {
                      Id: "2",
                      Children: []
                    },
                    {
                      Id: "3",
                      Children: [{
                          Id: "4",
                          Children: []
                        }]
                    }
                  ]
                }, nodeSchema), {
              id: "node_1",
              children: [
                {
                  id: "node_2",
                  children: []
                },
                {
                  id: "node_3",
                  children: [{
                      id: "node_4",
                      children: []
                    }]
                }
              ]
            }, undefined);
        U.assertCompiledCode(t, nodeSchema, "ReverseConvert", "i=>{let r3=i=>{let v0=e[0](i),v1=v0[\"children\"],v5=new Array(v1.length);for(let v2=0;v2<v1.length;++v2){let v4;try{v4=r3(v1[v2])}catch(v3){if(v3&&v3.s===s){v3.path=\"[\\\"children\\\"]\"+\'[\"\'+v2+\'\"]\'+v3.path}throw v3}v5[v2]=v4}return {\"Id\":v0[\"id\"],\"Children\":v5,}};return r3(i)}", undefined);
        t.deepEqual(S.reverseConvertOrThrow({
                  id: "node_1",
                  children: [
                    {
                      id: "node_2",
                      children: []
                    },
                    {
                      id: "node_3",
                      children: [{
                          id: "node_4",
                          children: []
                        }]
                    }
                  ]
                }, nodeSchema), {
              Id: "1",
              Children: [
                {
                  Id: "2",
                  Children: []
                },
                {
                  Id: "3",
                  Children: [{
                      Id: "4",
                      Children: []
                    }]
                }
              ]
            }, undefined);
      }));

Ava("Recursively transforms nested objects when added transform to the placeholder schema", (function (t) {
        var nodeSchema = S.recursive(function (nodeSchema) {
              return S.object(function (s) {
                          return {
                                  id: s.f("Id", S.string),
                                  children: s.f("Children", S.array(S.transform(nodeSchema, (function (param) {
                                                  return {
                                                          p: (function (node) {
                                                              return {
                                                                      id: "child_" + node.id,
                                                                      children: node.children
                                                                    };
                                                            }),
                                                          s: (function (node) {
                                                              return {
                                                                      id: node.id.slice(6),
                                                                      children: node.children
                                                                    };
                                                            })
                                                        };
                                                }))))
                                };
                        });
            });
        t.deepEqual(S.parseOrThrow({
                  Id: "1",
                  Children: [
                    {
                      Id: "2",
                      Children: []
                    },
                    {
                      Id: "3",
                      Children: [{
                          Id: "4",
                          Children: []
                        }]
                    }
                  ]
                }, nodeSchema), {
              id: "1",
              children: [
                {
                  id: "child_2",
                  children: []
                },
                {
                  id: "child_3",
                  children: [{
                      id: "child_4",
                      children: []
                    }]
                }
              ]
            }, undefined);
        t.deepEqual(S.reverseConvertOrThrow({
                  id: "1",
                  children: [
                    {
                      id: "child_2",
                      children: []
                    },
                    {
                      id: "child_3",
                      children: [{
                          id: "child_4",
                          children: []
                        }]
                    }
                  ]
                }, nodeSchema), {
              Id: "1",
              Children: [
                {
                  Id: "2",
                  Children: []
                },
                {
                  Id: "3",
                  Children: [{
                      Id: "4",
                      Children: []
                    }]
                }
              ]
            }, undefined);
      }));

Ava("Shallowly transforms object when added transform to the S.recursive result", (function (t) {
        var nodeSchema = S.transform(S.recursive(function (nodeSchema) {
                  return S.object(function (s) {
                              return {
                                      id: s.f("Id", S.string),
                                      children: s.f("Children", S.array(nodeSchema))
                                    };
                            });
                }), (function (param) {
                return {
                        p: (function (node) {
                            return {
                                    id: "parent_" + node.id,
                                    children: node.children
                                  };
                          }),
                        s: (function (node) {
                            return {
                                    id: node.id.slice(7),
                                    children: node.children
                                  };
                          })
                      };
              }));
        t.deepEqual(S.parseOrThrow({
                  Id: "1",
                  Children: [
                    {
                      Id: "2",
                      Children: []
                    },
                    {
                      Id: "3",
                      Children: [{
                          Id: "4",
                          Children: []
                        }]
                    }
                  ]
                }, nodeSchema), {
              id: "parent_1",
              children: [
                {
                  id: "2",
                  children: []
                },
                {
                  id: "3",
                  children: [{
                      id: "4",
                      children: []
                    }]
                }
              ]
            }, undefined);
        t.deepEqual(S.reverseConvertOrThrow({
                  id: "parent_1",
                  children: [
                    {
                      id: "2",
                      children: []
                    },
                    {
                      id: "3",
                      children: [{
                          id: "4",
                          children: []
                        }]
                    }
                  ]
                }, nodeSchema), {
              Id: "1",
              Children: [
                {
                  Id: "2",
                  Children: []
                },
                {
                  Id: "3",
                  Children: [{
                      Id: "4",
                      Children: []
                    }]
                }
              ]
            }, undefined);
        U.assertCompiledCode(t, nodeSchema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[4](i)}let r5=i=>{let v0=i[\"Id\"],v1=i[\"Children\"],v6=new Array(v1.length);if(typeof v0!==\"string\"){e[0](v0)}if(!Array.isArray(v1)){e[1](v1)}for(let v2=0;v2<v1.length;++v2){let v4=v1[v2],v5;try{if(typeof v4!==\"object\"||!v4){e[2](v4)}v5=r5(v4)}catch(v3){if(v3&&v3.s===s){v3.path=\"[\\\"Children\\\"]\"+\'[\"\'+v2+\'\"]\'+v3.path}throw v3}v6[v2]=v5}return {\"id\":v0,\"children\":v6,}};return e[3](r5(i))}", undefined);
        U.assertCompiledCode(t, nodeSchema, "ReverseConvert", "i=>{let v0=e[0](i);let r5=v0=>{let v1=v0[\"children\"],v5=new Array(v1.length);for(let v2=0;v2<v1.length;++v2){let v4;try{v4=r5(v1[v2])}catch(v3){if(v3&&v3.s===s){v3.path=\"[\\\"children\\\"]\"+\'[\"\'+v2+\'\"]\'+v3.path}throw v3}v5[v2]=v4}return {\"Id\":v0[\"id\"],\"Children\":v5,}};return r5(v0)}", undefined);
      }));

Ava("Creates schema without async parse function using S.recursive", (function (t) {
        t.notThrows((function () {
                S.recursive(function (nodeSchema) {
                      return S.object(function (s) {
                                  return {
                                          id: s.f("Id", S.string),
                                          children: s.f("Children", S.array(nodeSchema))
                                        };
                                });
                    });
              }), undefined);
      }));

Ava("Creates schema with async parse function using S.recursive", (function (t) {
        t.notThrows((function () {
                S.recursive(function (nodeSchema) {
                      return S.object(function (s) {
                                  return {
                                          id: s.f("Id", S.transform(S.string, (function (param) {
                                                      return {
                                                              a: (function (i) {
                                                                  return Promise.resolve(i);
                                                                })
                                                            };
                                                    }))),
                                          children: s.f("Children", S.array(nodeSchema))
                                        };
                                });
                    });
              }), undefined);
      }));

Ava("Successfully parses recursive object with async parse function", (function (t) {
        S.setGlobalConfig({});
        var nodeSchema = S.recursive(function (nodeSchema) {
              return S.object(function (s) {
                          return {
                                  id: s.f("Id", S.transform(S.string, (function (param) {
                                              return {
                                                      a: (function (i) {
                                                          return Promise.resolve(i);
                                                        })
                                                    };
                                            }))),
                                  children: s.f("Children", S.array(nodeSchema))
                                };
                        });
            });
        U.assertCompiledCode(t, nodeSchema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[4](i)}let r0=i=>{let v0=i[\"Id\"],v1=i[\"Children\"],v6=new Array(v1.length);if(typeof v0!==\"string\"){e[0](v0)}if(!Array.isArray(v1)){e[2](v1)}for(let v2=0;v2<v1.length;++v2){let v4=v1[v2],v5;try{if(typeof v4!==\"object\"||!v4){e[3](v4)}v5=r0(v4).catch(v3=>{if(v3&&v3.s===s){v3.path=\"[\\\"Children\\\"]\"+\'[\"\'+v2+\'\"]\'+v3.path}throw v3})}catch(v3){if(v3&&v3.s===s){v3.path=\"[\\\"Children\\\"]\"+\'[\"\'+v2+\'\"]\'+v3.path}throw v3}v6[v2]=v5}return Promise.all([e[1](v0),Promise.all(v6),]).then(a=>({\"id\":a[0],\"children\":a[1],}))};return r0(i)}", undefined);
        return S.parseAsyncOrThrow({
    "Id":"1",
    "Children": [
      {"Id": "2", "Children": []},
      {"Id": "3", "Children": [{"Id": "4", "Children": []}]},
    ],
  }, nodeSchema).then(function (result) {
                    t.deepEqual(result, {
                          id: "1",
                          children: [
                            {
                              id: "2",
                              children: []
                            },
                            {
                              id: "3",
                              children: [{
                                  id: "4",
                                  children: []
                                }]
                            }
                          ]
                        }, undefined);
                  });
      }));

Ava("Parses recursive object with async fields in parallel", (function (t) {
        var unresolvedPromise = new Promise((function (param, param$1) {
                
              }));
        var actionCounter = {
          contents: 0
        };
        var nodeSchema = S.recursive(function (nodeSchema) {
              return S.object(function (s) {
                          return {
                                  id: s.f("Id", S.transform(S.string, (function (param) {
                                              return {
                                                      a: (function (param) {
                                                          actionCounter.contents = actionCounter.contents + 1 | 0;
                                                          return unresolvedPromise;
                                                        })
                                                    };
                                            }))),
                                  children: s.f("Children", S.array(nodeSchema))
                                };
                        });
            });
        S.parseAsyncOrThrow({
    "Id": "1",
    "Children": [
      {"Id": "2", "Children": []},
      {"Id": "3", "Children": [{"Id": "4", "Children": []}]},
    ],
  }, nodeSchema);
        t.deepEqual(actionCounter.contents, 4, undefined);
      }));

Ava("Compiled parse code snapshot", (function (t) {
        S.setGlobalConfig({});
        var schema = S.recursive(function (schema) {
              return S.object(function (s) {
                          return {
                                  id: s.f("Id", S.string),
                                  children: s.f("Children", S.array(schema))
                                };
                        });
            });
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[3](i)}let r0=i=>{let v0=i[\"Id\"],v1=i[\"Children\"],v6=new Array(v1.length);if(typeof v0!==\"string\"){e[0](v0)}if(!Array.isArray(v1)){e[1](v1)}for(let v2=0;v2<v1.length;++v2){let v4=v1[v2],v5;try{if(typeof v4!==\"object\"||!v4){e[2](v4)}v5=r0(v4)}catch(v3){if(v3&&v3.s===s){v3.path=\"[\\\"Children\\\"]\"+\'[\"\'+v2+\'\"]\'+v3.path}throw v3}v6[v2]=v5}return {\"id\":v0,\"children\":v6,}};return r0(i)}", undefined);
      }));

export {
  
}
/*  Not a pure module */

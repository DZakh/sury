// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import Ava from "ava";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

var any = undefined;

var invalidAny = 123.45;

function factory() {
  return S.option(S.string);
}

Ava("Successfully parses", (function (t) {
        var schema = S.option(S.string);
        t.deepEqual(S.parseOrThrow(any, schema), undefined, undefined);
      }));

Ava("Fails to parse", (function (t) {
        var schema = S.option(S.string);
        U.assertThrows(t, (function () {
                return S.parseOrThrow(invalidAny, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: schema,
                received: invalidAny
              },
              path: S.Path.empty
            });
      }));

Ava("Successfully serializes", (function (t) {
        var schema = S.option(S.string);
        t.deepEqual(S.reverseConvertOrThrow(undefined, schema), any, undefined);
      }));

Ava("Compiled parse code snapshot", (function (t) {
        var schema = S.option(S.string);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(!(typeof i===\"string\"||i===void 0)){e[0](i)}return i}", undefined);
      }));

Ava("Compiled async parse code snapshot", (function (t) {
        var schema = S.option(S.transform(S.unknown, (function (param) {
                    return {
                            a: (function (i) {
                                return Promise.resolve(i);
                              })
                          };
                  })));
        U.assertCompiledCode(t, schema, "Parse", "i=>{try{i=e[0](i)}catch(e0){if(!(i===void 0)){e[1](i,e0)}}return Promise.resolve(i)}", undefined);
      }));

Ava("Compiled serialize code snapshot", (function (t) {
        var schema = S.option(S.string);
        U.assertCompiledCodeIsNoop(t, schema, "ReverseConvert", undefined);
      }));

Ava("Reverse to self", (function (t) {
        var schema = S.option(S.string);
        t.is(S.reverse(schema), schema, undefined);
      }));

Ava("Succesfully uses reversed schema for parsing back to initial value", (function (t) {
        var schema = S.option(S.string);
        U.assertReverseParsesBack(t, schema, "abc");
        U.assertReverseParsesBack(t, schema, undefined);
      }));

var Common = {
  value: undefined,
  any: any,
  invalidAny: invalidAny,
  factory: factory
};

Ava("Classify schema", (function (t) {
        var schema = S.option(S.$$null(S.string));
        U.assertEqualSchemas(t, schema, S.union([
                  S.string,
                  S.unit,
                  S.literal(null)
                ]), undefined);
        U.assertEqualSchemas(t, S.reverse(schema), S.union([
                  S.string,
                  S.unit,
                  S.literal({
                        BS_PRIVATE_NESTED_SOME_NONE: 0
                      })
                ]), undefined);
      }));

Ava("Successfully parses primitive", (function (t) {
        var schema = S.option(S.bool);
        t.deepEqual(S.parseOrThrow(true, schema), true, undefined);
      }));

Ava("Fails to parse JS null", (function (t) {
        var schema = S.option(S.bool);
        U.assertThrows(t, (function () {
                return S.parseOrThrow(null, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: schema,
                received: null
              },
              path: S.Path.empty
            });
      }));

Ava("Fails to parse JS undefined when schema doesn't allow optional data", (function (t) {
        U.assertThrows(t, (function () {
                return S.parseOrThrow(undefined, S.bool);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.bool,
                received: undefined
              },
              path: S.Path.empty
            });
      }));

Ava("Serializes Some(None) to undefined for option nested in null", (function (t) {
        var schema = S.$$null(S.option(S.bool));
        t.deepEqual(S.parseOrThrow(undefined, schema), Caml_option.some(undefined), undefined);
        t.deepEqual(S.parseOrThrow(null, schema), undefined, undefined);
        t.deepEqual(S.reverseConvertOrThrow(Caml_option.some(undefined), schema), undefined, undefined);
        t.deepEqual(S.reverseConvertOrThrow(undefined, schema), null, undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(i===null){i=void 0}else if(i===void 0){i={\"BS_PRIVATE_NESTED_SOME_NONE\":0}}else if(!(typeof i===\"boolean\")){e[0](i)}return i}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{if(i===void 0){i=null}else if(typeof i===\"object\"&&i&&i[\"BS_PRIVATE_NESTED_SOME_NONE\"]===0){i=void 0}return i}", undefined);
      }));

Ava("Applies valFromOption for Some()", (function (t) {
        var schema = S.option(S.literal());
        t.deepEqual(S.parseOrThrow(undefined, schema), undefined, undefined);
        t.deepEqual(S.reverseConvertOrThrow(Caml_option.some(undefined), schema), undefined, undefined);
        t.deepEqual(S.reverseConvertOrThrow(undefined, schema), undefined, undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(!(i===void 0)){e[0](i)}return i}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{if(typeof i===\"object\"&&i&&i[\"BS_PRIVATE_NESTED_SOME_NONE\"]===0){i=void 0}return i}", undefined);
      }));

Ava("Nested option support", (function (t) {
        var schema = S.option(S.option(S.bool));
        t.deepEqual(S.parseOrThrow(undefined, schema), undefined, undefined);
        t.deepEqual(S.reverseConvertOrThrow(true, schema), true, undefined);
        t.deepEqual(S.reverseConvertOrThrow(Caml_option.some(undefined), schema), undefined, undefined);
        t.deepEqual(S.reverseConvertOrThrow(undefined, schema), undefined, undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(!(typeof i===\"boolean\"||i===void 0)){e[0](i)}return i}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{if(typeof i===\"object\"&&i&&i[\"BS_PRIVATE_NESTED_SOME_NONE\"]===0){i=void 0}return i}", undefined);
      }));

Ava("Triple nested option support", (function (t) {
        var schema = S.option(S.option(S.option(S.bool)));
        t.deepEqual(S.parseOrThrow(undefined, schema), undefined, undefined);
        t.deepEqual(S.reverseConvertOrThrow(true, schema), true, undefined);
        t.deepEqual(S.reverseConvertOrThrow(Caml_option.some(Caml_option.some(undefined)), schema), undefined, undefined);
        t.deepEqual(S.reverseConvertOrThrow(Caml_option.some(undefined), schema), undefined, undefined);
        t.deepEqual(S.reverseConvertOrThrow(undefined, schema), undefined, undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(!(typeof i===\"boolean\"||i===void 0)){e[0](i)}return i}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{if(typeof i===\"object\"&&i){if(i[\"BS_PRIVATE_NESTED_SOME_NONE\"]===0){i=void 0}else if(i[\"BS_PRIVATE_NESTED_SOME_NONE\"]===1){i=void 0}}return i}", undefined);
      }));

Ava("Empty object in option: S.option(S.object(_ => ())) https://github.com/DZakh/rescript-schema/issues/110", (function (t) {
        var schema = S.option(S.object(function (param) {
                  
                }));
        t.deepEqual(S.parseOrThrow(undefined, schema), undefined, undefined);
        t.deepEqual(S.parseOrThrow({}, schema), Caml_option.some(undefined), undefined);
        t.deepEqual(S.reverseConvertOrThrow(Caml_option.some(undefined), schema), undefined, undefined);
        t.deepEqual(S.reverseConvertOrThrow(undefined, schema), undefined, undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i===\"object\"&&i){i={\"BS_PRIVATE_NESTED_SOME_NONE\":0}}else if(!(i===void 0)){e[0](i)}return i}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{if(typeof i===\"object\"&&i&&i[\"BS_PRIVATE_NESTED_SOME_NONE\"]===0){i=undefined}return i}", undefined);
      }));

Ava("Doesn't apply valFromOption for non-undefined literals in option", (function (t) {
        var schema = S.option(S.literal(null));
        t.deepEqual(S.reverseConvertOrThrow(Caml_option.some(null), schema), null, undefined);
        t.deepEqual(S.reverseConvertOrThrow(undefined, schema), undefined, undefined);
        U.assertCompiledCodeIsNoop(t, schema, "ReverseConvert", undefined);
      }));

Ava("Option with unknown", (function (t) {
        var schema = S.option(S.unknown);
        t.deepEqual(S.reverseConvertOrThrow(Caml_option.some(undefined), schema), {BS_PRIVATE_NESTED_SOME_NONE: 0}, undefined);
        t.deepEqual(S.reverseConvertOrThrow(Caml_option.some("foo"), schema), "foo", undefined);
        t.deepEqual(S.reverseConvertOrThrow(undefined, schema), undefined, undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(!(i===void 0)){e[0](i)}return i}", undefined);
        U.assertCompiledCodeIsNoop(t, schema, "ReverseConvert", undefined);
      }));

export {
  Common ,
}
/*  Not a pure module */

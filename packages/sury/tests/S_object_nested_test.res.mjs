// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import Ava from "ava";
import * as Core__Float from "@rescript/core/src/Core__Float.res.mjs";

Ava("Object with a single nested field", (function (t) {
        var schema = S.object(function (s) {
              return s.nested("nested").f("foo", S.string);
            });
        U.unsafeAssertEqualSchemas(t, schema, S.object(function (s) {
                  return s.f("nested", S.object(function (s) {
                                  return s.f("foo", S.string);
                                }));
                }), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[2](i)}let v0=i[\"nested\"];if(typeof v0!==\"object\"||!v0){e[0](v0)}let v1=v0[\"foo\"];if(typeof v1!==\"string\"){e[1](v1)}return v1}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return {\"nested\":{\"foo\":i,},}}", undefined);
      }));

Ava("Object with a single nested field with S.null", (function (t) {
        var schema = S.object(function (s) {
              return s.nested("nested").f("foo", S.$$null(S.string));
            });
        U.unsafeAssertEqualSchemas(t, schema, S.object(function (s) {
                  return s.f("nested", S.object(function (s) {
                                  return s.f("foo", S.$$null(S.string));
                                }));
                }), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[2](i)}let v0=i[\"nested\"];if(typeof v0!==\"object\"||!v0){e[0](v0)}let v1=v0[\"foo\"];if(v1===null){v1=void 0}else if(!(typeof v1===\"string\")){e[1](v1)}return v1}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{if(i===void 0){i=null}return {\"nested\":{\"foo\":i,},}}", undefined);
        t.deepEqual(S.reverseConvertOrThrow("bar", schema), {"nested":{"foo":"bar"}}, undefined);
      }));

Ava("Object with a single nested field with S.transform", (function (t) {
        var schema = S.object(function (s) {
              return s.nested("nested").f("foo", S.transform(S.$$float, (function (s) {
                                return {
                                        p: (function (f) {
                                            return f.toString();
                                          }),
                                        s: (function (string) {
                                            if (typeof string !== "string") {
                                              s.fail("Unexpected type", undefined);
                                            }
                                            var $$float = Core__Float.fromString(string);
                                            if ($$float !== undefined) {
                                              return $$float;
                                            } else {
                                              return s.fail("Invalid float", undefined);
                                            }
                                          })
                                      };
                              })));
            });
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[3](i)}let v0=i[\"nested\"];if(typeof v0!==\"object\"||!v0){e[0](v0)}let v1=v0[\"foo\"];if(typeof v1!==\"number\"||Number.isNaN(v1)){e[1](v1)}return e[2](v1)}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return {\"nested\":{\"foo\":e[0](i),},}}", undefined);
        t.deepEqual(S.reverseConvertOrThrow("123.4", schema), {"nested":{"foo":123.4}}, undefined);
      }));

Ava("Object with a nested tag and optional field", (function (t) {
        var schema = S.object(function (s) {
              s.nested("nested").tag("tag", "value");
              return {
                      foo: s.nested("nested").fieldOr("foo", S.string, ""),
                      bar: s.f("bar", S.string)
                    };
            });
        U.unsafeAssertEqualSchemas(t, schema, S.object(function (s) {
                  s.f("nested", S.object(function (s) {
                            s.tag("tag", "value");
                            s.fieldOr("foo", S.string, "");
                          }));
                  s.f("bar", S.string);
                }), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[4](i)}let v0=i[\"nested\"],v2=i[\"bar\"];if(typeof v0!==\"object\"||!v0||v0[\"tag\"]!==\"value\"){e[0](v0)}let v1=v0[\"foo\"];if(!(typeof v1===\"string\"||v1===void 0)){e[1](v1)}if(typeof v2!==\"string\"){e[3](v2)}return {\"foo\":v1===void 0?e[2]:v1,\"bar\":v2,}}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return {\"nested\":{\"tag\":e[0],\"foo\":i[\"foo\"],},\"bar\":i[\"bar\"],}}", undefined);
      }));

Ava("Object with a two nested field using the same ctx", (function (t) {
        var schema = S.object(function (s) {
              var nested = s.nested("nested");
              return {
                      foo: nested.f("foo", S.string),
                      bar: nested.f("bar", S.string)
                    };
            });
        U.unsafeAssertEqualSchemas(t, schema, S.object(function (s) {
                  return s.f("nested", S.object(function (s) {
                                  return {
                                          foo: s.f("foo", S.string),
                                          bar: s.f("bar", S.string)
                                        };
                                }));
                }), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[3](i)}let v0=i[\"nested\"];if(typeof v0!==\"object\"||!v0){e[0](v0)}let v1=v0[\"foo\"],v2=v0[\"bar\"];if(typeof v1!==\"string\"){e[1](v1)}if(typeof v2!==\"string\"){e[2](v2)}return {\"foo\":v1,\"bar\":v2,}}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return {\"nested\":{\"foo\":i[\"foo\"],\"bar\":i[\"bar\"],},}}", undefined);
      }));

Ava("Object with a single nested nested field", (function (t) {
        var schema = S.object(function (s) {
              return s.nested("nested").nested("deeply").f("foo", S.string);
            });
        U.unsafeAssertEqualSchemas(t, schema, S.object(function (s) {
                  return s.f("nested", S.object(function (s) {
                                  return s.f("deeply", S.object(function (s) {
                                                  return s.f("foo", S.string);
                                                }));
                                }));
                }), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[3](i)}let v0=i[\"nested\"];if(typeof v0!==\"object\"||!v0){e[0](v0)}let v1=v0[\"deeply\"];if(typeof v1!==\"object\"||!v1){e[1](v1)}let v2=v1[\"foo\"];if(typeof v2!==\"string\"){e[2](v2)}return v2}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return {\"nested\":{\"deeply\":{\"foo\":i,},},}}", undefined);
      }));

Ava("Object with a two nested field calling s.nested twice", (function (t) {
        var schema = S.object(function (s) {
              return {
                      foo: s.nested("nested").f("foo", S.string),
                      bar: s.nested("nested").f("bar", S.string)
                    };
            });
        U.unsafeAssertEqualSchemas(t, schema, S.object(function (s) {
                  return s.f("nested", S.object(function (s) {
                                  return {
                                          foo: s.f("foo", S.string),
                                          bar: s.f("bar", S.string)
                                        };
                                }));
                }), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[3](i)}let v0=i[\"nested\"];if(typeof v0!==\"object\"||!v0){e[0](v0)}let v1=v0[\"foo\"],v2=v0[\"bar\"];if(typeof v1!==\"string\"){e[1](v1)}if(typeof v2!==\"string\"){e[2](v2)}return {\"foo\":v1,\"bar\":v2,}}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return {\"nested\":{\"foo\":i[\"foo\"],\"bar\":i[\"bar\"],},}}", undefined);
      }));

Ava("Object with a flattened nested field", (function (t) {
        var schema = S.object(function (s) {
              return s.nested("nested").flatten(S.schema(function (s) {
                              return {
                                      foo: s.m(S.string)
                                    };
                            }));
            });
        U.unsafeAssertEqualSchemas(t, schema, S.object(function (s) {
                  return s.f("nested", S.schema(function (s) {
                                  return {
                                          foo: s.m(S.string)
                                        };
                                }));
                }), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[2](i)}let v0=i[\"nested\"];if(typeof v0!==\"object\"||!v0){e[0](v0)}let v1=v0[\"foo\"];if(typeof v1!==\"string\"){e[1](v1)}return {\"foo\":v1,}}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return {\"nested\":{\"foo\":i[\"foo\"],},}}", undefined);
      }));

Ava("Object with a strict flattened nested field", (function (t) {
        var schema = S.object(function (s) {
              return s.nested("nested").flatten(S.strict(S.schema(function (s) {
                                  return {
                                          foo: s.m(S.string)
                                        };
                                })));
            });
        U.unsafeAssertEqualSchemas(t, schema, S.object(function (s) {
                  return s.f("nested", S.schema(function (s) {
                                  return {
                                          foo: s.m(S.string)
                                        };
                                }));
                }), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[2](i)}let v0=i[\"nested\"];if(typeof v0!==\"object\"||!v0){e[0](v0)}let v1=v0[\"foo\"];if(typeof v1!==\"string\"){e[1](v1)}return {\"foo\":v1,}}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return {\"nested\":{\"foo\":i[\"foo\"],},}}", undefined);
      }));

Ava("S.schema object with a deep strict applied to the nested field parent", (function (t) {
        var schema = S.deepStrict(S.schema(function (s) {
                  return {
                          nested: {
                            foo: s.m(S.string)
                          }
                        };
                }));
        U.unsafeAssertEqualSchemas(t, schema, S.strict(S.object(function (s) {
                      return s.f("nested", S.strict(S.schema(function (s) {
                                          return {
                                                  foo: s.m(S.string)
                                                };
                                        })));
                    })), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i||Array.isArray(i)){e[4](i)}let v0=i[\"nested\"],v3;if(typeof v0!==\"object\"||!v0||Array.isArray(v0)){e[0](v0)}let v1=v0[\"foo\"],v2;if(typeof v1!==\"string\"){e[1](v1)}for(v2 in v0){if(v2!==\"foo\"){e[2](v2)}}for(v3 in i){if(v3!==\"nested\"){e[3](v3)}}return i}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v0=i[\"nested\"];return i}", undefined);
      }));

Ava("Nested tags on reverse convert", (function (t) {
        var schema = S.object(function (s) {
              s.nested("nested").tag("tag", "value");
            });
        t.deepEqual(S.reverseConvertOrThrow(undefined, schema), {"nested":{"tag":"value"}}, undefined);
      }));

Ava("Nested preprocessed tags on reverse convert", (function (t) {
        var prefixedWithUnderscore = S.to(S.transform(S.string, (function (s) {
                    return {
                            p: (function (v) {
                                if (v.startsWith("_")) {
                                  return v.slice(1);
                                } else {
                                  return s.fail("String should start with an underscore", undefined);
                                }
                              }),
                            s: (function (v) {
                                return "_" + v;
                              })
                          };
                  })), S.string);
        var schema = S.object(function (s) {
              s.nested("nested").f("tag", S.to(prefixedWithUnderscore, S.literal("value")));
              s.nested("nested").f("intTag", S.to(prefixedWithUnderscore, S.literal(1)));
            });
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{if(i!==void 0){e[5](i)}return {\"nested\":{\"tag\":e[2](e[0]),\"intTag\":e[4](\"1\"),},}}", undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[10](i)}let v0=i[\"nested\"];if(typeof v0!==\"object\"||!v0){e[0](v0)}let v1=v0[\"tag\"],v2=e[2](v1),v3=v0[\"intTag\"],v4=e[6](v3);if(typeof v1!==\"string\"){e[1](v1)}if(typeof v2!==\"string\"){e[3](v2)}if(v2!==\"value\"){e[4](v2)}if(typeof v3!==\"string\"){e[5](v3)}if(typeof v4!==\"string\"){e[7](v4)}v4===\"1\"||e[8](v4);return e[9]}", undefined);
        t.deepEqual(S.reverseConvertOrThrow(undefined, schema), {"nested":{"tag":"_value", "intTag":"_1"}}, undefined);
        t.deepEqual(S.parseOrThrow({"nested":{"tag":"_value", "intTag":"_1"}}, schema), undefined, undefined);
      }));

Ava("S.schema object with a deep strict applied to the nested field parent + reverse", (function (t) {
        var schema = S.deepStrict(S.reverse(S.schema(function (s) {
                      return {
                              nested: {
                                foo: s.m(S.$$null(S.string))
                              }
                            };
                    })));
        U.unsafeAssertEqualSchemas(t, schema, S.strict(S.object(function (s) {
                      return s.f("nested", S.strict(S.schema(function (s) {
                                          return {
                                                  foo: s.m(S.option(S.string))
                                                };
                                        })));
                    })), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i||Array.isArray(i)){e[4](i)}let v0=i[\"nested\"],v3;if(typeof v0!==\"object\"||!v0||Array.isArray(v0)){e[0](v0)}let v1=v0[\"foo\"],v2;if(v1===void 0){v1=null}else if(!(typeof v1===\"string\")){e[1](v1)}for(v2 in v0){if(v2!==\"foo\"){e[2](v2)}}for(v3 in i){if(v3!==\"nested\"){e[3](v3)}}return {\"nested\":{\"foo\":v1,},}}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v0=i[\"nested\"];let v1=v0[\"foo\"];if(v1===null){v1=void 0}return {\"nested\":{\"foo\":v1,},}}", undefined);
      }));

Ava("Object with a deep strict applied to the nested field parent", (function (t) {
        var schema = S.deepStrict(S.object(function (s) {
                  return s.nested("nested").f("foo", S.string);
                }));
        U.unsafeAssertEqualSchemas(t, schema, S.strict(S.object(function (s) {
                      return s.f("nested", S.strict(S.schema(function (s) {
                                          return {
                                                  foo: s.m(S.string)
                                                };
                                        })));
                    })), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i||Array.isArray(i)){e[4](i)}let v0=i[\"nested\"],v3;if(typeof v0!==\"object\"||!v0||Array.isArray(v0)){e[0](v0)}let v1=v0[\"foo\"],v2;if(typeof v1!==\"string\"){e[1](v1)}for(v2 in v0){if(v2!==\"foo\"){e[2](v2)}}for(v3 in i){if(v3!==\"nested\"){e[3](v3)}}return v1}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return {\"nested\":{\"foo\":i,},}}", undefined);
      }));

Ava("Object with a deep strict applied to the nested field parent + reverse", (function (t) {
        var schema = S.deepStrict(S.reverse(S.object(function (s) {
                      return {
                              foo: s.nested("nested").f("foo", S.string)
                            };
                    })));
        U.unsafeAssertEqualSchemas(t, schema, S.strict(S.schema(function (s) {
                      return {
                              foo: s.m(S.string)
                            };
                    })), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i||Array.isArray(i)){e[1](i)}let v0;for(v0 in i){if(v0!==\"foo\"){e[0](v0)}}return {\"nested\":{\"foo\":i[\"foo\"],},}}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v0=i[\"nested\"];return {\"foo\":v0[\"foo\"],}}", undefined);
      }));

Ava("Object with nested field together with flatten", (function (t) {
        var schema = S.object(function (s) {
              return {
                      flattened: s.nested("nested").flatten(S.schema(function (s) {
                                return {
                                        foo: s.m(S.string)
                                      };
                              })),
                      field: s.nested("nested").f("bar", S.string)
                    };
            });
        U.unsafeAssertEqualSchemas(t, schema, S.object(function (s) {
                  return s.f("nested", S.schema(function (s) {
                                  return {
                                          foo: s.m(S.string),
                                          bar: s.m(S.string)
                                        };
                                }));
                }), undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[3](i)}let v0=i[\"nested\"];if(typeof v0!==\"object\"||!v0){e[0](v0)}let v1=v0[\"foo\"],v2=v0[\"bar\"];if(typeof v1!==\"string\"){e[1](v1)}if(typeof v2!==\"string\"){e[2](v2)}return {\"flattened\":{\"foo\":v1,},\"field\":v2,}}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return {\"nested\":{\"foo\":i[\"flattened\"][\"foo\"],\"bar\":i[\"field\"],},}}", undefined);
      }));

Ava("s.nested conflicts with s.field", (function (t) {
        t.throws((function () {
                return S.object(function (s) {
                            s.nested("nested").f("foo", S.string);
                            s.f("nested", S.object(function (s) {
                                      return s.f("foo", S.string);
                                    }));
                          });
              }), {
              message: "[Schema] The field \"nested\" defined twice with incompatible schemas"
            }, undefined);
      }));

Ava("s.nested.flattened doesn't work with S.object", (function (t) {
        t.throws((function () {
                return S.object(function (s) {
                            s.nested("nested").flatten(S.object(function (s) {
                                      return s.f("foo", S.string);
                                    }));
                          });
              }), {
              message: "[Schema] Unsupported nested flatten for advanced object schema '{ foo: string; }'"
            }, undefined);
      }));

Ava("s.nested.flattened doesn't work with transformed S.schema", (function (t) {
        t.throws((function () {
                return S.object(function (s) {
                            s.nested("nested").flatten(S.transform(S.schema(function (s) {
                                          return {
                                                  foo: s.m(S.string)
                                                };
                                        }), (function (param) {
                                        return {
                                                p: (function (i) {
                                                    return i;
                                                  })
                                              };
                                      })));
                          });
              }), {
              message: "[Schema] Unsupported nested flatten for transformed schema \'{ foo: string; }\'"
            }, undefined);
      }));

Ava("s.nested.flattened doesn't work with S.schema->S.shape", (function (t) {
        t.throws((function () {
                return S.object(function (s) {
                            s.nested("nested").flatten(S.shape(S.schema(function (s) {
                                          return {
                                                  foo: s.m(S.string)
                                                };
                                        }), (function (v) {
                                        return {
                                                foo: v.foo
                                              };
                                      })));
                          });
              }), {
              message: "[Schema] Unsupported nested flatten for transformed schema \'{ foo: string; }\'"
            }, undefined);
      }));

Ava("s.nested.flattened doesn't work with S.string", (function (t) {
        t.throws((function () {
                return S.object(function (s) {
                            s.nested("nested").flatten(S.string);
                          });
              }), {
              message: "[Schema] The 'string' schema can\'t be flattened"
            }, undefined);
      }));

Ava("s.nested.flattened works with S.schema->S.shape to self", (function (t) {
        var schema = S.object(function (s) {
              return s.nested("nested").flatten(S.shape(S.schema(function (s) {
                                  return {
                                          foo: s.m(S.string)
                                        };
                                }), (function (v) {
                                return v;
                              })));
            });
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[2](i)}let v0=i[\"nested\"];if(typeof v0!==\"object\"||!v0){e[0](v0)}let v1=v0[\"foo\"];if(typeof v1!==\"string\"){e[1](v1)}return {\"foo\":v1,}}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return {\"nested\":{\"foo\":i[\"foo\"],},}}", undefined);
      }));

Ava("s.nested.flatten conflicts with s.nested.field", (function (t) {
        t.throws((function () {
                return S.object(function (s) {
                            s.nested("nested").flatten(S.schema(function (s) {
                                      return {
                                              foo: s.m(S.string)
                                            };
                                    }));
                            s.nested("nested").f("foo", S.string);
                          });
              }), {
              message: "[Schema] The field \"foo\" defined twice"
            }, undefined);
      }));

export {
  
}
/*  Not a pure module */

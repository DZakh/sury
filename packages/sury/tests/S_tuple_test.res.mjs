// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import Ava from "ava";

var any = [];

var invalidAny = [true];

var invalidTypeAny = "Hello world!";

function factory() {
  return S.tuple(function (param) {
              
            });
}

Ava("Successfully parses", (function (t) {
        var schema = S.tuple(function (param) {
              
            });
        t.deepEqual(S.parseOrThrow(any, schema), undefined, undefined);
      }));

Ava("Fails to parse extra value in strict mode (default for tuple)", (function (t) {
        var schema = S.tuple(function (param) {
              
            });
        U.assertThrows(t, (function () {
                S.parseOrThrow(invalidAny, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: schema,
                received: invalidAny
              },
              path: S.Path.empty
            });
      }));

Ava("Ignores extra items in strip mode", (function (t) {
        var schema = S.tuple(function (param) {
              
            });
        t.deepEqual(S.parseOrThrow(invalidAny, S.strip(schema)), undefined, undefined);
      }));

Ava("Fails to parse invalid type", (function (t) {
        var schema = S.tuple(function (param) {
              
            });
        U.assertThrows(t, (function () {
                S.parseOrThrow(invalidTypeAny, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: schema,
                received: invalidTypeAny
              },
              path: S.Path.empty
            });
      }));

Ava("Successfully serializes", (function (t) {
        var schema = S.tuple(function (param) {
              
            });
        t.deepEqual(S.reverseConvertOrThrow(undefined, schema), any, undefined);
      }));

var Tuple0 = {
  value: undefined,
  any: any,
  invalidAny: invalidAny,
  invalidTypeAny: invalidTypeAny,
  factory: factory
};

Ava("Fills holes with S.unit", (function (t) {
        var schema = S.tuple(function (s) {
              return [
                      s.item(0, S.string),
                      s.item(2, S.$$int)
                    ];
            });
        U.assertEqualSchemas(t, schema, S.tuple3(S.string, S.unit, S.$$int), undefined);
      }));

Ava("Successfully parses tuple with holes", (function (t) {
        var schema = S.tuple(function (s) {
              return [
                      s.item(0, S.string),
                      s.item(2, S.$$int)
                    ];
            });
        t.deepEqual(S.parseOrThrow((["value",, 123]), schema), [
              "value",
              123
            ], undefined);
      }));

Ava("Fails to parse tuple with holes", (function (t) {
        var schema = S.tuple(function (s) {
              return [
                      s.item(0, S.string),
                      s.item(2, S.$$int)
                    ];
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow(["value", "smth", 123], schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: schema,
                received: ["value", "smth", 123]
              },
              path: S.Path.empty
            });
      }));

Ava("Successfully serializes tuple with holes", (function (t) {
        var schema = S.tuple(function (s) {
              return [
                      s.item(0, S.string),
                      s.item(2, S.$$int)
                    ];
            });
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return [i[\"0\"],e[0],i[\"1\"],]}", undefined);
        t.deepEqual(S.reverseConvertOrThrow([
                  "value",
                  123
                ], schema), (["value",, 123]), undefined);
      }));

Ava("Reverse convert of tuple schema with single item registered multiple times", (function (t) {
        var schema = S.tuple(function (s) {
              var item = s.item(0, S.string);
              return {
                      item1: item,
                      item2: item
                    };
            });
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return [i[\"item2\"],]}", undefined);
        t.deepEqual(S.reverseConvertOrThrow({
                  item1: "foo",
                  item2: "foo"
                }, schema), ["foo"], undefined);
      }));

Ava("Fails to serialize tuple with discriminant \"Never\"", (function (t) {
        var schema = S.tuple(function (s) {
              s.item(0, S.never);
              return s.item(1, S.string);
            });
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow("bar", schema);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "InvalidOperation",
                description: "Schema for [\"0\"] isn\'t registered"
              },
              path: S.Path.empty
            });
      }));

Ava("Fails to serialize tuple with discriminant \"Never\" inside of an object (test path)", (function (t) {
        var schema = S.schema(function (s) {
              return {
                      foo: s.m(S.tuple(function (s) {
                                s.item(0, S.never);
                                return s.item(1, S.string);
                              }))
                    };
            });
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow({
                            foo: "bar"
                          }, schema);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "InvalidOperation",
                description: "Schema for [\"0\"] isn\'t registered"
              },
              path: S.Path.fromLocation("foo")
            });
      }));

Ava("Successfully parses tuple transformed to variant", (function (t) {
        var schema = S.tuple(function (s) {
              return {
                      NAME: "VARIANT",
                      VAL: s.item(0, S.bool)
                    };
            });
        t.deepEqual(S.parseOrThrow([true], schema), {
              NAME: "VARIANT",
              VAL: true
            }, undefined);
      }));

Ava("Successfully serializes tuple transformed to variant", (function (t) {
        var schema = S.tuple(function (s) {
              return {
                      NAME: "VARIANT",
                      VAL: s.item(0, S.bool)
                    };
            });
        t.deepEqual(S.reverseConvertOrThrow({
                  NAME: "VARIANT",
                  VAL: true
                }, schema), [true], undefined);
      }));

Ava("Fails to serialize tuple transformed to variant", (function (t) {
        var schema = S.tuple(function (s) {
              return {
                      TAG: "Ok",
                      _0: s.item(0, S.bool)
                    };
            });
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow({
                            TAG: "Error",
                            _0: "foo"
                          }, schema);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "InvalidType",
                expected: S.literal("Ok"),
                received: "Error"
              },
              path: S.Path.fromLocation("TAG")
            });
      }));

Ava("Fails to create tuple schema with single item defined multiple times", (function (t) {
        t.throws((function () {
                return S.tuple(function (s) {
                            return {
                                    boo: s.item(0, S.string),
                                    zoo: s.item(0, S.$$int)
                                  };
                          });
              }), {
              message: "[Schema] The item [\"0\"] is defined multiple times"
            }, undefined);
      }));

Ava("Tuple schema parsing checks order", (function (t) {
        var schema = S.tuple(function (s) {
              s.tag(1, "value");
              return {
                      key: s.item(0, S.string)
                    };
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow("foo", schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: schema,
                received: "foo"
              },
              path: S.Path.empty
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow(["value"], schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: schema,
                received: ["value"]
              },
              path: S.Path.empty
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow(["value", "value", "value"], S.strict(schema));
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: schema,
                received: ["value", "value", "value"]
              },
              path: S.Path.empty
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow(["value", "wrong"], schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: schema,
                received: ["value", "wrong"]
              },
              path: S.Path.empty
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow([1, "value"], schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.string,
                received: 1
              },
              path: S.Path.fromLocation("0")
            });
        t.deepEqual(S.parseOrThrow(["value", "value"], schema), {
              key: "value"
            }, undefined);
      }));

Ava("Works correctly with not-modified object item", (function (t) {
        var schema = S.tuple1(S.object(function (s) {
                  return s.f("foo", S.string);
                }));
        t.deepEqual(S.parseOrThrow([{"foo": "bar"}], schema), "bar", undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow("bar", schema), [{"foo": "bar"}], undefined);
      }));

Ava("Compiled parse code snapshot for simple tuple", (function (t) {
        var schema = S.tuple(function (s) {
              return [
                      s.item(0, S.string),
                      s.item(1, S.bool)
                    ];
            });
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(!Array.isArray(i)||i.length!==2){e[2](i)}let v0=i[\"0\"],v1=i[\"1\"];if(typeof v0!==\"string\"){e[0](v0)}if(typeof v1!==\"boolean\"){e[1](v1)}return [v0,v1,]}", undefined);
      }));

Ava("Compiled parse code snapshot for simple tuple with async", (function (t) {
        var schema = S.tuple(function (s) {
              return [
                      s.item(0, S.transform(S.unknown, (function (param) {
                                  return {
                                          a: (function (i) {
                                              return Promise.resolve(i);
                                            })
                                        };
                                }))),
                      s.item(1, S.bool)
                    ];
            });
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(!Array.isArray(i)||i.length!==2){e[2](i)}let v0=i[\"1\"];if(typeof v0!==\"boolean\"){e[1](v0)}return Promise.all([e[0](i[\"0\"]),]).then(a=>([a[0],v0,]))}", undefined);
      }));

Ava("Compiled serialize code snapshot for simple tuple", (function (t) {
        var schema = S.tuple(function (s) {
              return [
                      s.item(0, S.string),
                      s.item(1, S.bool)
                    ];
            });
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{return [i[\"0\"],i[\"1\"],]}", undefined);
      }));

Ava("Compiled serialize code snapshot for empty tuple", (function (t) {
        var schema = S.tuple(function (param) {
              
            });
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{if(i!==void 0){e[0](i)}return []}", undefined);
      }));

Ava("Compiled parse code snapshot for simple tuple with transformation, constants and discriminants", (function (t) {
        var schema = S.tuple(function (s) {
              s.tag(0, 0);
              return {
                      foo: s.item(1, S.string),
                      bar: s.item(2, S.bool),
                      zoo: 1
                    };
            });
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(!Array.isArray(i)||i.length!==3||i[\"0\"]!==0){e[3](i)}let v0=i[\"1\"],v1=i[\"2\"];if(typeof v0!==\"string\"){e[0](v0)}if(typeof v1!==\"boolean\"){e[1](v1)}return {\"foo\":v0,\"bar\":v1,\"zoo\":e[2],}}", undefined);
      }));

Ava("Compiled serialize code snapshot for simple tuple with transformation, constants and discriminants", (function (t) {
        var schema = S.tuple(function (s) {
              s.tag(0, 0);
              return {
                      foo: s.item(1, S.string),
                      bar: s.item(2, S.bool),
                      zoo: 1
                    };
            });
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v0=i[\"zoo\"];if(v0!==1){e[0](v0)}return [e[1],i[\"foo\"],i[\"bar\"],]}", undefined);
      }));

var Compiled = {};

Ava("Works with tuple schema used multiple times as a child schema", (function (t) {
        var appVersionSpecSchema = S.tuple(function (s) {
              return {
                      current: s.item(0, S.string),
                      minimum: s.item(1, S.string)
                    };
            });
        var appVersionsSchema = S.object(function (s) {
              return {
                      ios: s.f("ios", appVersionSpecSchema),
                      android: s.f("android", appVersionSpecSchema)
                    };
            });
        var rawAppVersions = {
          ios: [
            "1.1",
            "1.0"
          ],
          android: [
            "1.2",
            "1.1"
          ]
        };
        var appVersions = {
          ios: {
            current: "1.1",
            minimum: "1.0"
          },
          android: {
            current: "1.2",
            minimum: "1.1"
          }
        };
        var value = S.parseOrThrow(rawAppVersions, appVersionsSchema);
        t.deepEqual(value, appVersions, undefined);
        var data = S.reverseConvertToJsonOrThrow(appVersions, appVersionsSchema);
        t.deepEqual(data, rawAppVersions, undefined);
      }));

Ava("Reverse empty tuple schema to literal", (function (t) {
        var schema = S.tuple(function (param) {
              
            });
        U.assertEqualSchemas(t, S.reverse(schema), S.unit, undefined);
      }));

Ava("Succesfully uses reversed empty tuple schema for parsing back to initial value", (function (t) {
        var schema = S.tuple(function (param) {
              
            });
        U.assertReverseParsesBack(t, schema, undefined);
      }));

Ava("Reverse tagged tuple to literal without payload", (function (t) {
        var schema = S.tuple(function (s) {
              s.tag(0, "test");
              return "Test";
            });
        U.assertEqualSchemas(t, S.reverse(schema), S.literal("Test"), undefined);
      }));

Ava("Succesfully uses reversed non-payloaded tagged tuple schema for parsing back to initial value", (function (t) {
        var schema = S.tuple(function (s) {
              s.tag(0, "test");
              return "Test";
            });
        U.assertReverseParsesBack(t, schema, "Test");
      }));

Ava("Reverse tagged tuple to primitive schema", (function (t) {
        var schema = S.tuple(function (s) {
              s.tag(0, "test");
              return s.item(1, S.bool);
            });
        U.assertEqualSchemas(t, S.reverse(schema), S.bool, undefined);
      }));

Ava("Succesfully uses reversed tagged tuple schema with item as output for parsing back to initial value", (function (t) {
        var schema = S.tuple(function (s) {
              s.tag(0, "test");
              return s.item(1, S.bool);
            });
        U.assertReverseParsesBack(t, schema, true);
      }));

export {
  Tuple0 ,
  Compiled ,
}
/*  Not a pure module */

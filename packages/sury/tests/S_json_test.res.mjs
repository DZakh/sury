// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import Ava from "ava";

Ava("Supports String", (function (t) {
        var schema = S.json(true);
        var data = "Foo";
        t.deepEqual(S.parseOrThrow(data, schema), data, undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow(data, schema), data, undefined);
      }));

Ava("Supports Number", (function (t) {
        var schema = S.json(true);
        t.deepEqual(S.parseOrThrow(123, schema), 123, undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow(123, schema), 123, undefined);
      }));

Ava("Supports Bool", (function (t) {
        var schema = S.json(true);
        t.deepEqual(S.parseOrThrow(true, schema), true, undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow(true, schema), true, undefined);
      }));

Ava("Supports Null", (function (t) {
        var schema = S.json(true);
        var data = null;
        t.deepEqual(S.parseOrThrow(data, schema), data, undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow(data, schema), data, undefined);
      }));

Ava("Supports Array", (function (t) {
        var schema = S.json(true);
        var data = [
          "foo",
          null
        ];
        t.deepEqual(S.parseOrThrow(data, schema), data, undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow(data, schema), data, undefined);
      }));

Ava("Supports Object", (function (t) {
        var schema = S.json(true);
        var data = Object.fromEntries([
              [
                "bar",
                "foo"
              ],
              [
                "baz",
                null
              ]
            ]);
        t.deepEqual(S.parseOrThrow(data, schema), data, undefined);
        t.deepEqual(S.reverseConvertToJsonOrThrow(data, schema), data, undefined);
      }));

Ava("Fails to parse Object field", (function (t) {
        var schema = S.json(true);
        var data = Object.fromEntries([
              [
                "bar",
                undefined
              ],
              [
                "baz",
                null
              ]
            ]);
        U.assertThrows(t, (function () {
                return S.parseOrThrow(data, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: schema,
                received: undefined
              },
              path: S.Path.fromLocation("bar")
            });
      }));

Ava("Fails to parse matrix field", (function (t) {
        var schema = S.json(true);
        var data = [1,[undefined]];
        U.assertThrows(t, (function () {
                return S.parseOrThrow(data, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: schema,
                received: undefined
              },
              path: S.Path.fromArray([
                    "1",
                    "0"
                  ])
            });
      }));

Ava("Fails to parse NaN", (function (t) {
        var schema = S.json(true);
        U.assertThrows(t, (function () {
                return S.parseOrThrow(NaN, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: schema,
                received: NaN
              },
              path: S.Path.empty
            });
      }));

Ava("Fails to parse undefined", (function (t) {
        var schema = S.json(true);
        U.assertThrows(t, (function () {
                return S.parseOrThrow(undefined, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: schema,
                received: undefined
              },
              path: S.Path.empty
            });
      }));

Ava("Compiled parse code snapshot", (function (t) {
        var schema = S.json(true);
        U.assertCompiledCode(t, schema, "Parse", "i=>{return e[0](i)}", undefined);
      }));

Ava("Compiled parse code snapshot with validate=false", (function (t) {
        var schema = S.json(false);
        U.assertCompiledCodeIsNoop(t, schema, "Parse", undefined);
      }));

Ava("Compiled serialize code snapshot", (function (t) {
        var schema = S.json(true);
        U.assertCompiledCodeIsNoop(t, schema, "ReverseConvert", undefined);
      }));

Ava("Reverse schema to S.json(~validate=false) with validate=true", (function (t) {
        var schema = S.json(true);
        U.assertEqualSchemas(t, S.reverse(schema), S.json(false), undefined);
      }));

Ava("Succesfully uses reversed schema with validate=true for parsing back to initial value", (function (t) {
        var schema = S.json(true);
        U.assertReverseParsesBack(t, schema, {"foo":"bar"});
      }));

Ava("Reverse schema to self with validate=false", (function (t) {
        var schema = S.json(false);
        t.is(S.reverse(schema), schema, undefined);
      }));

Ava("Succesfully uses reversed schema with validate=false for parsing back to initial value", (function (t) {
        var schema = S.json(false);
        U.assertReverseParsesBack(t, schema, {"foo":"bar"});
      }));

export {
  
}
/*  Not a pure module */

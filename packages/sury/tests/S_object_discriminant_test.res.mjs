// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import Ava from "ava";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function make(discriminantSchema, discriminantData, maybeDescription, param) {
  return {
          discriminantSchema: discriminantSchema,
          discriminantData: discriminantData,
          testNamePostfix: maybeDescription !== undefined ? " " + maybeDescription : ""
        };
}

var TestData = {
  make: make
};

[
    make(S.literal("asdf"), "asdf", "String", undefined),
    make(S.literal("\"\'\`"), "\"\'\`", "String which needs to be escaped", undefined),
    make(S.literal(123), 123, "Int", undefined),
    make(S.literal(1.3), 1.3, "Float", undefined),
    make(S.literal(true), true, "Bool", undefined),
    make(S.literal(), undefined, "Unit", undefined),
    make(S.literal(null), null, "Null", undefined),
    make(S.literal(NaN), NaN, "NaN", undefined),
    make(S.literal([
              false,
              "bar"
            ]), [false, "bar"], "Tuple", undefined),
    make(S.object(function (s) {
              s.f("nestedDiscriminant", S.literal("abc"));
              return {
                      field: s.f("nestedField", S.literal(false))
                    };
            }), {
        "nestedDiscriminant": "abc",
        "nestedField": false
      }, undefined, undefined),
    make(S.object(function (s) {
              s.f("\"\'\`", S.literal("\"\'\`"));
              return {
                      field: s.f("nestedField", S.literal(false))
                    };
            }), {
        "\"\'\`": "\"\'\`",
        "nestedField": false
      }, "and values needed to be escaped", undefined),
    make(S.tuple2(S.literal(false), S.literal("bar")), [false, "bar"], undefined, undefined)
  ].forEach(function (testData) {
      Ava("Successfully parses object with discriminant \"" + S.toExpression(testData.discriminantSchema) + "\"" + testData.testNamePostfix, (function (t) {
              var schema = S.object(function (s) {
                    s.f("discriminant", testData.discriminantSchema);
                    return {
                            field: s.f("field", S.string)
                          };
                  });
              t.deepEqual(S.parseOrThrow({
                        discriminant: testData.discriminantData,
                        field: "bar"
                      }, schema), {
                    field: "bar"
                  }, undefined);
            }));
      Ava("Successfully serializes object with discriminant \"" + S.toExpression(testData.discriminantSchema) + "\"" + testData.testNamePostfix, (function (t) {
              var schema = S.object(function (s) {
                    s.f("discriminant", testData.discriminantSchema);
                    return {
                            field: s.f("field", S.string)
                          };
                  });
              t.deepEqual(S.reverseConvertOrThrow({
                        field: "bar"
                      }, schema), {
                    discriminant: testData.discriminantData,
                    field: "bar"
                  }, undefined);
            }));
    });

var Positive = {
  TestData: TestData
};

function make$1(discriminantSchema, discriminantData, maybeDescription, pathOpt) {
  var path = pathOpt !== undefined ? Caml_option.valFromOption(pathOpt) : S.Path.empty;
  return {
          discriminantSchema: discriminantSchema,
          discriminantData: discriminantData,
          testNamePostfix: maybeDescription !== undefined ? " " + maybeDescription : "",
          path: path
        };
}

var TestData$1 = {
  make: make$1
};

[
    make$1(S.string, "foo", undefined, undefined),
    make$1(S.$$int, 123, undefined, undefined),
    make$1(S.$$float, 123, undefined, undefined),
    make$1(S.bool, true, undefined, undefined),
    make$1(S.option(S.literal(true)), undefined, undefined, undefined),
    make$1(S.$$null(S.literal(true)), null, undefined, undefined),
    make$1(S.unknown, "anything", undefined, undefined),
    make$1(S.array(S.literal(true)), [
          true,
          true
        ], undefined, undefined),
    make$1(S.dict(S.literal(true)), Object.fromEntries([
              [
                "foo",
                true
              ],
              [
                "bar",
                true
              ]
            ]), undefined, undefined),
    make$1(S.tuple2(S.literal(true), S.bool), [
          true,
          false
        ], undefined, Caml_option.some(S.Path.fromLocation("1"))),
    make$1(S.union([
              S.bool,
              S.literal(false)
            ]), true, undefined, undefined),
    make$1(S.union([
              S.literal(false),
              S.bool
            ]), false, undefined, undefined)
  ].forEach(function (testData) {
      Ava("Successfully parses object with discriminant that we don't know how to serialize \"" + S.toExpression(testData.discriminantSchema) + "\"" + testData.testNamePostfix, (function (t) {
              var schema = S.object(function (s) {
                    s.f("discriminant", testData.discriminantSchema);
                    return {
                            field: s.f("field", S.string)
                          };
                  });
              t.deepEqual(S.parseOrThrow({
                        discriminant: testData.discriminantData,
                        field: "bar"
                      }, schema), {
                    field: "bar"
                  }, undefined);
            }));
      Ava("Fails to serialize object with discriminant that we don't know how to serialize \"" + S.toExpression(testData.discriminantSchema) + "\"" + testData.testNamePostfix, (function (t) {
              var schema = S.object(function (s) {
                    s.f("discriminant", testData.discriminantSchema);
                    return {
                            field: s.f("field", S.string)
                          };
                  });
              U.assertThrows(t, (function () {
                      return S.reverseConvertOrThrow({
                                  field: "bar"
                                }, schema);
                    }), {
                    operation: "ReverseConvert",
                    code: {
                      TAG: "InvalidOperation",
                      description: "Schema for [\"discriminant\"]" + testData.path + " isn\'t registered"
                    },
                    path: S.Path.empty
                  });
            }));
    });

var Negative = {
  TestData: TestData$1
};

Ava("Successfully parses object with discriminant object that we don't know how to serialize", (function (t) {
        var schema = S.object(function (s) {
              s.f("discriminant", S.object(function (s) {
                        return s.f("field", S.bool);
                      }));
              return {
                      field: s.f("field", S.string)
                    };
            });
        t.deepEqual(S.parseOrThrow({
                  discriminant: {
                    field: true
                  },
                  field: "bar"
                }, schema), {
              field: "bar"
            }, undefined);
      }));

Ava("Fails to serialize object with object discriminant that we don't know how to serialize", (function (t) {
        var schema = S.object(function (s) {
              s.f("discriminant", S.object(function (s) {
                        return s.f("nestedField", S.bool);
                      }));
              return {
                      field: s.f("field", S.string)
                    };
            });
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow({
                            field: "bar"
                          }, schema);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "InvalidOperation",
                description: "Schema for [\"discriminant\"] isn\'t registered"
              },
              path: S.Path.empty
            });
      }));

var NestedNegative = {};

Ava("Fails to parse object with invalid data passed to discriminant field", (function (t) {
        var schema = S.object(function (s) {
              s.f("discriminant", S.string);
              return {
                      field: s.f("field", S.string)
                    };
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow({
                            discriminant: false,
                            field: "bar"
                          }, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.string,
                received: false
              },
              path: S.Path.fromArray(["discriminant"])
            });
      }));

Ava("Parses discriminant fields before registered fields", (function (t) {
        var schema = S.object(function (s) {
              s.f("discriminant", S.string);
              return {
                      field: s.f("field", S.string)
                    };
            });
        U.assertThrows(t, (function () {
                return S.parseOrThrow({
                            discriminant: false,
                            field: false
                          }, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: S.string,
                received: false
              },
              path: S.Path.fromArray(["discriminant"])
            });
      }));

Ava("Fails to serialize object with discriminant \"Never\"", (function (t) {
        var schema = S.object(function (s) {
              s.f("discriminant", S.never);
              return {
                      field: s.f("field", S.string)
                    };
            });
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow({
                            field: "bar"
                          }, schema);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "InvalidOperation",
                description: "Schema for [\"discriminant\"] isn\'t registered"
              },
              path: S.Path.empty
            });
      }));

Ava("Serializes constant fields before registered non-literal fields", (function (t) {
        var schema = S.object(function (s) {
              return {
                      literalField: s.f("field", S.literal(true)),
                      constant: true
                    };
            });
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow({
                            constant: false,
                            literalField: false
                          }, schema);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "InvalidType",
                expected: S.literal(true),
                received: false
              },
              path: S.Path.fromArray(["constant"])
            });
        var schema$1 = S.object(function (s) {
              return {
                      boolField: s.f("field", S.bool),
                      constant: true
                    };
            });
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow({
                            constant: false,
                            boolField: false
                          }, schema$1);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "InvalidType",
                expected: S.literal(true),
                received: false
              },
              path: S.Path.fromArray(["constant"])
            });
      }));

export {
  Positive ,
  Negative ,
  NestedNegative ,
}
/*  Not a pure module */

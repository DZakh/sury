// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import * as Ava from "ava";
import Ava$1 from "ava";

Ava$1("Expression of primitive schema", (function (t) {
        t.deepEqual(S.toExpression(S.string), "string", undefined);
      }));

Ava$1("Expression of primitive schema with name", (function (t) {
        t.deepEqual(S.toExpression(S.meta(S.string, {
                      name: "Address"
                    })), "Address", undefined);
      }));

Ava$1("Expression of Literal schema", (function (t) {
        t.deepEqual(S.toExpression(S.literal(123)), "123", undefined);
      }));

Ava$1("Expression of Literal object schema", (function (t) {
        t.deepEqual(S.toExpression(S.literal({
                      abc: 123
                    })), "{ abc: 123; }", undefined);
      }));

Ava$1("Expression of Literal array schema", (function (t) {
        t.deepEqual(S.toExpression(S.literal([
                      123,
                      "abc"
                    ])), "[123, \"abc\"]", undefined);
      }));

Ava$1("Expression of Array schema", (function (t) {
        t.deepEqual(S.toExpression(S.array(S.string)), "string[]", undefined);
      }));

Ava$1("Expression of Unnest schema", (function (t) {
        t.deepEqual(S.toExpression(S.unnest(S.schema(function (s) {
                          return {
                                  foo: s.m(S.string),
                                  bar: s.m(S.$$int)
                                };
                        }))), "[string[], int32[]]", undefined);
      }));

Ava$1("Expression of reversed Unnest schema", (function (t) {
        t.deepEqual(S.toExpression(S.reverse(S.unnest(S.schema(function (s) {
                              return {
                                      foo: s.m(S.string),
                                      bar: s.m(S.$$int)
                                    };
                            })))), "{ foo: string; bar: int32; }[]", undefined);
      }));

Ava$1("Expression of Array schema with optional items", (function (t) {
        t.deepEqual(S.toExpression(S.array(S.option(S.string))), "(string | undefined)[]", undefined);
      }));

Ava$1("Expression of Dict schema", (function (t) {
        t.deepEqual(S.toExpression(S.dict(S.string)), "{ [key: string]: string; }", undefined);
      }));

Ava$1("Expression of Option schema", (function (t) {
        t.deepEqual(S.toExpression(S.option(S.string)), "string | undefined", undefined);
      }));

Ava$1("Expression of Option schema with name", (function (t) {
        t.deepEqual(S.toExpression(S.meta(S.option(S.meta(S.string, {
                              name: "Nested"
                            })), {
                      name: "EnvVar"
                    })), "EnvVar", undefined);
      }));

Ava$1("Expression of Null schema", (function (t) {
        t.deepEqual(S.toExpression(S.$$null(S.string)), "string | null", undefined);
      }));

Ava$1("Expression of Union schema", (function (t) {
        t.deepEqual(S.toExpression(S.union([
                      S.string,
                      S.literal("foo")
                    ])), "string | \"foo\"", undefined);
      }));

Ava$1("Expression of Union schema with duplicated items", (function (t) {
        t.deepEqual(S.toExpression(S.union([
                      S.literal("foo"),
                      S.string,
                      S.literal("foo")
                    ])), "\"foo\" | string | \"foo\"", undefined);
      }));

Ava$1("Expression of Object schema", (function (t) {
        t.deepEqual(S.toExpression(S.object(function (s) {
                      return {
                              foo: s.f("foo", S.string),
                              bar: s.f("bar", S.$$int)
                            };
                    })), "{ foo: string; bar: int32; }", undefined);
      }));

Ava$1("Expression of empty Object schema", (function (t) {
        t.deepEqual(S.toExpression(S.object(function (param) {
                      
                    })), "{}", undefined);
      }));

Ava$1("Expression of Tuple schema", (function (t) {
        t.deepEqual(S.toExpression(S.tuple(function (s) {
                      return {
                              foo: s.item(0, S.string),
                              bar: s.item(1, S.$$int)
                            };
                    })), "[string, int32]", undefined);
      }));

Ava$1("Expression of custom schema", (function (t) {
        t.deepEqual(S.toExpression(S.custom("Test", (function (s) {
                        return s.fail("User error", undefined);
                      }))), "Test", undefined);
      }));

Ava.default.failing("Expression of renamed schema", (function (t) {
        var renamedSchema = S.meta(S.never, {
              name: "Ethers.BigInt"
            });
        t.deepEqual(S.toExpression(S.never), "never", undefined);
        t.deepEqual(S.toExpression(renamedSchema), "Ethers.BigInt", undefined);
        U.assertThrows(t, (function () {
                return S.parseOrThrow("smth", renamedSchema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: renamedSchema,
                received: "smth"
              },
              path: S.Path.empty
            });
        t.is(U.error({
                  operation: "Parse",
                  code: {
                    TAG: "InvalidType",
                    expected: renamedSchema,
                    received: "smth"
                  },
                  path: S.Path.empty
                }).message, "Failed parsing: Expected Ethers.BigInt, received \"smth\"", undefined);
        var schema = S.meta(S.$$null(S.never), {
              name: "Ethers.BigInt"
            });
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{try{e[0](i);}catch(e0){if(i===void 0){i=null}}return i}", undefined);
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow("smth", S.meta(S.$$null(S.never), {
                                name: "Ethers.BigInt"
                              }));
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "InvalidType",
                expected: S.never,
                received: "smth"
              },
              path: S.Path.empty
            });
      }));

export {
  
}
/*  Not a pure module */

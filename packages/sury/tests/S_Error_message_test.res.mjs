// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import Ava from "ava";

Ava("OperationFailed error", (function (t) {
        t.is(U.error({
                  operation: "Parse",
                  code: {
                    TAG: "OperationFailed",
                    _0: "Should be positive"
                  },
                  path: S.Path.empty
                }).message, "Failed parsing: Should be positive", undefined);
      }));

Ava("Error with Serializing operation", (function (t) {
        t.is(U.error({
                  operation: "ReverseConvert",
                  code: {
                    TAG: "OperationFailed",
                    _0: "Should be positive"
                  },
                  path: S.Path.empty
                }).message, "Failed converting: Should be positive", undefined);
      }));

Ava("Error with path", (function (t) {
        t.is(U.error({
                  operation: "Parse",
                  code: {
                    TAG: "OperationFailed",
                    _0: "Should be positive"
                  },
                  path: S.Path.fromArray([
                        "0",
                        "foo"
                      ])
                }).message, "Failed parsing at [\"0\"][\"foo\"]: Should be positive", undefined);
      }));

Ava("InvalidOperation error", (function (t) {
        t.is(U.error({
                  operation: "Parse",
                  code: {
                    TAG: "InvalidOperation",
                    description: "The S.transform serializer is missing"
                  },
                  path: S.Path.empty
                }).message, "Failed parsing: The S.transform serializer is missing", undefined);
      }));

Ava("InvalidType error", (function (t) {
        t.is(U.error({
                  operation: "Parse",
                  code: {
                    TAG: "InvalidType",
                    expected: S.string,
                    received: true
                  },
                  path: S.Path.empty
                }).message, "Failed parsing: Expected string, received true", undefined);
      }));

Ava("UnexpectedAsync error", (function (t) {
        t.is(U.error({
                  operation: "Parse",
                  code: "UnexpectedAsync",
                  path: S.Path.empty
                }).message, "Failed parsing: Encountered unexpected async transform or refine. Use parseAsyncOrThrow operation instead", undefined);
      }));

Ava("InvalidType with literal error", (function (t) {
        t.is(U.error({
                  operation: "Parse",
                  code: {
                    TAG: "InvalidType",
                    expected: S.literal(false),
                    received: true
                  },
                  path: S.Path.empty
                }).message, "Failed parsing: Expected false, received true", undefined);
      }));

Ava("ExcessField error", (function (t) {
        t.is(U.error({
                  operation: "Parse",
                  code: {
                    TAG: "ExcessField",
                    _0: "unknownKey"
                  },
                  path: S.Path.empty
                }).message, "Failed parsing: Unrecognized key \"unknownKey\"", undefined);
      }));

Ava("InvalidType error (replacement for InvalidTupleSize)", (function (t) {
        t.is(U.error({
                  operation: "Parse",
                  code: {
                    TAG: "InvalidType",
                    expected: S.tuple2(S.bool, S.$$int),
                    received: [
                      1,
                      2,
                      "foo"
                    ]
                  },
                  path: S.Path.empty
                }).message, "Failed parsing: Expected [boolean, int32], received [1, 2, \"foo\"]", undefined);
      }));

Ava("InvalidType error with union errors", (function (t) {
        t.is(U.error({
                  operation: "Parse",
                  code: {
                    TAG: "InvalidType",
                    expected: S.unknown,
                    received: "foo",
                    unionErrors: [
                      U.error({
                            operation: "Parse",
                            code: {
                              TAG: "InvalidType",
                              expected: S.literal("circle"),
                              received: "oval"
                            },
                            path: S.Path.fromArray(["kind"])
                          }),
                      U.error({
                            operation: "Parse",
                            code: {
                              TAG: "InvalidType",
                              expected: S.literal("square"),
                              received: "oval"
                            },
                            path: S.Path.fromArray(["kind"])
                          }),
                      U.error({
                            operation: "Parse",
                            code: {
                              TAG: "InvalidType",
                              expected: S.literal("triangle"),
                              received: "oval"
                            },
                            path: S.Path.fromArray(["kind"])
                          })
                    ]
                  },
                  path: S.Path.empty
                }).message, "Failed parsing: Expected unknown, received \"foo\"\n- At [\"kind\"]: Expected \"circle\", received \"oval\"\n- At [\"kind\"]: Expected \"square\", received \"oval\"\n- At [\"kind\"]: Expected \"triangle\", received \"oval\"", undefined);
      }));

Ava("InvalidUnion filters similar reasons", (function (t) {
        t.is(U.error({
                  operation: "Parse",
                  code: {
                    TAG: "InvalidType",
                    expected: S.unknown,
                    received: "foo",
                    unionErrors: [
                      U.error({
                            operation: "Parse",
                            code: {
                              TAG: "InvalidType",
                              expected: S.bool,
                              received: "Hello world!"
                            },
                            path: S.Path.empty
                          }),
                      U.error({
                            operation: "Parse",
                            code: {
                              TAG: "InvalidType",
                              expected: S.bool,
                              received: "Hello world!"
                            },
                            path: S.Path.empty
                          }),
                      U.error({
                            operation: "Parse",
                            code: {
                              TAG: "InvalidType",
                              expected: S.bool,
                              received: "Hello world!"
                            },
                            path: S.Path.empty
                          })
                    ]
                  },
                  path: S.Path.empty
                }).message, "Failed parsing: Expected unknown, received \"foo\"\n- Expected boolean, received \"Hello world!\"", undefined);
      }));

Ava("Nested InvalidUnion error", (function (t) {
        t.is(U.error({
                  operation: "Parse",
                  code: {
                    TAG: "InvalidType",
                    expected: S.unknown,
                    received: "foo",
                    unionErrors: [U.error({
                            operation: "Parse",
                            code: {
                              TAG: "InvalidType",
                              expected: S.bool,
                              received: "foo",
                              unionErrors: [
                                U.error({
                                      operation: "Parse",
                                      code: {
                                        TAG: "InvalidType",
                                        expected: S.bool,
                                        received: "Hello world!"
                                      },
                                      path: S.Path.empty
                                    }),
                                U.error({
                                      operation: "Parse",
                                      code: {
                                        TAG: "InvalidType",
                                        expected: S.bool,
                                        received: "Hello world!"
                                      },
                                      path: S.Path.empty
                                    }),
                                U.error({
                                      operation: "Parse",
                                      code: {
                                        TAG: "InvalidType",
                                        expected: S.bool,
                                        received: "Hello world!"
                                      },
                                      path: S.Path.empty
                                    })
                              ]
                            },
                            path: S.Path.empty
                          })]
                  },
                  path: S.Path.empty
                }).message, "Failed parsing: Expected unknown, received \"foo\"\n- Expected boolean, received \"foo\"\n  - Expected boolean, received \"Hello world!\"", undefined);
      }));

Ava("InvalidJsonSchema error", (function (t) {
        t.is(U.error({
                  operation: "ReverseConvert",
                  code: {
                    TAG: "InvalidJsonSchema",
                    _0: S.option(S.literal(true))
                  },
                  path: S.Path.empty
                }).message, "Failed converting: The 'true | undefined' schema cannot be converted to JSON", undefined);
      }));

export {
  
}
/*  Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import Ava from "ava";
import * as Core__Int from "@rescript/core/src/Core__Int.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

Ava("Throws for a Union schema factory without schemas", (function (t) {
        t.throws((function () {
                return S.union([]);
              }), {
              message: "[Schema] S.union requires at least one item"
            }, undefined);
      }));

Ava("Successfully creates a Union schema factory with single schema and flattens it", (function (t) {
        var schema = S.union([S.string]);
        U.assertEqualSchemas(t, schema, S.string, undefined);
      }));

Ava("Successfully parses polymorphic variants", (function (t) {
        var schema = S.union([
              S.literal("apple"),
              S.literal("orange")
            ]);
        t.deepEqual(S.parseOrThrow("apple", schema), "apple", undefined);
      }));

Ava("Parses when both schemas misses parser and have the same type", (function (t) {
        var schema = S.union([
              S.transform(S.string, (function (param) {
                      return {
                              s: (function (param) {
                                  return "apple";
                                })
                            };
                    })),
              S.transform(S.string, (function (param) {
                      return {
                              s: (function (param) {
                                  return "apple";
                                })
                            };
                    }))
            ]);
        try {
          S.parseOrThrow(null, schema);
          t.fail("Expected to throw");
        }
        catch (raw_error){
          var error = Caml_js_exceptions.internalToOCamlException(raw_error);
          if (error.RE_EXN_ID === S.$$Error) {
            t.is(error._1.message, "Failed parsing: Expected string | string, received null", undefined);
          } else {
            throw error;
          }
        }
        try {
          S.parseOrThrow("foo", schema);
          t.fail("Expected to throw");
        }
        catch (raw_error$1){
          var error$1 = Caml_js_exceptions.internalToOCamlException(raw_error$1);
          if (error$1.RE_EXN_ID === S.$$Error) {
            t.is(error$1._1.message, "Failed parsing: Expected string | string, received \"foo\"\n- The S.transform parser is missing", undefined);
          } else {
            throw error$1;
          }
        }
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i===\"string\"){try{throw e[0]}catch(e0){try{throw e[1]}catch(e1){e[2](i,e0,e1)}}}else{e[3](i)}return i}", undefined);
      }));

Ava("Parses when both schemas misses parser and have different types", (function (t) {
        var schema = S.union([
              S.transform(S.literal("apple"), (function (param) {
                      return {
                              s: (function (param) {
                                  return "apple";
                                })
                            };
                    })),
              S.transform(S.string, (function (param) {
                      return {
                              s: (function (param) {
                                  return "apple";
                                })
                            };
                    }))
            ]);
        try {
          S.parseOrThrow(null, schema);
          t.fail("Expected to throw");
        }
        catch (raw_error){
          var error = Caml_js_exceptions.internalToOCamlException(raw_error);
          if (error.RE_EXN_ID === S.$$Error) {
            t.is(error._1.message, "Failed parsing: Expected \"apple\" | string, received null", undefined);
          } else {
            throw error;
          }
        }
        try {
          S.parseOrThrow("abc", schema);
          t.fail("Expected to throw");
        }
        catch (raw_error$1){
          var error$1 = Caml_js_exceptions.internalToOCamlException(raw_error$1);
          if (error$1.RE_EXN_ID === S.$$Error) {
            t.is(error$1._1.message, "Failed parsing: Expected \"apple\" | string, received \"abc\"\n- The S.transform parser is missing", undefined);
          } else {
            throw error$1;
          }
        }
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i===\"string\"){if(i===\"apple\"){throw e[0]}try{throw e[1]}catch(e1){e[2](i,e1)}}else{e[3](i)}return i}", undefined);
      }));

Ava("Serializes when both schemas misses serializer", (function (t) {
        var schema = S.union([
              S.transform(S.literal("apple"), (function (param) {
                      return {
                              p: (function (param) {
                                  return "apple";
                                })
                            };
                    })),
              S.transform(S.string, (function (param) {
                      return {
                              p: (function (param) {
                                  return "apple";
                                })
                            };
                    }))
            ]);
        try {
          S.reverseConvertOrThrow(null, schema);
          t.fail("Expected to throw");
        }
        catch (raw_error){
          var error = Caml_js_exceptions.internalToOCamlException(raw_error);
          if (error.RE_EXN_ID === S.$$Error) {
            t.is(error._1.message, "Failed converting: Expected unknown | unknown, received null\n- The S.transform serializer is missing", undefined);
          } else {
            throw error;
          }
        }
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{try{throw e[0]}catch(e0){try{throw e[1]}catch(e1){e[2](i,e0,e1)}}return i}", undefined);
      }));

Ava("When union of json and string schemas, should parse the first one", (function (t) {
        var schema = S.union([
              S.shape(S.json(false), (function (param) {
                      return "json";
                    })),
              S.shape(S.string, (function (param) {
                      return "str";
                    }))
            ]);
        t.deepEqual(S.parseOrThrow("string", schema), "json", undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{try{i=e[0]}catch(e0){if(typeof i===\"string\"){i=e[1]}else{e[2](i,e0)}}return i}", undefined);
      }));

Ava("Ensures parsing order with unknown schema", (function (t) {
        var schema = S.union([
              S.length(S.string, 2, undefined),
              S.bool,
              S.custom("unknown string", (function (param) {
                      return {
                              p: (function (param) {
                                  return "pass";
                                })
                            };
                    })),
              S.$$float,
              S.bigint
            ]);
        t.deepEqual(S.parseOrThrow("string", schema), "pass", undefined);
        t.deepEqual(S.parseOrThrow("to", schema), "to", undefined);
        t.deepEqual(S.parseOrThrow(true, schema), true, undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{try{if(typeof i!==\"string\"){e[0](i)}if(i.length!==e[1]){e[2]()}}catch(e0){try{if(typeof i!==\"boolean\"){e[3](i)}}catch(e1){try{i=e[4](i)}catch(e2){if(!(typeof i===\"number\"&&!Number.isNaN(i)||typeof i===\"bigint\")){e[5](i,e0,e1,e2)}}}}return i}", undefined);
      }));

Ava("Parses when second schema misses parser", (function (t) {
        var schema = S.union([
              S.literal("apple"),
              S.transform(S.string, (function (param) {
                      return {
                              s: (function (param) {
                                  return "apple";
                                })
                            };
                    }))
            ]);
        t.deepEqual(S.parseOrThrow("apple", schema), "apple", undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i===\"string\"){if(!(i===\"apple\")){try{throw e[0]}catch(e1){e[1](i,e1)}}}else{e[2](i)}return i}", undefined);
      }));

Ava("Serializes when second struct misses serializer", (function (t) {
        var schema = S.union([
              S.literal("apple"),
              S.transform(S.string, (function (param) {
                      return {
                              p: (function (param) {
                                  return "apple";
                                })
                            };
                    }))
            ]);
        t.deepEqual(S.reverseConvertOrThrow("apple", schema), "apple", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{try{if(i!==\"apple\"){e[0](i)}}catch(e0){try{throw e[1]}catch(e1){e[2](i,e0,e1)}}return i}", undefined);
      }));

var circleSchema = S.object(function (s) {
      s.tag("kind", "circle");
      return {
              TAG: "Circle",
              radius: s.f("radius", S.$$float)
            };
    });

var squareSchema = S.object(function (s) {
      s.tag("kind", "square");
      return {
              TAG: "Square",
              x: s.f("x", S.$$float)
            };
    });

var triangleSchema = S.object(function (s) {
      s.tag("kind", "triangle");
      return {
              TAG: "Triangle",
              x: s.f("x", S.$$float),
              y: s.f("y", S.$$float)
            };
    });

var shapeSchema = S.union([
      circleSchema,
      squareSchema,
      triangleSchema
    ]);

Ava("Successfully parses Circle shape", (function (t) {
        t.deepEqual(S.parseOrThrow({
      "kind": "circle",
      "radius": 1,
    }, shapeSchema), {
              TAG: "Circle",
              radius: 1
            }, undefined);
      }));

Ava("Successfully parses Square shape", (function (t) {
        t.deepEqual(S.parseOrThrow({
      "kind": "square",
      "x": 2,
    }, shapeSchema), {
              TAG: "Square",
              x: 2
            }, undefined);
      }));

Ava("Successfully parses Triangle shape", (function (t) {
        t.deepEqual(S.parseOrThrow({
      "kind": "triangle",
      "x": 2,
      "y": 3,
    }, shapeSchema), {
              TAG: "Triangle",
              x: 2,
              y: 3
            }, undefined);
      }));

Ava("Fails to parse with unknown kind", (function (t) {
        var shape = {
      "kind": "oval",
      "x": 2,
      "y": 3,
    };
        var error_code = {
          TAG: "InvalidType",
          expected: shapeSchema,
          received: shape
        };
        var error_path = S.Path.empty;
        var error = {
          operation: "Parse",
          code: error_code,
          path: error_path
        };
        U.assertThrows(t, (function () {
                return S.parseOrThrow(shape, shapeSchema);
              }), error);
      }));

Ava("Fails to parse with unknown kind when the union is an object field", (function (t) {
        var schema = S.object(function (s) {
              return s.f("field", shapeSchema);
            });
        var shape = {
          kind: "oval",
          x: 2,
          y: 3
        };
        var data = {
          field: shape
        };
        var error_code = {
          TAG: "InvalidType",
          expected: shapeSchema,
          received: shape
        };
        var error_path = S.Path.fromLocation("field");
        var error = {
          operation: "Parse",
          code: error_code,
          path: error_path
        };
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[9](i)}let v0=i[\"field\"];if(typeof v0===\"object\"&&v0){if(v0[\"kind\"]===\"circle\"){let v1=v0[\"radius\"];if(typeof v1!==\"number\"||Number.isNaN(v1)){e[0](v1)}v0={\"TAG\":e[1],\"radius\":v1,}}else if(v0[\"kind\"]===\"square\"){let v2=v0[\"x\"];if(typeof v2!==\"number\"||Number.isNaN(v2)){e[2](v2)}v0={\"TAG\":e[3],\"x\":v2,}}else if(v0[\"kind\"]===\"triangle\"){let v3=v0[\"x\"],v4=v0[\"y\"];if(typeof v3!==\"number\"||Number.isNaN(v3)){e[4](v3)}if(typeof v4!==\"number\"||Number.isNaN(v4)){e[5](v4)}v0={\"TAG\":e[6],\"x\":v3,\"y\":v4,}}else{e[7](v0)}}else{e[8](v0)}return v0}", undefined);
        U.assertThrows(t, (function () {
                return S.parseOrThrow(data, schema);
              }), error);
        t.is(U.error(error).message, "Failed parsing at [\"field\"]: Expected { kind: \"circle\"; radius: number; } | { kind: \"square\"; x: number; } | { kind: \"triangle\"; x: number; y: number; }, received {\"kind\": \"oval\", \"x\": 2, \"y\": 3}", undefined);
      }));

Ava("Fails to parse with invalid data type", (function (t) {
        U.assertThrows(t, (function () {
                return S.parseOrThrow("Hello world!", shapeSchema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: shapeSchema,
                received: "Hello world!"
              },
              path: S.Path.empty
            });
      }));

Ava("Passes through not defined item on converting without type validation", (function (t) {
        var incompleteSchema = S.union([
              S.object(function (s) {
                    s.tag("kind", "circle");
                    return {
                            TAG: "Circle",
                            radius: s.f("radius", S.$$float)
                          };
                  }),
              S.object(function (s) {
                    s.tag("kind", "square");
                    return {
                            TAG: "Square",
                            x: s.f("x", S.$$float)
                          };
                  })
            ]);
        var v = {
          TAG: "Triangle",
          x: 2,
          y: 3
        };
        t.is(S.reverseConvertOrThrow(v, incompleteSchema), v, undefined);
      }));

Ava("Successfully serializes Circle shape", (function (t) {
        t.deepEqual(S.reverseConvertOrThrow({
                  TAG: "Circle",
                  radius: 1
                }, shapeSchema), {
          "kind": "circle",
          "radius": 1,
        }, undefined);
      }));

Ava("Successfully serializes Square shape", (function (t) {
        t.deepEqual(S.reverseConvertOrThrow({
                  TAG: "Square",
                  x: 2
                }, shapeSchema), {
        "kind": "square",
        "x": 2,
      }, undefined);
      }));

Ava("Successfully serializes Triangle shape", (function (t) {
        t.deepEqual(S.reverseConvertOrThrow({
                  TAG: "Triangle",
                  x: 2,
                  y: 3
                }, shapeSchema), {
        "kind": "triangle",
        "x": 2,
        "y": 3,
      }, undefined);
      }));

Ava("Compiled parse code snapshot of shape schema", (function (t) {
        U.assertCompiledCode(t, shapeSchema, "Parse", "i=>{if(typeof i===\"object\"&&i){if(i[\"kind\"]===\"circle\"){let v0=i[\"radius\"];if(typeof v0!==\"number\"||Number.isNaN(v0)){e[0](v0)}i={\"TAG\":e[1],\"radius\":v0,}}else if(i[\"kind\"]===\"square\"){let v1=i[\"x\"];if(typeof v1!==\"number\"||Number.isNaN(v1)){e[2](v1)}i={\"TAG\":e[3],\"x\":v1,}}else if(i[\"kind\"]===\"triangle\"){let v2=i[\"x\"],v3=i[\"y\"];if(typeof v2!==\"number\"||Number.isNaN(v2)){e[4](v2)}if(typeof v3!==\"number\"||Number.isNaN(v3)){e[5](v3)}i={\"TAG\":e[6],\"x\":v2,\"y\":v3,}}else{e[7](i)}}else{e[8](i)}return i}", undefined);
      }));

Ava("Compiled serialize code snapshot of shape schema", (function (t) {
        U.assertCompiledCode(t, shapeSchema, "ReverseConvert", "i=>{if(typeof i===\"object\"&&i){if(i[\"TAG\"]===\"Circle\"){let v0=i[\"TAG\"];if(v0!==\"Circle\"){e[0](v0)}i={\"kind\":e[1],\"radius\":i[\"radius\"],}}else if(i[\"TAG\"]===\"Square\"){let v1=i[\"TAG\"];if(v1!==\"Square\"){e[2](v1)}i={\"kind\":e[3],\"x\":i[\"x\"],}}else if(i[\"TAG\"]===\"Triangle\"){let v2=i[\"TAG\"];if(v2!==\"Triangle\"){e[4](v2)}i={\"kind\":e[5],\"x\":i[\"x\"],\"y\":i[\"y\"],}}}return i}", undefined);
      }));

var Advanced = {
  circleSchema: circleSchema,
  squareSchema: squareSchema,
  triangleSchema: triangleSchema,
  shapeSchema: shapeSchema
};

Ava("Successfully serializes unboxed variant", (function (t) {
        var toInt = S.shape(S.transform(S.string, (function (param) {
                    return {
                            p: (function (string) {
                                return Core__Option.getExn(Core__Int.fromString(string, undefined), undefined);
                              }),
                            s: (function (__x) {
                                return __x.toString();
                              })
                          };
                  })), (function (i) {
                return i;
              }));
        var toString = S.shape(S.string, (function (s) {
                return s;
              }));
        var schema = S.union([
              toInt,
              toString
            ]);
        t.deepEqual(S.parseOrThrow("123", schema), 123, undefined);
        t.deepEqual(S.reverseConvertOrThrow("abc", schema), "abc", undefined);
        t.deepEqual(S.reverseConvertOrThrow(123, schema), "123", undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i===\"string\"){try{i=e[0](i)}catch(e0){e[1](i,e0)}}else{e[2](i)}return i}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{try{let v0=e[0](i);if(typeof v0!==\"string\"){e[1](v0)}i=v0}catch(e0){}return i}", undefined);
        var schema$1 = S.union([
              toString,
              toInt
            ]);
        t.deepEqual(S.parseOrThrow("123", schema$1), "123", undefined);
        t.deepEqual(S.reverseConvertOrThrow("abc", schema$1), "abc", undefined);
        t.deepEqual(S.reverseConvertOrThrow(123, schema$1), "123", undefined);
        U.assertCompiledCode(t, schema$1, "Parse", "i=>{if(!(typeof i===\"string\")){e[0](i)}return i}", undefined);
        U.assertCompiledCode(t, schema$1, "ReverseConvert", "i=>{try{if(typeof i!==\"string\"){e[0](i)}}catch(e0){try{let v0=e[1](i);if(typeof v0!==\"string\"){e[2](v0)}i=v0}catch(e1){e[3](i,e0,e1)}}return i}", undefined);
      }));

Ava("Compiled parse code snapshot", (function (t) {
        var schema = S.union([
              S.literal(0),
              S.literal(1)
            ]);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(!(typeof i===\"number\"&&(i===0||i===1))){e[0](i)}return i}", undefined);
        U.assertCompiledCode(t, schema, "ReverseParse", "i=>{if(!(typeof i===\"number\"&&(i===0||i===1))){e[0](i)}return i}", undefined);
        U.assertCompiledCodeIsNoop(t, schema, "Convert", undefined);
        U.assertCompiledCodeIsNoop(t, schema, "ReverseConvert", undefined);
      }));

Ava("Compiled async parse code snapshot", (async function (t) {
        var schema = S.union([
              S.transform(S.literal(0), (function (param) {
                      return {
                              a: (function (i) {
                                  return Promise.resolve(i);
                                })
                            };
                    })),
              S.literal(1)
            ]);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i===\"number\"){if(i===0){i=e[0](i)}else if(!(i===1)){e[1](i)}}else{e[2](i)}return Promise.resolve(i)}", undefined);
        U.assertCompiledCode(t, schema, "ConvertAsync", "i=>{if(typeof i===\"number\"){if(i===0){i=e[0](i)}}return Promise.resolve(i)}", undefined);
        t.deepEqual(await S.parseAsyncOrThrow(1, schema), 1, undefined);
        t.throws((function () {
                return S.parseAsyncOrThrow(2, schema);
              }), {
              message: "Failed async parsing: Expected 0 | 1, received 2"
            }, undefined);
      }));

Ava("Union with nested variant", (function (t) {
        var schema = S.union([
              S.schema(function (s) {
                    return {
                            foo: {
                              tag: {
                                NAME: "Null",
                                VAL: s.m(S.$$null(S.string))
                              }
                            }
                          };
                  }),
              S.schema(function (s) {
                    return {
                            foo: {
                              tag: {
                                NAME: "Option",
                                VAL: s.m(S.option(S.string))
                              }
                            }
                          };
                  })
            ]);
        t.deepEqual(S.reverseConvertOrThrow({
                  foo: {
                    tag: {
                      NAME: "Null",
                      VAL: undefined
                    }
                  }
                }, schema), {"foo":{"tag":{"NAME":"Null","VAL":null}}}, undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{if(typeof i===\"object\"&&i){try{let v0=i[\"foo\"];let v1=v0[\"tag\"];let v2=v1[\"NAME\"],v3=v1[\"VAL\"];if(v2!==\"Null\"){e[0](v2)}if(v3===void 0){v3=null}i={\"foo\":{\"tag\":{\"NAME\":v2,\"VAL\":v3,},},}}catch(e0){try{let v4=i[\"foo\"];let v5=v4[\"tag\"];let v6=v5[\"NAME\"],v7=v5[\"VAL\"];if(v6!==\"Option\"){e[1](v6)}i=i}catch(e1){}}}return i}", undefined);
      }));

Ava("Nested union doesn't mutate the input", (function (t) {
        var schema = S.schema(function (s) {
              return {
                      foo: s.m(S.union([
                                S.string,
                                S.to(S.bool, S.string)
                              ]))
                    };
            });
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[2](i)}let v0=i[\"foo\"];if(typeof v0===\"boolean\"){v0=\"\"+v0}else if(!(typeof v0===\"string\")){e[1](v0)}return {\"foo\":v0,}}", undefined);
        U.assertCompiledCode(t, schema, "Convert", "i=>{let v0=i[\"foo\"];if(typeof v0===\"boolean\"){v0=\"\"+v0}return {\"foo\":v0,}}", undefined);
      }));

Ava("Compiled serialize code snapshot", (function (t) {
        var schema = S.union([
              S.literal(0),
              S.literal(1)
            ]);
        U.assertCompiledCodeIsNoop(t, schema, "Convert", undefined);
        U.assertCompiledCodeIsNoop(t, schema, "ReverseConvert", undefined);
      }));

Ava("Compiled serialize code snapshot of objects returning literal fields", (function (t) {
        var schema = S.union([
              S.object(function (s) {
                    return s.f("foo", S.literal(0));
                  }),
              S.object(function (s) {
                    return s.f("bar", S.literal(1));
                  })
            ]);
        t.deepEqual(S.reverseConvertOrThrow(1, schema), {"bar":1}, undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{if(typeof i===\"number\"){if(i===0){i={\"foo\":i,}}else if(i===1){i={\"bar\":i,}}}return i}", undefined);
        U.assertCompiledCode(t, schema, "Convert", "i=>{if(typeof i===\"object\"&&i){if(i[\"foo\"]===0){let v0=i[\"foo\"];if(v0!==0){e[0](v0)}i=v0}else if(i[\"bar\"]===1){let v1=i[\"bar\"];if(v1!==1){e[1](v1)}i=v1}}return i}", undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i===\"object\"&&i){if(i[\"foo\"]===0){i=i[\"foo\"]}else if(i[\"bar\"]===1){i=i[\"bar\"]}else{e[0](i)}}else{e[1](i)}return i}", undefined);
      }));

Ava("Enum is a shorthand for union", (function (t) {
        U.assertEqualSchemas(t, S.$$enum([
                  0,
                  1
                ]), S.union([
                  S.literal(0),
                  S.literal(1)
                ]), undefined);
      }));

Ava("Reverse schema with items", (function (t) {
        var schema = S.union([
              S.literal(0),
              S.$$null(S.bool)
            ]);
        U.assertEqualSchemas(t, S.reverse(schema), S.union([
                  S.literal(0),
                  S.option(S.bool)
                ]), undefined);
      }));

Ava("Succesfully uses reversed schema for parsing back to initial value", (function (t) {
        var schema = S.union([
              S.literal(0),
              S.$$null(S.bool)
            ]);
        U.assertReverseParsesBack(t, schema, undefined);
      }));

var schema = S.recursive(function (schema) {
      return S.union([
                  S.object(function (s) {
                        s.tag("type", "A");
                        return {
                                TAG: "A",
                                _0: s.f("nested", S.array(schema))
                              };
                      }),
                  S.literal("B"),
                  S.literal("C"),
                  S.literal("D"),
                  S.literal("E"),
                  S.literal("F"),
                  S.literal("G"),
                  S.literal("H"),
                  S.literal("I"),
                  S.literal("J"),
                  S.literal("K"),
                  S.literal("L"),
                  S.literal("M"),
                  S.literal("N"),
                  S.literal("O"),
                  S.literal("P"),
                  S.literal("Q"),
                  S.literal("R"),
                  S.literal("S"),
                  S.literal("T"),
                  S.literal("U"),
                  S.literal("V"),
                  S.literal("W"),
                  S.literal("X"),
                  S.literal("Y"),
                  S.object(function (s) {
                        s.tag("type", "Z");
                        return {
                                TAG: "Z",
                                _0: s.f("nested", S.array(schema))
                              };
                      })
                ]);
    });

Ava("Compiled parse code snapshot of crazy union", (function (t) {
        S.setGlobalConfig({});
        U.assertCompiledCode(t, schema, "Parse", "i=>{let r0=i=>{if(typeof i===\"object\"&&i){if(i[\"type\"]===\"A\"){let v0=i[\"nested\"],v4=new Array(v0.length);if(!Array.isArray(v0)){e[0](v0)}for(let v1=0;v1<v0.length;++v1){let v3;try{v3=r0(v0[v1])}catch(v2){if(v2&&v2.s===s){v2.path=\"[\\\"nested\\\"]\"+\'[\"\'+v1+\'\"]\'+v2.path}throw v2}v4[v1]=v3}i={\"TAG\":e[1],\"_0\":v4,}}else if(i[\"type\"]===\"Z\"){let v5=i[\"nested\"],v9=new Array(v5.length);if(!Array.isArray(v5)){e[2](v5)}for(let v6=0;v6<v5.length;++v6){let v8;try{v8=r0(v5[v6])}catch(v7){if(v7&&v7.s===s){v7.path=\"[\\\"nested\\\"]\"+\'[\"\'+v6+\'\"]\'+v7.path}throw v7}v9[v6]=v8}i={\"TAG\":e[3],\"_0\":v9,}}else{e[4](i)}}else if(!(typeof i===\"string\"&&(i===\"B\"||i===\"C\"||i===\"D\"||i===\"E\"||i===\"F\"||i===\"G\"||i===\"H\"||i===\"I\"||i===\"J\"||i===\"K\"||i===\"L\"||i===\"M\"||i===\"N\"||i===\"O\"||i===\"P\"||i===\"Q\"||i===\"R\"||i===\"S\"||i===\"T\"||i===\"U\"||i===\"V\"||i===\"W\"||i===\"X\"||i===\"Y\"))){e[5](i)}return i};return r0(i)}", undefined);
      }));

Ava("Compiled serialize code snapshot of crazy union", (function (t) {
        S.setGlobalConfig({});
        var code = "i=>{let r0=i=>{if(typeof i===\"object\"&&i){if(i[\"TAG\"]===\"A\"){let v0=i[\"TAG\"],v1=i[\"_0\"],v5=new Array(v1.length);if(v0!==\"A\"){e[0](v0)}for(let v2=0;v2<v1.length;++v2){let v4;try{v4=r0(v1[v2])}catch(v3){if(v3&&v3.s===s){v3.path=\"[\\\"_0\\\"]\"+\'[\"\'+v2+\'\"]\'+v3.path}throw v3}v5[v2]=v4}i={\"type\":e[1],\"nested\":v5,}}else if(i[\"TAG\"]===\"Z\"){let v6=i[\"TAG\"],v7=i[\"_0\"],v11=new Array(v7.length);if(v6!==\"Z\"){e[2](v6)}for(let v8=0;v8<v7.length;++v8){let v10;try{v10=r0(v7[v8])}catch(v9){if(v9&&v9.s===s){v9.path=\"[\\\"_0\\\"]\"+\'[\"\'+v8+\'\"]\'+v9.path}throw v9}v11[v8]=v10}i={\"type\":e[3],\"nested\":v11,}}}return i};return r0(i)}";
        U.assertCompiledCode(t, schema, "ReverseConvert", code, undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", code, undefined);
      }));

var CrazyUnion = {
  schema: schema
};

Ava("json-rpc response", (function (t) {
        var jsonRpcSchema = function (okSchema, errorSchema) {
          return S.union([
                      S.object(function (s) {
                            return {
                                    TAG: "Ok",
                                    _0: s.f("result", okSchema)
                                  };
                          }),
                      S.object(function (s) {
                            return {
                                    TAG: "Error",
                                    _0: s.f("error", errorSchema)
                                  };
                          })
                    ]);
        };
        var getLogsResponseSchema = jsonRpcSchema(S.array(S.string), S.union([
                  S.object(function (s) {
                        s.tag("message", "NotFound");
                        return "LogsNotFound";
                      }),
                  S.object(function (s) {
                        s.tag("message", "Invalid");
                        return {
                                NAME: "InvalidData",
                                VAL: s.f("data", S.string)
                              };
                      })
                ]));
        t.deepEqual(S.parseOrThrow({
        "jsonrpc": "2.0",
        "id": 1,
        "result": ["foo", "bar"]
      }, getLogsResponseSchema), {
              TAG: "Ok",
              _0: [
                "foo",
                "bar"
              ]
            }, undefined);
        t.deepEqual(S.parseOrThrow({
        "jsonrpc": "2.0",
        "id": 1,
        "error": {
          "message": "NotFound"
        }
      }, getLogsResponseSchema), {
              TAG: "Error",
              _0: "LogsNotFound"
            }, undefined);
        t.deepEqual(S.parseOrThrow({
        "jsonrpc": "2.0",
        "id": 1,
        "error": {
          "message": "Invalid",
          "data": "foo"
        }
      }, getLogsResponseSchema), {
              TAG: "Error",
              _0: {
                NAME: "InvalidData",
                VAL: "foo"
              }
            }, undefined);
      }));

Ava("Issue https://github.com/DZakh/rescript-schema/issues/101", (function (t) {
        var syncRequestSchema = S.schema(function (s) {
              return {
                      NAME: "request",
                      VAL: {
                        collectionName: s.m(S.string)
                      }
                    };
            });
        var syncResponseSchema = S.schema(function (s) {
              return {
                      NAME: "response",
                      VAL: {
                        collectionName: s.m(S.string),
                        response: s.m(S.$$enum([
                                  "accepted",
                                  "rejected"
                                ]))
                      }
                    };
            });
        var schema = S.union([
              syncRequestSchema,
              syncResponseSchema
            ]);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{if(typeof i===\"object\"&&i){if(i[\"NAME\"]===\"request\"){let v0=i[\"NAME\"],v1=i[\"VAL\"];if(v0!==\"request\"){e[0](v0)}i=i}else if(i[\"NAME\"]===\"response\"){let v2=i[\"NAME\"],v3=i[\"VAL\"];if(v2!==\"response\"){e[1](v2)}i=i}}return i}", undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i===\"object\"&&i){if(i[\"NAME\"]===\"request\"){let v0=i[\"VAL\"];if(typeof v0!==\"object\"||!v0){e[0](v0)}let v1=v0[\"collectionName\"];if(typeof v1!==\"string\"){e[1](v1)}i={\"NAME\":i[\"NAME\"],\"VAL\":{\"collectionName\":v1,},}}else if(i[\"NAME\"]===\"response\"){let v2=i[\"VAL\"];if(typeof v2!==\"object\"||!v2){e[2](v2)}let v3=v2[\"collectionName\"],v4=v2[\"response\"];if(typeof v3!==\"string\"){e[3](v3)}if(!(typeof v4===\"string\"&&(v4===\"accepted\"||v4===\"rejected\"))){e[4](v4)}i={\"NAME\":i[\"NAME\"],\"VAL\":{\"collectionName\":v3,\"response\":v4,},}}else{e[5](i)}}else{e[6](i)}return i}", undefined);
        t.deepEqual(S.reverseConvertOrThrow({
                  NAME: "response",
                  VAL: {
                    collectionName: "foo",
                    response: "accepted"
                  }
                }, schema), {
              NAME: "response",
              VAL: {
                collectionName: "foo",
                response: "accepted"
              }
            }, undefined);
      }));

export {
  Advanced ,
  CrazyUnion ,
}
/*  Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as U from "./U.res.mjs";
import Ava from "ava";

Ava("Parses with wrapping the value in variant", (function (t) {
        var schema = S.shape(S.string, (function (s) {
                return {
                        TAG: "Ok",
                        _0: s
                      };
              }));
        t.deepEqual(S.parseOrThrow("Hello world!", schema), {
              TAG: "Ok",
              _0: "Hello world!"
            }, undefined);
      }));

Ava("Parses with wrapping async schema in variant", (async function (t) {
        var schema = S.shape(S.transform(S.string, (function (param) {
                    return {
                            a: (async function (i) {
                                return i;
                              })
                          };
                  })), (function (s) {
                return {
                        TAG: "Ok",
                        _0: s
                      };
              }));
        t.deepEqual(await S.parseAsyncOrThrow("Hello world!", schema), {
              TAG: "Ok",
              _0: "Hello world!"
            }, undefined);
        return U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"string\"){e[2](i)}return Promise.all([e[0](i),]).then(a=>({\"TAG\":e[1],\"_0\":a[0],}))}", undefined);
      }));

Ava("Fails to parse wrapped schema", (function (t) {
        var schema = S.shape(S.string, (function (s) {
                return {
                        TAG: "Ok",
                        _0: s
                      };
              }));
        U.assertThrows(t, (function () {
                return S.parseOrThrow(123, schema);
              }), {
              operation: "Parse",
              code: {
                TAG: "InvalidType",
                expected: schema,
                received: 123
              },
              path: S.Path.empty
            });
      }));

Ava("Serializes with unwrapping the value from variant", (function (t) {
        var schema = S.shape(S.string, (function (s) {
                return {
                        TAG: "Ok",
                        _0: s
                      };
              }));
        t.deepEqual(S.reverseConvertOrThrow({
                  TAG: "Ok",
                  _0: "Hello world!"
                }, schema), "Hello world!", undefined);
      }));

Ava("Fails to serialize when can't unwrap the value from variant", (function (t) {
        var schema = S.shape(S.string, (function (s) {
                return {
                        TAG: "Ok",
                        _0: s
                      };
              }));
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow({
                            TAG: "Error",
                            _0: "Hello world!"
                          }, schema);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "InvalidType",
                expected: S.literal("Ok"),
                received: "Error"
              },
              path: S.Path.fromLocation("TAG")
            });
      }));

Ava("Successfully parses when the value is not used as the variant payload", (function (t) {
        var schema = S.shape(S.string, (function (param) {
                return "foo";
              }));
        t.deepEqual(S.parseOrThrow("Hello world!", schema), "foo", undefined);
      }));

Ava("Fails to serialize when the value is not used as the variant payload", (function (t) {
        var schema = S.shape(S.string, (function (param) {
                return "foo";
              }));
        U.assertThrows(t, (function () {
                return S.reverseConvertOrThrow("foo", schema);
              }), {
              operation: "ReverseConvert",
              code: {
                TAG: "InvalidOperation",
                description: "Schema isn\'t registered"
              },
              path: S.Path.empty
            });
      }));

Ava("Successfully serializes when the value is not used as the variant payload for literal schemas", (function (t) {
        var schema = S.shape(S.literal([
                  true,
                  12
                ]), (function (param) {
                return "foo";
              }));
        t.deepEqual(S.reverseConvertOrThrow("foo", schema), [true, 12], undefined);
      }));

Ava("Successfully parses when tuple is destructured", (function (t) {
        var schema = S.shape(S.literal([
                  true,
                  12
                ]), (function (param) {
                return param[1];
              }));
        t.deepEqual(S.parseOrThrow([true, 12], schema), 12, undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(!Array.isArray(i)||i.length!==2||i[\"0\"]!==true||i[\"1\"]!==12){e[0](i)}return i[\"1\"]}", undefined);
      }));

Ava("Successfully parses when S.schema object is destructured - it doesn't create an object", (function (t) {
        var schema = S.shape(S.schema(function (s) {
                  return {
                          foo: s.m(S.string)
                        };
                }), (function (obj) {
                return obj.foo;
              }));
        t.deepEqual(S.parseOrThrow({
                  foo: "bar"
                }, schema), "bar", undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[1](i)}let v0=i[\"foo\"];if(typeof v0!==\"string\"){e[0](v0)}return v0}", undefined);
      }));

Ava("Successfully parses when nested S.schema object is destructured - it doesn't create an object", (function (t) {
        var schema = S.shape(S.schema(function (s) {
                  return {
                          foo: {
                            bar: s.m(S.string)
                          }
                        };
                }), (function (obj) {
                return obj.foo.bar;
              }));
        t.deepEqual(S.parseOrThrow({
                  foo: {
                    bar: "jazz"
                  }
                }, schema), "jazz", undefined);
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[2](i)}let v0=i[\"foo\"];if(typeof v0!==\"object\"||!v0){e[0](v0)}let v1=v0[\"bar\"];if(typeof v1!==\"string\"){e[1](v1)}return v1}", undefined);
      }));

Ava("Successfully parses when transformed object schema is destructured - it does create an object and extracts a field from it afterwards", (function (t) {
        var schema = S.shape(S.transform(S.schema(function (s) {
                      return {
                              foo: s.m(S.string)
                            };
                    }), (function (param) {
                    return {
                            p: (function (obj) {
                                return {
                                        faz: obj.foo
                                      };
                              })
                          };
                  })), (function (obj) {
                return obj.faz;
              }));
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[2](i)}let v1;let v0=i[\"foo\"];if(typeof v0!==\"string\"){e[0](v0)}v1=e[1]({\"foo\":v0,});return v1[\"faz\"]}", undefined);
        t.deepEqual(S.parseOrThrow({
                  foo: "bar"
                }, schema), "bar", undefined);
      }));

Ava("Reverse convert of tagged tuple with destructured literal", (function (t) {
        var schema = S.shape(S.tuple2(S.literal(true), S.literal(12)), (function (param) {
                return param[1];
              }));
        U.assertEqualSchemas(t, S.reverse(schema), S.literal(12), undefined);
        t.deepEqual(S.reverseConvertOrThrow(12, schema), [true, 12], undefined);
        var code = "i=>{if(i!==12){e[2](i)}if(i!==12){e[1](i)}return [e[0],i,]}";
        U.assertCompiledCode(t, schema, "ReverseConvert", code, undefined);
        U.assertCompiledCode(t, schema, "ReverseParse", code, undefined);
      }));

Ava("Reverse convert of tagged tuple with destructured bool", (function (t) {
        var schema = S.shape(S.tuple3(S.literal(true), S.literal("foo"), S.bool), (function (param) {
                return [
                        param[2],
                        param[1]
                      ];
              }));
        U.assertEqualSchemas(t, S.reverse(schema), S.tuple2(S.bool, S.literal("foo")), undefined);
        t.deepEqual(S.reverseConvertOrThrow([
                  false,
                  "foo"
                ], schema), [true, "foo",false], undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v0=i[\"1\"];if(v0!==\"foo\"){e[1](v0)}return [e[0],i[\"1\"],i[\"0\"],]}", undefined);
        U.assertCompiledCode(t, schema, "ReverseParse", "i=>{if(!Array.isArray(i)||i.length!==2||i[\"1\"]!==\"foo\"){e[2](i)}let v0=i[\"1\"];if(v0!==\"foo\"){e[1](v0)}return [e[0],i[\"1\"],i[\"0\"],]}", undefined);
      }));

Ava("Successfully parses when value registered multiple times", (function (t) {
        var schema = S.shape(S.string, (function (s) {
                return {
                        NAME: "Foo",
                        VAL: [
                          s,
                          s
                        ]
                      };
              }));
        t.deepEqual(S.parseOrThrow("abc", schema), {
              NAME: "Foo",
              VAL: [
                "abc",
                "abc"
              ]
            }, undefined);
      }));

Ava("Reverse convert with value registered multiple times", (function (t) {
        var schema = S.shape(S.string, (function (s) {
                return {
                        NAME: "Foo",
                        VAL: [
                          s,
                          s
                        ]
                      };
              }));
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v0=i[\"NAME\"];if(v0!==\"Foo\"){e[0](v0)}return i[\"VAL\"][\"1\"]}", undefined);
        t.deepEqual(S.reverseConvertOrThrow({
                  NAME: "Foo",
                  VAL: [
                    "abc",
                    "abc"
                  ]
                }, schema), "abc", undefined);
      }));

Ava("Can destructure object value passed to S.shape", (function (t) {
        var schema = S.shape(S.object(function (s) {
                  return [
                          s.f("foo", S.string),
                          s.f("bar", S.string)
                        ];
                }), (function (param) {
                return {
                        foo: param[0],
                        bar: param[1]
                      };
              }));
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[2](i)}let v0=i[\"foo\"],v1=i[\"bar\"];if(typeof v0!==\"string\"){e[0](v0)}if(typeof v1!==\"string\"){e[1](v1)}return {\"foo\":v0,\"bar\":v1,}}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v0=[i[\"foo\"],i[\"bar\"],];return {\"foo\":v0[\"0\"],\"bar\":v0[\"1\"],}}", undefined);
      }));

Ava("Compiled code snapshot of variant applied to object", (function (t) {
        var schema = S.shape(S.object(function (s) {
                  return s.f("foo", S.string);
                }), (function (s) {
                return {
                        TAG: "Ok",
                        _0: s
                      };
              }));
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"object\"||!i){e[2](i)}let v0=i[\"foo\"];if(typeof v0!==\"string\"){e[0](v0)}return {\"TAG\":e[1],\"_0\":v0,}}", undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v0=i[\"TAG\"];if(v0!==\"Ok\"){e[0](v0)}return {\"foo\":i[\"_0\"],}}", undefined);
      }));

Ava("Compiled parse code snapshot", (function (t) {
        var schema = S.shape(S.string, (function (s) {
                return {
                        TAG: "Ok",
                        _0: s
                      };
              }));
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"string\"){e[1](i)}return {\"TAG\":e[0],\"_0\":i,}}", undefined);
      }));

Ava("Compiled parse code snapshot without transform", (function (t) {
        var schema = S.shape(S.string, (function (s) {
                return s;
              }));
        U.assertCompiledCode(t, schema, "Parse", "i=>{if(typeof i!==\"string\"){e[0](i)}return i}", undefined);
      }));

Ava("Compiled serialize code snapshot", (function (t) {
        var schema = S.shape(S.string, (function (s) {
                return {
                        TAG: "Ok",
                        _0: s
                      };
              }));
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v0=i[\"TAG\"];if(v0!==\"Ok\"){e[0](v0)}return i[\"_0\"]}", undefined);
      }));

Ava("Compiled serialize code snapshot without transform", (function (t) {
        var schema = S.shape(S.string, (function (s) {
                return s;
              }));
        U.assertCompiledCodeIsNoop(t, schema, "ReverseConvert", undefined);
      }));

Ava("Compiled serialize code snapshot when the value is not used as the variant payload for literal schemas", (function (t) {
        var schema = S.shape(S.literal([
                  true,
                  12
                ]), (function (param) {
                return "foo";
              }));
        t.deepEqual(S.reverseConvertOrThrow("foo", schema), [true,12], undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{if(i!==\"foo\"){e[2](i)}return [e[0],e[1],]}", undefined);
      }));

Ava("Works with variant schema used multiple times as a child schema", (function (t) {
        var appVersionSpecSchema = S.shape(S.string, (function (current) {
                return {
                        current: current,
                        minimum: "1.0"
                      };
              }));
        var appVersionsSchema = S.object(function (s) {
              return {
                      ios: s.f("ios", appVersionSpecSchema),
                      android: s.f("android", appVersionSpecSchema)
                    };
            });
        var rawAppVersions = {
          ios: "1.1",
          android: "1.2"
        };
        var appVersions = {
          ios: {
            current: "1.1",
            minimum: "1.0"
          },
          android: {
            current: "1.2",
            minimum: "1.0"
          }
        };
        var value = S.parseOrThrow(rawAppVersions, appVersionsSchema);
        t.deepEqual(value, appVersions, undefined);
        var data = S.reverseConvertToJsonOrThrow(appVersions, appVersionsSchema);
        t.deepEqual(data, rawAppVersions, undefined);
        var data$1 = S.reverseConvertToJsonOrThrow(appVersions, appVersionsSchema);
        t.deepEqual(data$1, rawAppVersions, undefined);
      }));

Ava("Reverse variant schema to literal", (function (t) {
        var schema = S.shape(S.literal("foo"), (function (param) {
                
              }));
        U.assertEqualSchemas(t, S.reverse(schema), S.unit, undefined);
      }));

Ava("Succesfully uses reversed variant schema to literal for parsing back to initial value", (function (t) {
        var schema = S.shape(S.literal("foo"), (function (param) {
                
              }));
        U.assertReverseParsesBack(t, schema, undefined);
      }));

Ava("Reverse variant schema to self", (function (t) {
        var schema = S.shape(S.bool, (function (v) {
                return v;
              }));
        t.not(S.reverse(schema), schema, undefined);
        U.assertEqualSchemas(t, S.reverse(schema), schema, undefined);
      }));

Ava("Succesfully uses reversed variant schema to self for parsing back to initial value", (function (t) {
        var schema = S.shape(S.bool, (function (v) {
                return v;
              }));
        U.assertReverseParsesBack(t, schema, true);
      }));

Ava("Reverse convert tuple turned to Ok", (function (t) {
        var schema = S.shape(S.tuple2(S.string, S.bool), (function (t) {
                return {
                        TAG: "Ok",
                        _0: t
                      };
              }));
        t.deepEqual(S.reverseConvertOrThrow({
                  TAG: "Ok",
                  _0: [
                    "foo",
                    true
                  ]
                }, schema), ["foo", true], undefined);
        U.assertCompiledCode(t, schema, "ReverseConvert", "i=>{let v0=i[\"TAG\"],v1=i[\"_0\"];if(v0!==\"Ok\"){e[0](v0)}return v1}", undefined);
      }));

Ava("Reverse with output of nested object/tuple schema", (function (t) {
        var schema = S.shape(S.bool, (function (v) {
                return {
                        nested: {
                          field: [
                            v,
                            true
                          ]
                        }
                      };
              }));
        U.assertEqualSchemas(t, S.reverse(schema), S.object(function (s) {
                  s.f("nested", S.object(function (s) {
                            s.f("field", S.tuple(function (s) {
                                      s.item(0, S.bool);
                                      s.tag(1, true);
                                    }));
                          }));
                }), undefined);
      }));

Ava("Succesfully parses reversed schema with output of nested object/tuple and parses it back to initial value", (function (t) {
        var schema = S.shape(S.bool, (function (v) {
                return {
                        nested: {
                          field: [
                            v,
                            true
                          ]
                        }
                      };
              }));
        U.assertReverseParsesBack(t, schema, {
              nested: {
                field: [
                  true,
                  true
                ]
              }
            });
      }));

export {
  
}
/*  Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S_Core from "./S_Core.res.mjs";

let Path = S_Core.Path;

let $$Error = S_Core.$$Error;

let Flag = S_Core.Flag;

let never = S_Core.never;

let unknown = S_Core.unknown;

let unit = S_Core.unit;

let nullAsUnit = S_Core.nullAsUnit;

let string = S_Core.string;

let bool = S_Core.bool;

let int = S_Core.int;

let float = S_Core.float;

let bigint = S_Core.bigint;

let json = S_Core.json;

let literal = S_Core.literal;

let array = S_Core.array;

let unnest = S_Core.unnest;

let list = S_Core.list;

let dict = S_Core.dict;

let option = S_Core.option;

let $$null = S_Core.$$null;

let nullish = S_Core.nullish;

let jsonString = S_Core.jsonString;

let union = S_Core.union;

let $$enum = S_Core.$$enum;

let meta = S_Core.meta;

let Catch = S_Core.Catch;

let $$catch = S_Core.$$catch;

let transform = S_Core.transform;

let custom = S_Core.custom;

let refine = S_Core.refine;

let shape = S_Core.shape;

let to = S_Core.to;

let compile = S_Core.compile;

let parseOrThrow = S_Core.parseOrThrow;

let parseJsonOrThrow = S_Core.parseJsonOrThrow;

let parseJsonStringOrThrow = S_Core.parseJsonStringOrThrow;

let parseAsyncOrThrow = S_Core.parseAsyncOrThrow;

let convertOrThrow = S_Core.convertOrThrow;

let convertToJsonOrThrow = S_Core.convertToJsonOrThrow;

let convertToJsonStringOrThrow = S_Core.convertToJsonStringOrThrow;

let convertAsyncOrThrow = S_Core.convertAsyncOrThrow;

let reverseConvertOrThrow = S_Core.reverseConvertOrThrow;

let reverseConvertToJsonOrThrow = S_Core.reverseConvertToJsonOrThrow;

let reverseConvertToJsonStringOrThrow = S_Core.reverseConvertToJsonStringOrThrow;

let assertOrThrow = S_Core.assertOrThrow;

let isAsync = S_Core.isAsync;

let recursive = S_Core.recursive;

let noValidation = S_Core.noValidation;

let toExpression = S_Core.toExpression;

let Schema = S_Core.Schema;

let schema = S_Core.schema;

let $$Object = S_Core.$$Object;

let object = S_Core.object;

let strip = S_Core.strip;

let deepStrip = S_Core.deepStrip;

let strict = S_Core.strict;

let deepStrict = S_Core.deepStrict;

let Tuple = S_Core.Tuple;

let tuple = S_Core.tuple;

let tuple1 = S_Core.tuple1;

let tuple2 = S_Core.tuple2;

let tuple3 = S_Core.tuple3;

let Option = S_Core.Option;

let $$String = S_Core.$$String;

let Int = S_Core.Int;

let Float = S_Core.Float;

let $$Array = S_Core.$$Array;

let Metadata = S_Core.Metadata;

let reverse = S_Core.reverse;

let min = S_Core.min;

let floatMin = S_Core.floatMin;

let max = S_Core.max;

let floatMax = S_Core.floatMax;

let length = S_Core.length;

let port = S_Core.port;

let email = S_Core.email;

let uuid = S_Core.uuid;

let cuid = S_Core.cuid;

let url = S_Core.url;

let pattern = S_Core.pattern;

let datetime = S_Core.datetime;

let trim = S_Core.trim;

let toJSONSchema = S_Core.toJSONSchema;

let extendJSONSchema = S_Core.extendJSONSchema;

let setGlobalConfig = S_Core.setGlobalConfig;

let ErrorClass = S_Core.ErrorClass;

export {
  Path,
  $$Error,
  Flag,
  never,
  unknown,
  unit,
  nullAsUnit,
  string,
  bool,
  int,
  float,
  bigint,
  json,
  literal,
  array,
  unnest,
  list,
  dict,
  option,
  $$null,
  nullish,
  jsonString,
  union,
  $$enum,
  meta,
  Catch,
  $$catch,
  transform,
  custom,
  refine,
  shape,
  to,
  compile,
  parseOrThrow,
  parseJsonOrThrow,
  parseJsonStringOrThrow,
  parseAsyncOrThrow,
  convertOrThrow,
  convertToJsonOrThrow,
  convertToJsonStringOrThrow,
  convertAsyncOrThrow,
  reverseConvertOrThrow,
  reverseConvertToJsonOrThrow,
  reverseConvertToJsonStringOrThrow,
  assertOrThrow,
  isAsync,
  recursive,
  noValidation,
  toExpression,
  Schema,
  schema,
  $$Object,
  object,
  strip,
  deepStrip,
  strict,
  deepStrict,
  Tuple,
  tuple,
  tuple1,
  tuple2,
  tuple3,
  Option,
  $$String,
  Int,
  Float,
  $$Array,
  Metadata,
  reverse,
  min,
  floatMin,
  max,
  floatMax,
  length,
  port,
  email,
  uuid,
  cuid,
  url,
  pattern,
  datetime,
  trim,
  toJSONSchema,
  extendJSONSchema,
  setGlobalConfig,
  ErrorClass,
}
/* S_Core Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_List from "rescript/lib/es6/Belt_List.js";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";
import * as Primitive_exceptions from "rescript/lib/es6/Primitive_exceptions.js";

let immutableEmpty = {};

let immutableEmpty$1 = [];

function fromString(string) {
  let _idx = 0;
  while (true) {
    let idx = _idx;
    let match = string[idx];
    if (match === undefined) {
      return "\"" + string + "\"";
    }
    if (match === "\"") {
      return JSON.stringify(string);
    }
    _idx = idx + 1 | 0;
    continue;
  };
}

function toArray(path) {
  if (path === "") {
    return [];
  } else {
    return JSON.parse(path.split("\"][\"").join("\",\""));
  }
}

function fromLocation(location) {
  return "[" + fromString(location) + "]";
}

function fromArray(array) {
  let len = array.length;
  if (len !== 1) {
    if (len !== 0) {
      return "[" + array.map(fromString).join("][") + "]";
    } else {
      return "";
    }
  } else {
    return "[" + fromString(array[0]) + "]";
  }
}

function concat(path, concatedPath) {
  return path + concatedPath;
}

let symbol = Symbol("schema");

let itemSymbol = Symbol("schema:item");

let $$Error = /* @__PURE__ */Primitive_exceptions.create("S_Core.Error");

let c = "const";

function isOptional(schema) {
  let match = schema.type;
  switch (match) {
    case "undefined" :
      return true;
    case "union" :
      return "undefined" in schema.has;
    default:
      return false;
  }
}

let globalConfig = {
  r: 0,
  a: "strip",
  n: false
};

class SuryError extends Error {
  constructor(code, flag, path) {
    super();
    this.flag = flag;
    this.code = code;
    this.path = path;
  }
}

var d = Object.defineProperty, p = SuryError.prototype;
d(p, 'message', {
  get() {
      return message(this);
  }
})
d(p, 'reason', {
  get() {
      return reason(this);
  }
})
d(p, 'name', {value: 'SuryError'})
d(p, 's', {value: symbol})
d(p, '_1', {
  get() {
    return this
  },
});
d(p, 'RE_EXN_ID', {
  value: $$Error,
});

function w(fn, ...args) {
  return fn(this, ...args)
}
;

function getOrRethrow(exn) {
  if ((exn&&exn.s===symbol)) {
    return exn;
  }
  throw exn;
}

function has(acc, flag) {
  return (acc & flag) !== 0;
}

let copy = ((schema) => {
  let c = {}
  for (let k in schema) {
    if (k > "a") {
      c[k] = schema[k]
    }
  }
  return c
});

let mergeInPlace = ((target, schema) => {
  for (let k in schema) {
    if (k > "a") {
      target[k] = schema[k]
    }
  }
});

let resetOperationsCache = ((schema) => {
  for (let k in schema) {
    if (+k) {
      delete schema[k];
    }
  }
});

function stringify(unknown) {
  let typeOfValue = typeof unknown;
  if (typeOfValue === "number" || typeOfValue === "function" || typeOfValue === "boolean" || typeOfValue === "symbol") {
    return unknown.toString();
  }
  if (typeOfValue === "string") {
    return "\"" + unknown + "\"";
  }
  if (typeOfValue !== "object") {
    if (typeOfValue === "undefined") {
      return "undefined";
    } else {
      return unknown + "n";
    }
  }
  if (unknown === null) {
    return "null";
  }
  if (Array.isArray(unknown)) {
    let string = "[";
    for (let i = 0, i_finish = unknown.length; i < i_finish; ++i) {
      if (i !== 0) {
        string = string + ", ";
      }
      string = string + stringify(unknown[i]);
    }
    return string + "]";
  }
  if (unknown.constructor !== Object) {
    return Object.prototype.toString.call(unknown);
  }
  let keys = Object.keys(unknown);
  let string$1 = "{";
  for (let i$1 = 0, i_finish$1 = keys.length; i$1 < i_finish$1; ++i$1) {
    let key = keys[i$1];
    let value = unknown[key];
    if (i$1 !== 0) {
      string$1 = string$1 + ", ";
    }
    string$1 = string$1 + "\"" + key + "\": " + stringify(value);
  }
  return string$1 + "}";
}

function toExpression(schema) {
  let tag = schema.type;
  let $$const = schema.const;
  let name = schema.name;
  if (name !== undefined) {
    return name;
  }
  if ($$const !== undefined) {
    return stringify($$const);
  }
  let format = schema.format;
  let anyOf = schema.anyOf;
  if (anyOf !== undefined) {
    return anyOf.map(toExpression).join(" | ");
  }
  if (format !== undefined) {
    return format;
  }
  switch (tag) {
    case "nan" :
      return "NaN";
    case "array" :
      let additionalItems = schema.additionalItems;
      let items = schema.items;
      if (typeof additionalItems !== "object") {
        return "[" + items.map(item => toExpression(item.schema)).join(", ") + "]";
      }
      let itemName = toExpression(additionalItems);
      return (
        additionalItems.type === "union" ? "(" + itemName + ")" : itemName
      ) + "[]";
    case "object" :
      let additionalItems$1 = schema.additionalItems;
      let items$1 = schema.items;
      if (items$1.length === 0) {
        if (typeof additionalItems$1 === "object") {
          return "{ [key: string]: " + toExpression(additionalItems$1) + "; }";
        } else {
          return "{}";
        }
      } else {
        return "{ " + items$1.map(item => item.location + ": " + toExpression(item.schema) + ";").join(" ") + " }";
      }
    default:
      return tag;
  }
}

let value = SuryError;

function constructor(prim0, prim1, prim2) {
  return new SuryError(prim0, prim1, prim2);
}

function reason(error, nestedLevelOpt) {
  let nestedLevel = nestedLevelOpt !== undefined ? nestedLevelOpt : 0;
  let reason$1 = error.code;
  if (typeof reason$1 !== "object") {
    return "Encountered unexpected async transform or refine. Use parseAsyncOrThrow operation instead";
  }
  switch (reason$1.TAG) {
    case "OperationFailed" :
      return reason$1._0;
    case "InvalidOperation" :
      return reason$1.description;
    case "InvalidType" :
      let unionErrors = reason$1.unionErrors;
      let m = "Expected " + toExpression(reason$1.expected) + ", received " + stringify(reason$1.received);
      if (unionErrors !== undefined) {
        let lineBreak = "\n" + " ".repeat((nestedLevel << 1));
        let reasonsDict = {};
        for (let idx = 0, idx_finish = unionErrors.length; idx < idx_finish; ++idx) {
          let error$1 = unionErrors[idx];
          let reason$2 = reason(error$1, nestedLevel + 1);
          let nonEmptyPath = error$1.path;
          let location = nonEmptyPath === "" ? "" : "At " + nonEmptyPath + ": ";
          let line = "- " + location + reason$2;
          if (!reasonsDict[line]) {
            reasonsDict[line] = 1;
            m = m + lineBreak + line;
          }
          
        }
      }
      return m;
    case "ExcessField" :
      return "Unrecognized key \"" + reason$1._0 + "\"";
    case "InvalidJsonSchema" :
      return "The '" + toExpression(reason$1._0) + "' schema cannot be converted to JSON";
  }
}

function reason$1(error) {
  return reason(error, undefined);
}

function message(error) {
  let op = error.flag;
  let text = "Failed ";
  if (op & 2) {
    text = text + "async ";
  }
  text = text + (
    op & 1 ? (
        op & 4 ? "asserting" : "parsing"
      ) : "converting"
  );
  if (op & 8) {
    text = text + " to JSON" + (
      op & 16 ? " string" : ""
    );
  }
  let nonEmptyPath = error.path;
  let tmp = nonEmptyPath === "" ? "" : " at " + nonEmptyPath;
  return text + tmp + ": " + reason(error, undefined);
}

let ErrorClass = {
  value: value,
  constructor: constructor,
  reason: reason$1,
  message: message
};

function embed(b, value) {
  let e = b.g.e;
  let l = e.length;
  e[l] = value;
  return "e[" + l + "]";
}

function inlineConst(b, schema) {
  let match = schema.type;
  switch (match) {
    case "string" :
      return fromString(schema.const);
    case "bigint" :
      let $$const = schema.const;
      return $$const + "n";
    case "undefined" :
      return "void 0";
    case "symbol" :
    case "function" :
    case "instance" :
      break;
    default:
      return schema.const;
  }
  let $$const$1 = schema.const;
  return embed(b, $$const$1);
}

function secondAllocate(v) {
  let b = this;
  b.l = b.l + "," + v;
}

function initialAllocate(v) {
  let b = this;
  b.l = v;
  b.a = secondAllocate;
}

function rootScope(flag) {
  let global = {
    c: "",
    l: "",
    a: initialAllocate,
    v: -1,
    o: flag,
    e: []
  };
  global.g = global;
  return global;
}

function allocateScope(b) {
  ((delete b.a));
  let varsAllocation = b.l;
  if (varsAllocation === "") {
    return b.c;
  } else {
    return "let " + varsAllocation + ";" + b.c;
  }
}

function varWithoutAllocation(global) {
  let newCounter = global.v + 1;
  global.v = newCounter;
  return "v" + newCounter;
}

function _var(_b) {
  return this.i;
}

function _notVar(b) {
  let val = this;
  let v = varWithoutAllocation(b.g);
  let i = val.i;
  if (i === "") {
    val.b.a(v);
  } else if (val.b.a !== (void 0)) {
    val.b.a(v + "=" + i);
  } else {
    b.c = b.c + (v + "=" + i + ";");
    b.g.a(v);
  }
  val.v = _var;
  val.i = v;
  return v;
}

function allocateVal(b) {
  let v = varWithoutAllocation(b.g);
  b.a(v);
  return {
    b: b,
    v: _var,
    i: v,
    a: false
  };
}

function objectJoin(inlinedLocation, value) {
  return inlinedLocation + ":" + value + ",";
}

function arrayJoin(_inlinedLocation, value) {
  return value + ",";
}

function make(b, isArray) {
  return {
    b: b,
    v: _notVar,
    i: "",
    a: false,
    j: isArray ? arrayJoin : objectJoin,
    c: 0,
    p: ""
  };
}

function add(objectVal, inlinedLocation, val) {
  objectVal[inlinedLocation] = val;
  if (val.a) {
    objectVal.p = objectVal.p + val.i + ",";
    objectVal.i = objectVal.i + objectVal.j(inlinedLocation, "a[" + (objectVal.c++) + "]");
  } else {
    objectVal.i = objectVal.i + objectVal.j(inlinedLocation, val.i);
  }
}

function merge(target, subObjectVal) {
  let inlinedLocations = Object.keys(subObjectVal);
  for (let idx = 7, idx_finish = inlinedLocations.length; idx < idx_finish; ++idx) {
    let inlinedLocation = inlinedLocations[idx];
    add(target, inlinedLocation, subObjectVal[inlinedLocation]);
  }
}

function complete(objectVal, isArray) {
  objectVal.i = isArray ? "[" + objectVal.i + "]" : "{" + objectVal.i + "}";
  if (objectVal.c) {
    objectVal.a = true;
    objectVal.i = "Promise.all([" + objectVal.p + "]).then(a=>(" + objectVal.i + "))";
  }
  return objectVal;
}

function addKey(b, input, key, val) {
  return input.v(b) + "[" + key + "]=" + val.i;
}

function set(b, input, val) {
  if (input === val) {
    return "";
  }
  let inputVar = input.v(b);
  let match = input.a;
  if (match) {
    let match$1 = val.a;
    if (!match$1) {
      return inputVar + "=Promise.resolve(" + val.i + ")";
    }
    
  } else {
    let match$2 = val.a;
    if (match$2) {
      input.a = true;
      return inputVar + "=" + val.i;
    }
    
  }
  return inputVar + "=" + val.i;
}

function get(b, targetVal, inlinedLocation) {
  let val = targetVal[inlinedLocation];
  if (val !== undefined) {
    return val;
  } else {
    return {
      b: b,
      v: _notVar,
      i: targetVal.v(b) + ("[" + inlinedLocation + "]"),
      a: false
    };
  }
}

function setInlined(b, input, inlined) {
  return input.v(b) + "=" + inlined;
}

function map(inlinedFn, input) {
  return {
    b: input.b,
    v: _notVar,
    i: inlinedFn + "(" + input.i + ")",
    a: false
  };
}

function transform(b, input, operation) {
  if (!input.a) {
    return operation(b, input);
  }
  let bb = {
    c: "",
    l: "",
    a: initialAllocate,
    g: b.g
  };
  let operationInput = {
    b: b,
    v: _var,
    i: varWithoutAllocation(bb.g),
    a: false
  };
  let operationOutputVal = operation(bb, operationInput);
  let operationCode = allocateScope(bb);
  return {
    b: input.b,
    v: _notVar,
    i: input.i + ".then(" + operationInput.v(b) + "=>{" + operationCode + "return " + operationOutputVal.i + "})",
    a: true
  };
}

function raise(b, code, path) {
  throw new SuryError(code, b.g.o, path);
}

function embedSyncOperation(b, input, fn) {
  if (input.a) {
    return {
      b: input.b,
      v: _notVar,
      i: input.i + ".then(" + embed(b, fn) + ")",
      a: true
    };
  } else {
    return map(embed(b, fn), input);
  }
}

function embedAsyncOperation(b, input, fn) {
  if (!(b.g.o & 2)) {
    raise(b, "UnexpectedAsync", "");
  }
  let val = embedSyncOperation(b, input, fn);
  val.a = true;
  return val;
}

function failWithArg(b, path, fn, arg) {
  return embed(b, arg => raise(b, fn(arg), path)) + "(" + arg + ")";
}

function fail(b, message, path) {
  return embed(b, () => raise(b, {
    TAG: "OperationFailed",
    _0: message
  }, path)) + "()";
}

function effectCtx(b, selfSchema, path) {
  return {
    schema: selfSchema,
    fail: (message, customPathOpt) => {
      let customPath = customPathOpt !== undefined ? customPathOpt : "";
      return raise(b, {
        TAG: "OperationFailed",
        _0: message
      }, path + customPath);
    }
  };
}

function invalidOperation(b, path, description) {
  return raise(b, {
    TAG: "InvalidOperation",
    description: description
  }, path);
}

function withCatch(b, input, $$catch, appendSafe, fn) {
  let prevCode = b.c;
  b.c = "";
  let errorVar = varWithoutAllocation(b.g);
  let maybeResolveVal = $$catch(b, errorVar);
  let catchCode = "if(" + (errorVar + "&&" + errorVar + ".s===s") + "){" + b.c;
  b.c = "";
  let bb = {
    c: "",
    l: "",
    a: initialAllocate,
    g: b.g
  };
  let fnOutput = fn(bb);
  b.c = b.c + allocateScope(bb);
  let isNoop = fnOutput.i === input.i && b.c === "";
  if (appendSafe !== undefined) {
    appendSafe(b, fnOutput);
  }
  if (isNoop) {
    return fnOutput;
  }
  let isAsync = fnOutput.a;
  let output = input === fnOutput ? input : (
      appendSafe !== undefined ? fnOutput : ({
          b: b,
          v: _notVar,
          i: "",
          a: isAsync
        })
    );
  let catchCode$1 = maybeResolveVal !== undefined ? catchLocation => catchCode + (
      catchLocation === 1 ? "return " + maybeResolveVal.i : set(b, output, maybeResolveVal)
    ) + ("}else{throw " + errorVar + "}") : param => catchCode + "}throw " + errorVar;
  b.c = prevCode + ("try{" + b.c + (
    isAsync ? setInlined(b, output, fnOutput.i + ".catch(" + errorVar + "=>{" + catchCode$1(1) + "})") : set(b, output, fnOutput)
  ) + "}catch(" + errorVar + "){" + catchCode$1(0) + "}");
  return output;
}

function withPathPrepend(b, input, path, maybeDynamicLocationVar, appendSafe, fn) {
  if (path === "" && maybeDynamicLocationVar === undefined) {
    return fn(b, input, path);
  }
  try {
    return withCatch(b, input, (b, errorVar) => {
      b.c = errorVar + ".path=" + fromString(path) + "+" + (
        maybeDynamicLocationVar !== undefined ? "'[\"'+" + maybeDynamicLocationVar + "+'\"]'+" : ""
      ) + errorVar + ".path";
    }, appendSafe, b => fn(b, input, ""));
  } catch (exn) {
    let error = getOrRethrow(exn);
    throw new SuryError(error.code, error.flag, path + "[]" + error.path);
  }
}

function validation(b, inputVar, schema, negative) {
  let eq = negative ? "!==" : "===";
  let and_ = negative ? "||" : "&&";
  let exp = negative ? "!" : "";
  let tag = schema.type;
  switch (tag) {
    case "null" :
      return inputVar + eq + "null";
    case "undefined" :
      return inputVar + eq + "void 0";
    case "nan" :
      return exp + ("Number.isNaN(" + inputVar + ")");
    default:
      let match = schema.const;
      if (match !== undefined) {
        return inputVar + eq + inlineConst(b, schema);
      }
      switch (tag) {
        case "array" :
          return exp + "Array.isArray(" + inputVar + ")";
        case "object" :
          return "typeof " + inputVar + eq + "\"" + tag + "\"" + and_ + exp + inputVar;
        default:
          return "typeof " + inputVar + eq + "\"" + tag + "\"";
      }
  }
}

function refinement(b, inputVar, schema, negative) {
  let eq = negative ? "!==" : "===";
  let and_ = negative ? "||" : "&&";
  let not_ = negative ? "" : "!";
  let lt = negative ? ">" : "<";
  let gt = negative ? "<" : ">";
  if (c in schema) {
    return "";
  }
  let match = schema.type;
  if (schema.format !== "Tbd") {
    return and_ + inputVar + lt + "2147483647" + and_ + inputVar + gt + "-2147483648" + and_ + inputVar + "%1" + eq + "0";
  }
  switch (match) {
    case "number" :
      if (globalConfig.n) {
        return "";
      } else {
        return and_ + not_ + "Number.isNaN(" + inputVar + ")";
      }
    case "array" :
      let additionalItems = schema.additionalItems;
      let items = schema.items;
      let length = items.length;
      let code;
      code = additionalItems === "strip" || additionalItems === "strict" ? (
          additionalItems === "strip" ? and_ + inputVar + ".length" + gt + length : and_ + inputVar + ".length" + eq + length
        ) : "";
      for (let idx = 0; idx < length; ++idx) {
        let match$1 = items[idx];
        let item = match$1.schema;
        if (c in item && !item.catch || schema.unnest) {
          code = code + and_ + validation(b, inputVar + ("[" + match$1.inlinedLocation + "]"), item, negative);
        }
        
      }
      return code;
    case "object" :
      let additionalItems$1 = schema.additionalItems;
      let items$1 = schema.items;
      let code$1 = additionalItems$1 === "strip" ? "" : and_ + not_ + "Array.isArray(" + inputVar + ")";
      for (let idx$1 = 0, idx_finish = items$1.length; idx$1 < idx_finish; ++idx$1) {
        let match$2 = items$1[idx$1];
        let schema$1 = match$2.schema;
        if (c in schema$1 && !schema$1.catch) {
          code$1 = code$1 + and_ + validation(b, inputVar + ("[" + match$2.inlinedLocation + "]"), schema$1, negative);
        }
        
      }
      return code$1;
    default:
      return "";
  }
}

function typeFilterCode(b, schema, input, path) {
  let match = schema.type;
  let match$1 = schema.noValidation;
  if (match$1) {
    return "";
  }
  switch (match) {
    case "never" :
    case "unknown" :
    case "union" :
    case "json" :
      return "";
    default:
      let inputVar = input.v(b);
      return "if(" + validation(b, inputVar, schema, true) + refinement(b, inputVar, schema, true) + "){" + failWithArg(b, path, input => ({
        TAG: "InvalidType",
        expected: schema,
        received: input
      }), inputVar) + "}";
  }
}

function parseWithTypeValidation(b, schema, input, path) {
  if (b.g.o & 1 || c in schema) {
    b.c = b.c + typeFilterCode(b, schema, input, path);
  }
  return schema.b(b, input, schema, path);
}

function noop(_b, input, param, param$1) {
  return input;
}

function noopOperation(i) {
  return i;
}

let nonJsonableTags = new Set([
  "undefined",
  "unknown",
  "nan",
  "bigint",
  "function",
  "instance",
  "symbol"
]);

function internalCompile(builder, schema, flag) {
  let b = rootScope(flag);
  if (flag & 8) {
    let output = reverse(schema);
    jsonableValidation(output, output, "", flag);
  }
  let input = {
    b: b,
    v: _var,
    i: "i",
    a: false
  };
  let output$1 = builder(b, input, schema, "");
  schema.isAsync = output$1.a;
  if (b.l !== "") {
    b.c = "let " + b.l + ";" + b.c;
  }
  if (flag & 1 || c in schema) {
    b.c = typeFilterCode(b, schema, input, "") + b.c;
  }
  if (b.c === "" && output$1 === input && !(flag & 22)) {
    return noopOperation;
  }
  let inlinedOutput = flag & 4 ? "void 0" : output$1.i;
  if (flag & 16) {
    inlinedOutput = "JSON.stringify(" + inlinedOutput + ")";
  }
  if (flag & 2 && !output$1.a) {
    inlinedOutput = "Promise.resolve(" + inlinedOutput + ")";
  }
  let inlinedFunction = "i=>{" + b.c + "return " + inlinedOutput + "}";
  let ctxVarValue1 = b.g.e;
  return new Function("e", "s", "return " + inlinedFunction)(ctxVarValue1, symbol);
}

function operationFn(s, o) {
  if ((o in s)) {
    return (s[o]);
  }
  let ss = o & 32 ? reverse(s) : s;
  let f = internalCompile(ss.b, ss, o);
  ((s[o] = f));
  return f;
}

function reverse(schema) {
  let fn = schema.output;
  if (fn === undefined) {
    return schema;
  }
  if (typeof fn === "object") {
    return fn;
  }
  let reversed = fn.call(schema);
  let reversed$1 = reversed.output === undefined ? copy(reversed) : reversed;
  if (reversed$1["~standard"] === undefined) {
    toStandard(reversed$1);
  }
  schema.output = reversed$1;
  reversed$1.output = schema;
  return reversed$1;
}

function toStandard(schema) {
  schema.with = w;
  schema["~standard"] = {
    version: 1,
    vendor: "sury",
    validate: input => {
      try {
        return {
          value: operationFn(schema, 1)(input)
        };
      } catch (exn) {
        let error = getOrRethrow(exn);
        return {
          issues: [{
              message: message(error),
              path: error.path === "" ? undefined : toArray(error.path)
            }]
        };
      }
    }
  };
  return schema;
}

function jsonableValidation(output, report, path, flag) {
  let tag = output.type;
  if (nonJsonableTags.has(tag)) {
    throw new SuryError({
      TAG: "InvalidJsonSchema",
      _0: report
    }, flag, path);
  }
  if (tag === "union") {
    output.anyOf.forEach(s => jsonableValidation(s, report, path, flag));
    return;
  }
  let additionalItems = output.additionalItems;
  let items = output.items;
  if (items === undefined) {
    return;
  }
  let isObject = tag === "object";
  if (additionalItems === "strip" || additionalItems === "strict") {
    additionalItems === "strip";
  } else if (isObject ? !isOptional(additionalItems) : true) {
    jsonableValidation(additionalItems, report, path, flag);
  }
  items.forEach(item => {
    let s = item.schema;
    if (isObject ? !isOptional(s) : true) {
      return jsonableValidation(s, s, path + ("[" + item.inlinedLocation + "]"), flag);
    }
    
  });
}

function compile(schema, input, output, mode, typeValidationOpt) {
  let typeValidation = typeValidationOpt !== undefined ? typeValidationOpt : true;
  let flag = 0;
  let exit = 0;
  switch (output) {
    case "Output" :
    case "Input" :
      exit = 1;
      break;
    case "Assert" :
      flag = flag | 4;
      break;
    case "Json" :
      flag = flag | 8;
      break;
    case "JsonString" :
      flag = flag | 24;
      break;
  }
  if (exit === 1 && output === input) {
    throw new Error("[Schema] Can't compile operation to converting value to self");
  }
  if (mode !== "Sync") {
    flag = flag | 2;
  }
  if (typeValidation) {
    flag = flag | 1;
  }
  if (input === "Output") {
    flag = flag | 32;
  }
  let fn = operationFn(schema, flag);
  if (input !== "JsonString") {
    return fn;
  }
  let flag$1 = flag;
  return jsonString => {
    try {
      return fn(JSON.parse(jsonString));
    } catch (exn) {
      throw new SuryError({
        TAG: "OperationFailed",
        _0: exn.message
      }, flag$1, "");
    }
  };
}

function item(factory, item$1) {
  return function () {
    let reversed = reverse(item$1);
    if (reversed === item$1) {
      return this;
    } else {
      return factory(reversed);
    }
  };
}

function parseOrThrow(any, schema) {
  return operationFn(schema, 1)(any);
}

function parseJsonStringOrThrow(jsonString, schema) {
  let tmp;
  try {
    tmp = JSON.parse(jsonString);
  } catch (exn) {
    throw new SuryError({
      TAG: "OperationFailed",
      _0: exn.message
    }, 1, "");
  }
  return parseOrThrow(tmp, schema);
}

function parseAsyncOrThrow(any, schema) {
  return operationFn(schema, 3)(any);
}

function convertOrThrow(input, schema) {
  return operationFn(schema, 0)(input);
}

function convertToJsonOrThrow(any, schema) {
  return operationFn(schema, 8)(any);
}

function convertToJsonStringOrThrow(input, schema) {
  return operationFn(schema, 24)(input);
}

function convertAsyncOrThrow(any, schema) {
  return operationFn(schema, 2)(any);
}

function reverseConvertOrThrow(value, schema) {
  return operationFn(schema, 32)(value);
}

function reverseConvertToJsonOrThrow(value, schema) {
  return operationFn(schema, 40)(value);
}

function reverseConvertToJsonStringOrThrow(value, schema, spaceOpt) {
  let space = spaceOpt !== undefined ? spaceOpt : 0;
  return JSON.stringify(reverseConvertToJsonOrThrow(value, schema), null, space);
}

function assertOrThrow(any, schema) {
  return operationFn(schema, 5)(any);
}

let $$undefined = {
  type: "undefined",
  b: noop,
  const: (void 0)
};

let $$null = {
  type: "null",
  b: noop,
  const: null
};

function parse(value) {
  if (value === null) {
    return $$null;
  }
  let $$typeof = typeof value;
  let schema = $$typeof === "object" ? ({
      type: "instance",
      b: noop
    }) : (
      $$typeof === "undefined" ? $$undefined : (
          $$typeof === "number" && Number.isNaN(value) ? ({
              type: "nan",
              b: noop
            }) : ({
              type: $$typeof,
              b: noop
            })
        )
    );
  schema.const = value;
  return schema;
}

function isAsync(schema) {
  let v = schema.isAsync;
  if (v !== undefined) {
    return v;
  }
  try {
    let b = rootScope(2);
    let input = {
      b: b,
      v: _var,
      i: "i",
      a: false
    };
    let output = schema.b(b, input, schema, "");
    schema.isAsync = output.a;
    return output.a;
  } catch (exn) {
    getOrRethrow(exn);
    return false;
  }
}

function wrapExnToFailure(exn) {
  if ((exn&&exn.s===symbol)) {
    return {
      success: false,
      error: exn
    };
  }
  throw exn;
}

function js_safe(fn) {
  try {
    return {
      success: true,
      value: fn()
    };
  } catch (exn) {
    return wrapExnToFailure(exn);
  }
}

function js_safeAsync(fn) {
  try {
    return fn().then(value => ({
      success: true,
      value: value
    }), wrapExnToFailure);
  } catch (exn) {
    return Promise.resolve(wrapExnToFailure(exn));
  }
}

function make$1(namespace, name) {
  return "m:" + namespace + ":" + name;
}

function internal(name) {
  return "m:" + name;
}

let Id = {
  make: make$1,
  internal: internal
};

function get$1(schema, id) {
  return schema[id];
}

function set$1(schema, id, metadata) {
  let mut = copy(schema);
  mut[id] = metadata;
  return toStandard(mut);
}

function recursive(fn) {
  let r = "r" + globalConfig.r;
  globalConfig.r = globalConfig.r + 1 | 0;
  let builder = (b, input, param, param$1) => transform(b, input, (_b, input) => map(r, input));
  let output = () => ({
    type: "unknown",
    b: (_b, input, param, param$1) => map(r, input)
  });
  let placeholder = {
    type: "unknown",
    b: builder,
    name: "Self",
    output: output
  };
  let schema = fn(placeholder);
  mergeInPlace(placeholder, schema);
  placeholder.name = toExpression(schema);
  placeholder.b = builder;
  placeholder.output = output;
  let initialParseOperationBuilder = schema.b;
  schema.b = (b, input, selfSchema, path) => {
    let inputVar = input.v(b);
    let bb = {
      c: "",
      l: "",
      a: initialAllocate,
      g: b.g
    };
    let opOutput = initialParseOperationBuilder(bb, input, selfSchema, "");
    let opBodyCode = allocateScope(bb) + ("return " + opOutput.i);
    b.c = b.c + ("let " + r + "=" + inputVar + "=>{" + opBodyCode + "};");
    return withPathPrepend(b, input, path, undefined, undefined, (b, input, param) => transform(b, input, (_b, input) => {
      let output = map(r, input);
      if (opOutput.a) {
        output.a = true;
        placeholder.b = (b, input, param, param$1) => transform(b, input, (_b, input) => {
          let output = map(r, input);
          output.a = true;
          return output;
        });
      }
      return output;
    }));
  };
  let initialReverse = schema.output.bind(schema);
  schema.output = () => {
    let initialReversed = initialReverse();
    let mut = copy(initialReversed);
    mut.output = schema;
    schema.output = mut;
    mut.b = (b, input, selfSchema, path) => {
      let inputVar = input.v(b);
      let bb = {
        c: "",
        l: "",
        a: initialAllocate,
        g: b.g
      };
      let initialInput = {
        b: bb,
        v: input.v,
        i: input.i,
        a: input.a
      };
      let opOutput = initialReversed.b(bb, initialInput, selfSchema, "");
      let opBodyCode = allocateScope(bb) + ("return " + opOutput.i);
      b.c = b.c + ("let " + r + "=" + inputVar + "=>{" + opBodyCode + "};");
      return withPathPrepend(b, input, path, undefined, undefined, (_b, input, param) => map(r, input));
    };
    return mut;
  };
  return toStandard(schema);
}

function noValidation(schema, value) {
  let mut = copy(schema);
  mut.noValidation = value;
  return toStandard(mut);
}

function internalRefine(schema, refiner) {
  let mut = copy(schema);
  mut.b = (b, input, selfSchema, path) => transform(b, schema.b(b, input, schema, path), (b, input) => {
    let bb = {
      c: "",
      l: "",
      a: initialAllocate,
      g: b.g
    };
    let rCode = refiner(bb, input.v(bb), selfSchema, path);
    b.c = b.c + allocateScope(bb) + rCode;
    return input;
  });
  mut.output = () => {
    let schema$1 = reverse(schema);
    let mut = copy(schema$1);
    mut.b = (b, input, selfSchema, path) => {
      let input$1 = transform(b, input, (b, input) => {
        b.c = b.c + refiner(b, input.v(b), selfSchema, path);
        return input;
      });
      return schema$1.b(b, input$1, schema$1, path);
    };
    return mut;
  };
  return toStandard(mut);
}

function refine(schema, refiner) {
  return internalRefine(schema, (b, inputVar, selfSchema, path) => embed(b, refiner(effectCtx(b, selfSchema, path))) + "(" + inputVar + ");");
}

function addRefinement(schema, metadataId, refinement, refiner) {
  let refinements = schema[metadataId];
  return internalRefine(set$1(schema, metadataId, refinements !== undefined ? refinements.concat(refinement) : [refinement]), refiner);
}

function transform$1(schema, transformer) {
  let mut = copy(schema);
  mut.b = (b, input, selfSchema, path) => {
    let input$1 = schema.b(b, input, schema, path);
    let match = transformer(effectCtx(b, selfSchema, path));
    let parser = match.p;
    if (parser !== undefined) {
      if (match.a !== undefined) {
        return invalidOperation(b, path, "The S.transform doesn't allow parser and asyncParser at the same time. Remove parser in favor of asyncParser");
      } else {
        return embedSyncOperation(b, input$1, parser);
      }
    }
    let asyncParser = match.a;
    if (asyncParser !== undefined) {
      return embedAsyncOperation(b, input$1, asyncParser);
    } else if (match.s !== undefined) {
      return invalidOperation(b, path, "The S.transform parser is missing");
    } else {
      return input$1;
    }
  };
  mut.output = () => {
    let schema$1 = reverse(schema);
    return {
      type: "unknown",
      b: (b, input, selfSchema, path) => {
        let match = transformer(effectCtx(b, selfSchema, path));
        let serializer = match.s;
        if (serializer === undefined) {
          if (match.a !== undefined || match.p !== undefined) {
            return invalidOperation(b, path, "The S.transform serializer is missing");
          } else {
            return schema$1.b(b, input, schema$1, path);
          }
        }
        let input$1 = embedSyncOperation(b, input, serializer);
        return schema$1.b(b, input$1, schema$1, path);
      }
    };
  };
  mut.isAsync = undefined;
  return toStandard(mut);
}

function custom(name, definer) {
  return toStandard({
    type: "unknown",
    b: (b, input, selfSchema, path) => {
      let match = definer(effectCtx(b, selfSchema, path));
      let parser = match.p;
      if (parser !== undefined) {
        if (match.a !== undefined) {
          return invalidOperation(b, path, "The S.custom doesn't allow parser and asyncParser at the same time. Remove parser in favor of asyncParser");
        } else {
          return embedSyncOperation(b, input, parser);
        }
      }
      let asyncParser = match.a;
      if (asyncParser !== undefined) {
        return embedAsyncOperation(b, input, asyncParser);
      } else if (match.s !== undefined) {
        return invalidOperation(b, path, "The S.custom parser is missing");
      } else {
        return input;
      }
    },
    name: name,
    output: () => ({
      type: "unknown",
      b: (b, input, selfSchema, path) => {
        let match = definer(effectCtx(b, selfSchema, path));
        let serializer = match.s;
        if (serializer !== undefined) {
          return embedSyncOperation(b, input, serializer);
        } else if (match.a !== undefined || match.p !== undefined) {
          return invalidOperation(b, path, "The S.custom serializer is missing");
        } else {
          return input;
        }
      }
    })
  });
}

let unit = toStandard($$undefined);

function output() {
  return {
    type: "undefined",
    b: (b, param, param$1, param$2) => ({
      b: b,
      v: _notVar,
      i: "null",
      a: false
    }),
    const: (void 0)
  };
}

let nullAsUnit = toStandard({
  type: "null",
  b: (b, param, param$1, param$2) => ({
    b: b,
    v: _notVar,
    i: "void 0",
    a: false
  }),
  const: null,
  output: output
});

let unknown = toStandard({
  type: "unknown",
  b: noop
});

function builder(b, input, selfSchema, path) {
  b.c = b.c + failWithArg(b, path, input => ({
    TAG: "InvalidType",
    expected: selfSchema,
    received: input
  }), input.i) + ";";
  return input;
}

let schema = toStandard({
  type: "never",
  b: builder
});

function getItemCode(b, schema, input, output, deopt, path) {
  try {
    let bb = {
      c: "",
      l: "",
      a: initialAllocate,
      g: b.g
    };
    if (deopt) {
      bb.c = bb.c + typeFilterCode(bb, schema, input, path);
    }
    let itemOutput = schema.b(bb, input, schema, path);
    if (itemOutput !== input) {
      itemOutput.b = bb;
      if (schema.type === "unknown") {
        let reversed = reverse(schema);
        bb.c = bb.c + typeFilterCode(bb, reversed, itemOutput, path);
      }
      if (itemOutput.a) {
        output.a = true;
      }
      bb.c = bb.c + (output.v(b) + "=" + itemOutput.i);
    }
    return allocateScope(bb);
  } catch (exn) {
    return "throw " + embed(b, getOrRethrow(exn));
  }
}

function builder$1(b, input, selfSchema, path) {
  let fail = caught => embed(b, function () {
    let args = arguments;
    return raise(b, {
      TAG: "InvalidType",
      expected: selfSchema,
      received: args[0],
      unionErrors: args.length > 1 ? Array.from(args).slice(1) : undefined
    }, path);
  }) + "(" + input.v(b) + caught + ")";
  let schemas = selfSchema.anyOf;
  let typeValidation = b.g.o & 1;
  let initialInline = input.i;
  let deoptIdx = -1;
  let lastIdx = schemas.length - 1 | 0;
  let byTag = {};
  let tags = [];
  for (let idx = 0; idx <= lastIdx; ++idx) {
    let schema = schemas[idx];
    let tag = schema.type;
    let exit = 0;
    switch (tag) {
      case "never" :
      case "unknown" :
      case "union" :
      case "json" :
        exit = 1;
        break;
      default:
        let arr = byTag[tag];
        if (arr !== undefined) {
          if (tag !== "undefined" && tag !== "null" && tag !== "nan") {
            arr.push(schema);
          }
          
        } else {
          tags.push(tag);
          byTag[tag] = [schema];
        }
    }
    if (exit === 1) {
      deoptIdx = idx;
      byTag = {};
      tags = [];
    }
    
  }
  let deoptIdx$1 = deoptIdx;
  let byTag$1 = byTag;
  let tags$1 = tags;
  let start = "";
  let end = "";
  let caught = "";
  if (deoptIdx$1 !== -1) {
    for (let idx$1 = 0; idx$1 <= deoptIdx$1; ++idx$1) {
      let schema$1 = schemas[idx$1];
      let itemCode = getItemCode(b, schema$1, input, input, true, path);
      if (itemCode) {
        let errorVar = "e" + idx$1;
        start = start + ("try{" + itemCode + "}catch(" + errorVar + "){");
        end = "}" + end;
        caught = caught + "," + errorVar;
      }
      
    }
  }
  let nextElse = false;
  let noop = "";
  for (let idx$2 = 0, idx_finish = tags$1.length; idx$2 < idx_finish; ++idx$2) {
    let schemas$1 = byTag$1[tags$1[idx$2]];
    let inputVar = input.v(b);
    let isMultiple = schemas$1.length > 1;
    let firstSchema = schemas$1[0];
    let cond = "";
    let body;
    if (isMultiple) {
      let itemStart = "";
      let itemEnd = "";
      let itemNextElse = false;
      let itemNoop = "";
      let caught$1 = "";
      let itemIdx = 0;
      let lastIdx$1 = schemas$1.length - 1 | 0;
      while (itemIdx <= lastIdx$1) {
        let schema$2 = schemas$1[itemIdx];
        let itemCond = (
          c in schema$2 ? validation(b, inputVar, schema$2, false) : ""
        ) + refinement(b, inputVar, schema$2, false).slice(2);
        let itemCode$1 = getItemCode(b, schema$2, input, input, false, path);
        if (itemCond && !itemCode$1) {
          itemNoop = itemNoop ? itemNoop + "||" + itemCond : itemCond;
        } else if (itemNoop) {
          let if_ = itemNextElse ? "else if" : "if";
          itemStart = itemStart + if_ + ("(!(" + itemNoop + ")){");
          itemEnd = "}" + itemEnd;
          itemNoop = "";
          itemNextElse = false;
        }
        if (itemCond) {
          if (itemCode$1) {
            let if_$1 = itemNextElse ? "else if" : "if";
            itemStart = itemStart + if_$1 + ("(" + itemCond + "){" + itemCode$1 + "}");
            itemNextElse = true;
          }
          
        } else if (itemCode$1) {
          itemNextElse = false;
          let errorVar$1 = "e" + itemIdx;
          itemStart = itemStart + ("try{" + itemCode$1 + "}catch(" + errorVar$1 + "){");
          itemEnd = "}" + itemEnd;
          caught$1 = caught$1 + "," + errorVar$1;
        } else {
          itemIdx = lastIdx$1;
        }
        itemIdx = itemIdx + 1;
      };
      cond = validation(b, inputVar, {
        type: firstSchema.type,
        b: 0
      }, false);
      if (itemNoop) {
        if (itemStart) {
          if (typeValidation) {
            let if_$2 = itemNextElse ? "else if" : "if";
            itemStart = itemStart + if_$2 + ("(!(" + itemNoop + ")){" + fail(caught$1) + "}");
          }
          
        } else {
          cond = cond + ("&&(" + itemNoop + ")");
        }
      } else if (typeValidation && itemStart) {
        let errorCode = fail(caught$1);
        itemStart = itemStart + (
          itemNextElse ? "else{" + errorCode + "}" : errorCode
        );
      }
      body = itemStart + itemEnd;
    } else {
      cond = validation(b, inputVar, firstSchema, false) + refinement(b, inputVar, firstSchema, false);
      body = getItemCode(b, firstSchema, input, input, false, path);
    }
    let cond$1 = cond;
    if (body) {
      let if_$3 = nextElse ? "else if" : "if";
      start = start + if_$3 + ("(" + cond$1 + "){" + body + "}");
      nextElse = true;
    } else {
      noop = noop ? noop + "||" + cond$1 : cond$1;
    }
  }
  if (typeValidation || deoptIdx$1 === lastIdx) {
    let errorCode$1 = fail(caught);
    let tmp;
    if (noop) {
      let if_$4 = nextElse ? "else if" : "if";
      tmp = if_$4 + ("(!(" + noop + ")){" + errorCode$1 + "}");
    } else {
      tmp = nextElse ? "else{" + errorCode$1 + "}" : errorCode$1;
    }
    start = start + tmp;
  }
  b.c = b.c + start + end;
  if (input.a) {
    return {
      b: b,
      v: _notVar,
      i: "Promise.resolve(" + input.i + ")",
      a: true
    };
  } else if (input.v === _var) {
    if (b.c === "" && input.b.c === "" && (input.b.l === input.i + "=" + initialInline || initialInline === "i")) {
      input.b.l = "";
      input.b.a = initialAllocate;
      input.v = _notVar;
      input.i = initialInline;
      return input;
    } else {
      return {
        b: input.b,
        v: input.v,
        i: input.i,
        a: input.a
      };
    }
  } else {
    return input;
  }
}

function factory(schemas) {
  let len = schemas.length;
  if (len === 1) {
    return schemas[0];
  }
  if (len !== 0) {
    let has = {};
    let anyOf = new Set();
    for (let idx = 0, idx_finish = schemas.length; idx < idx_finish; ++idx) {
      let schema = schemas[idx];
      if (schema.type === "union" && schema.b === builder$1) {
        schema.anyOf.forEach(item => {
          anyOf.add(item);
        });
        Object.assign(has, schema.has);
      } else {
        anyOf.add(schema);
        let v = schema.type;
        let tmp;
        switch (v) {
          case "union" :
          case "json" :
            tmp = "unknown";
            break;
          default:
            tmp = v;
        }
        has[tmp] = true;
      }
    }
    return toStandard({
      type: "union",
      b: builder$1,
      has: has,
      anyOf: Array.from(anyOf),
      output: output$1
    });
  }
  throw new Error("[Schema] S.union requires at least one item");
}

function output$1() {
  let schemas = this.anyOf;
  let items = [];
  let toSelf = true;
  for (let idx = 0, idx_finish = schemas.length; idx < idx_finish; ++idx) {
    let schema = schemas[idx];
    let reversed = reverse(schema);
    items[idx] = reversed;
    toSelf = toSelf && schema === reversed;
  }
  if (toSelf) {
    return this;
  } else {
    return factory(items);
  }
}

let defaultMetadataId = "m:Option.default";

function $$default(schema) {
  return schema[defaultMetadataId];
}

let nestedLoc = "BS_PRIVATE_NESTED_SOME_NONE";

let inLoc = "\"" + nestedLoc + "\"";

function nestedNone() {
  let item_schema = parse(0);
  let item = {
    schema: item_schema,
    location: nestedLoc,
    inlinedLocation: inLoc
  };
  let fields = {};
  fields[nestedLoc] = item;
  return {
    type: "object",
    b: (b, param, selfSchema, param$1) => ({
      b: b,
      v: _notVar,
      i: inlineConst(b, reverse(selfSchema)),
      a: false
    }),
    additionalItems: "strip",
    items: [item],
    fields: fields
  };
}

function builder$2(b, param, selfSchema, param$1) {
  return {
    b: b,
    v: _notVar,
    i: "{" + inLoc + ":" + reverse(selfSchema).items[0].schema.const + "}",
    a: false
  };
}

function nestedOption(item) {
  let mut = copy(item);
  mut.output = nestedNone;
  mut.b = builder$2;
  return mut;
}

function factory$1(item, unitOpt) {
  let unit$1 = unitOpt !== undefined ? unitOpt : unit;
  let reversed = reverse(item);
  let match = reversed.type;
  switch (match) {
    case "undefined" :
      return factory([
        unit$1,
        nestedOption(item)
      ]);
    case "union" :
      let has = reversed.has;
      if (!("undefined" in has)) {
        return factory([
          item,
          unit$1
        ]);
      }
      let mut = copy(reversed);
      let schemas = mut.anyOf;
      let has$1 = mut.has;
      let anyOf = [];
      for (let idx = 0, idx_finish = schemas.length; idx < idx_finish; ++idx) {
        let schema = schemas[idx];
        let match$1 = schema.type;
        let tmp;
        if (match$1 === "undefined") {
          if (!("object" in has$1)) {
            let d = {};
            d["object"] = true;
            mut.has = Object.assign(d, has$1);
          }
          anyOf.push(reverse(unit$1));
          tmp = reverse(nestedOption(reverse(schema)));
        } else {
          let fields = schema.fields;
          if (fields !== undefined) {
            let item$1 = fields[nestedLoc];
            if (item$1 !== undefined) {
              let fSchema = item$1.schema;
              let newItem_schema = {
                type: fSchema.type,
                b: fSchema.b,
                const: fSchema.const + 1
              };
              let newItem_location = item$1.location;
              let newItem_inlinedLocation = item$1.inlinedLocation;
              let newItem = {
                schema: newItem_schema,
                location: newItem_location,
                inlinedLocation: newItem_inlinedLocation
              };
              let mut$1 = copy(schema);
              let fields$1 = {};
              fields$1[nestedLoc] = newItem;
              mut$1.items = [newItem];
              mut$1.fields = fields$1;
              reverse(mut$1).output = mut$1;
              tmp = mut$1;
            } else {
              tmp = schema;
            }
          } else {
            tmp = schema;
          }
        }
        anyOf.push(tmp);
      }
      mut.anyOf = anyOf;
      mut.output = output$1;
      return reverse(mut);
    default:
      return factory([
        item,
        unit$1
      ]);
  }
}

function getWithDefault(schema, $$default) {
  let mut = copy(schema);
  mut[defaultMetadataId] = $$default;
  mut.b = (b, input, param, path) => transform(b, schema.b(b, input, schema, path), (b, input) => {
    let inputVar = input.v(b);
    let tmp;
    tmp = $$default.TAG === "Value" ? embed(b, $$default._0) : embed(b, $$default._0) + "()";
    return {
      b: b,
      v: _notVar,
      i: inputVar + "===void 0?" + tmp + ":" + inputVar,
      a: false
    };
  });
  mut.output = () => {
    let reversed = reverse(schema);
    let anyOf = reversed.anyOf;
    if (anyOf !== undefined) {
      return factory(anyOf.filter(s => !isOptional(s)));
    } else {
      return reversed;
    }
  };
  return toStandard(mut);
}

function getOr(schema, defalutValue) {
  return getWithDefault(schema, {
    TAG: "Value",
    _0: defalutValue
  });
}

function getOrWith(schema, defalutCb) {
  return getWithDefault(schema, {
    TAG: "Callback",
    _0: defalutCb
  });
}

let metadataId = "m:Array.refinements";

function refinements(schema) {
  let m = schema[metadataId];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

function factory$2(item$1) {
  return toStandard({
    type: "array",
    b: (b, input, param, path) => {
      let inputVar = input.v(b);
      let iteratorVar = varWithoutAllocation(b.g);
      let bb = {
        c: "",
        l: "",
        a: initialAllocate,
        g: b.g
      };
      let itemInput = {
        b: bb,
        v: _notVar,
        i: inputVar + "[" + iteratorVar + "]",
        a: false
      };
      let itemOutput = withPathPrepend(bb, itemInput, path, iteratorVar, undefined, (b, input, path) => parseWithTypeValidation(b, item$1, input, path));
      let itemCode = allocateScope(bb);
      let isTransformed = itemInput !== itemOutput;
      let output = isTransformed ? ({
          b: b,
          v: _notVar,
          i: "new Array(" + inputVar + ".length)",
          a: false
        }) : input;
      if (isTransformed || itemCode !== "") {
        b.c = b.c + ("for(let " + iteratorVar + "=0;" + iteratorVar + "<" + inputVar + ".length;++" + iteratorVar + "){" + itemCode + (
          isTransformed ? addKey(b, output, iteratorVar, itemOutput) : ""
        ) + "}");
      }
      if (itemOutput.a) {
        return {
          b: output.b,
          v: _notVar,
          i: "Promise.all(" + output.i + ")",
          a: true
        };
      } else {
        return output;
      }
    },
    additionalItems: item$1,
    items: immutableEmpty$1,
    output: item(factory$2, item$1)
  });
}

function setAdditionalItems(schema, additionalItems, deep) {
  let currentAdditionalItems = schema.additionalItems;
  if (currentAdditionalItems === undefined) {
    return schema;
  }
  let items = schema.items;
  if (currentAdditionalItems === additionalItems || typeof currentAdditionalItems === "object") {
    return schema;
  }
  let mut = copy(schema);
  mut.additionalItems = additionalItems;
  if (deep) {
    let newItems = [];
    let newFields = {};
    for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
      let item = items[idx];
      let newSchema = setAdditionalItems(item.schema, additionalItems, deep);
      let newItem = newSchema === item.schema ? item : ({
          schema: newSchema,
          location: item.location,
          inlinedLocation: item.inlinedLocation
        });
      newFields[item.location] = newItem;
      newItems.push(newItem);
    }
    mut.items = newItems;
    mut.fields = newFields;
  }
  return toStandard(mut);
}

function strip(schema) {
  return setAdditionalItems(schema, "strip", false);
}

function deepStrip(schema) {
  return setAdditionalItems(schema, "strip", true);
}

function strict(schema) {
  return setAdditionalItems(schema, "strict", false);
}

function deepStrict(schema) {
  return setAdditionalItems(schema, "strict", true);
}

function factory$3(item$1) {
  return toStandard({
    type: "object",
    b: (b, input, param, path) => {
      let inputVar = input.v(b);
      let keyVar = varWithoutAllocation(b.g);
      let bb = {
        c: "",
        l: "",
        a: initialAllocate,
        g: b.g
      };
      let itemInput = {
        b: bb,
        v: _notVar,
        i: inputVar + "[" + keyVar + "]",
        a: false
      };
      let itemOutput = withPathPrepend(bb, itemInput, path, keyVar, undefined, (b, input, path) => parseWithTypeValidation(b, item$1, input, path));
      let itemCode = allocateScope(bb);
      let isTransformed = itemInput !== itemOutput;
      let output = isTransformed ? ({
          b: b,
          v: _notVar,
          i: "{}",
          a: false
        }) : input;
      if (isTransformed || itemCode !== "") {
        b.c = b.c + ("for(let " + keyVar + " in " + inputVar + "){" + itemCode + (
          isTransformed ? addKey(b, output, keyVar, itemOutput) : ""
        ) + "}");
      }
      if (!itemOutput.a) {
        return output;
      }
      let resolveVar = varWithoutAllocation(b.g);
      let rejectVar = varWithoutAllocation(b.g);
      let asyncParseResultVar = varWithoutAllocation(b.g);
      let counterVar = varWithoutAllocation(b.g);
      let outputVar = output.v(b);
      return {
        b: b,
        v: _notVar,
        i: "new Promise((" + resolveVar + "," + rejectVar + ")=>{let " + counterVar + "=Object.keys(" + outputVar + ").length;for(let " + keyVar + " in " + outputVar + "){" + outputVar + "[" + keyVar + "].then(" + asyncParseResultVar + "=>{" + outputVar + "[" + keyVar + "]=" + asyncParseResultVar + ";if(" + counterVar + "--===1){" + resolveVar + "(" + outputVar + ")}}," + rejectVar + ")}})",
        a: true
      };
    },
    additionalItems: item$1,
    items: immutableEmpty$1,
    fields: immutableEmpty,
    output: item(factory$3, item$1)
  });
}

let Tuple = {};

let metadataId$1 = "m:String.refinements";

function refinements$1(schema) {
  let m = schema[metadataId$1];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

let cuidRegex = /^c[^\s-]{8,}$/i;

let uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;

let emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;

let datetimeRe = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/;

let schema$1 = toStandard({
  type: "string",
  b: noop
});

function factory$4(item, spaceOpt) {
  let space = spaceOpt !== undefined ? spaceOpt : 0;
  return toStandard({
    type: "string",
    b: (b, input, param, path) => {
      let jsonVal = allocateVal(b);
      b.c = b.c + ("try{" + jsonVal.i + "=JSON.parse(" + input.i + ")}catch(t){" + failWithArg(b, path, message => ({
        TAG: "OperationFailed",
        _0: message
      }), "t.message") + "}");
      return parseWithTypeValidation(b, item, jsonVal, path);
    },
    output: () => {
      let reversed = reverse(item);
      let mut = copy(reversed);
      mut.b = (b, input, param, path) => {
        let prevFlag = b.g.o;
        b.g.o = prevFlag | 8;
        jsonableValidation(reversed, reversed, "", b.g.o);
        let output = {
          b: b,
          v: _notVar,
          i: "JSON.stringify(" + reversed.b(b, input, reversed, path).i + (
            space > 0 ? ",null," + space : ""
          ) + ")",
          a: false
        };
        b.g.o = prevFlag;
        return output;
      };
      return mut;
    }
  });
}

let schema$2 = toStandard({
  type: "boolean",
  b: noop
});

let metadataId$2 = "m:Int.refinements";

function refinements$2(schema) {
  let m = schema[metadataId$2];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

let schema$3 = toStandard({
  type: "number",
  b: noop,
  format: "int32"
});

let metadataId$3 = "m:Float.refinements";

function refinements$3(schema) {
  let m = schema[metadataId$3];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

let schema$4 = toStandard({
  type: "number",
  b: noop
});

let schema$5 = toStandard({
  type: "bigint",
  b: noop
});

function to(from, target) {
  if (from === target) {
    return from;
  }
  let anyOf = target.anyOf;
  if (anyOf !== undefined) {
    return factory(anyOf.map(target => to(from, target)));
  }
  let extendCoercion = 0;
  let shrinkCoercion = 1;
  let fromOutput = reverse(from);
  let isFromLiteral = c in from;
  let isTargetLiteral = c in target;
  let match = fromOutput.type;
  let coercion;
  let exit = 0;
  let exit$1 = 0;
  let match$1 = target.type;
  if (isFromLiteral && isTargetLiteral) {
    coercion = (b, param, param$1) => ({
      b: b,
      v: _notVar,
      i: inlineConst(b, target),
      a: false
    });
  } else if (match$1 === "unknown") {
    coercion = extendCoercion;
  } else {
    switch (match) {
      case "string" :
        let match$2 = target.type;
        let exit$2 = 0;
        switch (match$2) {
          case "string" :
            let match$3 = target.const;
            coercion = match$3 !== undefined ? shrinkCoercion : extendCoercion;
            break;
          case "number" :
          case "bigint" :
          case "boolean" :
          case "null" :
          case "undefined" :
          case "nan" :
            exit$2 = 3;
            break;
          default:
            exit = 1;
        }
        if (exit$2 === 3) {
          let $$const = target.const;
          if (isTargetLiteral) {
            coercion = (b, inputVar, failCoercion) => {
              b.c = b.c + (inputVar + "===\"" + $$const + "\"||" + failCoercion + ";");
              return {
                b: b,
                v: _notVar,
                i: inlineConst(b, target),
                a: false
              };
            };
          } else {
            switch (match$2) {
              case "number" :
                let format = target.format;
                coercion = (b, inputVar, failCoercion) => {
                  let output = {
                    b: b,
                    v: _notVar,
                    i: "+" + inputVar,
                    a: false
                  };
                  let outputVar = output.v(b);
                  let tmp;
                  tmp = format !== undefined ? (
                      format === "Tbd" ? "Number.isNaN(" + outputVar + ")" : "(" + refinement(b, outputVar, target, true).slice(2) + ")"
                    ) : "Number.isNaN(" + outputVar + ")";
                  b.c = b.c + tmp + ("&&" + failCoercion + ";");
                  return output;
                };
                break;
              case "bigint" :
                coercion = (b, inputVar, failCoercion) => {
                  let output = allocateVal(b);
                  b.c = b.c + ("try{" + output.i + "=BigInt(" + inputVar + ")}catch(_){" + failCoercion + "}");
                  return output;
                };
                break;
              case "boolean" :
                coercion = (b, inputVar, failCoercion) => {
                  let output = allocateVal(b);
                  b.c = b.c + ("(" + output.i + "=" + inputVar + "===\"true\")||" + inputVar + "===\"false\"||" + failCoercion + ";");
                  return output;
                };
                break;
              default:
                exit = 1;
            }
          }
        }
        break;
      case "number" :
        if (fromOutput.format === "Tbd") {
          exit$1 = 2;
        } else {
          let match$4 = target.type;
          if (match$4 === "number" && target.format === undefined) {
            coercion = extendCoercion;
          } else {
            exit$1 = 2;
          }
        }
        break;
      case "unknown" :
        coercion = shrinkCoercion;
        break;
      case "bigint" :
      case "boolean" :
      case "null" :
      case "undefined" :
      case "nan" :
        exit$1 = 2;
        break;
      default:
        exit = 1;
    }
  }
  if (exit$1 === 2) {
    let $$const$1 = fromOutput.const;
    let match$5 = target.type;
    if (match$5 === "string") {
      if (isFromLiteral) {
        coercion = (b, param, param$1) => ({
          b: b,
          v: _notVar,
          i: "\"" + $$const$1 + "\"",
          a: false
        });
      } else {
        let exit$3 = 0;
        switch (match) {
          case "number" :
          case "bigint" :
          case "boolean" :
            exit$3 = 3;
            break;
          default:
            exit = 1;
        }
        if (exit$3 === 3) {
          let match$6 = target.type;
          if (match$6 === "string") {
            coercion = (b, inputVar, param) => ({
              b: b,
              v: _notVar,
              i: "\"\"+" + inputVar,
              a: false
            });
          } else {
            exit = 1;
          }
        }
        
      }
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    let message = "S.to from " + toExpression(fromOutput) + " to " + toExpression(target) + " is not supported";
    throw new Error("[Schema] " + message);
  }
  let mut = copy(from);
  mut.b = (b, input, param, path) => {
    let input$1 = from.b(b, input, from, path);
    if (coercion === extendCoercion) {
      return target.b(b, input$1, target, path);
    }
    if (coercion === shrinkCoercion) {
      return parseWithTypeValidation(b, target, input$1, path);
    }
    let bb = {
      c: "",
      l: "",
      a: initialAllocate,
      g: b.g
    };
    let inputVar = input$1.v(bb);
    let input$2 = coercion(bb, inputVar, failWithArg(bb, path, input => ({
      TAG: "InvalidType",
      expected: target,
      received: input
    }), inputVar));
    let output = target.b(bb, input$2, target, path);
    b.c = b.c + allocateScope(bb);
    return output;
  };
  mut.output = () => to(reverse(target), fromOutput);
  return toStandard(mut);
}

function list(schema) {
  return transform$1(factory$2(schema), param => ({
    p: Belt_List.fromArray,
    s: Belt_List.toArray
  }));
}

function json(validate) {
  return toStandard({
    type: "json",
    b: validate ? (b, input, selfSchema, path) => {
        let parse = (input, pathOpt) => {
          let path$1 = pathOpt !== undefined ? pathOpt : path;
          let match = typeof input;
          if (match === "string" || match === "boolean") {
            return input;
          }
          if (match === "object") {
            if (input === null) {
              return input;
            }
            if (Array.isArray(input)) {
              let output = [];
              for (let idx = 0, idx_finish = input.length; idx < idx_finish; ++idx) {
                let inputItem = input[idx];
                let location = idx.toString();
                output.push(parse(inputItem, path$1 + ("[" + fromString(location) + "]")));
              }
              return output;
            }
            let keys = Object.keys(input);
            let output$1 = {};
            for (let idx$1 = 0, idx_finish$1 = keys.length; idx$1 < idx_finish$1; ++idx$1) {
              let key = keys[idx$1];
              let field = input[key];
              output$1[key] = parse(field, path$1 + ("[" + fromString(key) + "]"));
            }
            return output$1;
          }
          if (match === "number" && !Number.isNaN(input)) {
            return input;
          }
          return raise(b, {
            TAG: "InvalidType",
            expected: selfSchema,
            received: input
          }, path$1);
        };
        return map(embed(b, parse), input);
      } : noop,
    output: function () {
      if (validate) {
        return json(false);
      } else {
        return this;
      }
    }
  });
}

let Catch = {};

function $$catch(schema, getFallbackValue) {
  let mut = copy(schema);
  mut.b = (b, input, selfSchema, path) => {
    let inputVar = input.v(b);
    return withCatch(b, input, (b, errorVar) => ({
      b: b,
      v: _notVar,
      i: embed(b, (input, internalError) => getFallbackValue({
        e: internalError,
        i: input,
        s: selfSchema,
        f: (message, customPathOpt) => {
          let customPath = customPathOpt !== undefined ? customPathOpt : "";
          return raise(b, {
            TAG: "OperationFailed",
            _0: message
          }, path + customPath);
        }
      })) + "(" + inputVar + "," + errorVar + ")",
      a: false
    }), undefined, b => parseWithTypeValidation(b, schema, input, path));
  };
  mut.noValidation = true;
  mut.catch = true;
  return toStandard(mut);
}

function meta(schema, meta$1) {
  let mut = copy(schema);
  let name = meta$1.name;
  if (name !== undefined) {
    if (name === "") {
      mut.name = undefined;
    } else {
      mut.name = name;
    }
  }
  let description = meta$1.description;
  if (description !== undefined) {
    if (description === "") {
      mut.description = undefined;
    } else {
      mut.description = description;
    }
  }
  let deprecated = meta$1.deprecated;
  if (deprecated !== undefined) {
    mut.deprecated = deprecated;
  }
  return toStandard(mut);
}

function getFullDitemPath(ditem) {
  switch (ditem.k) {
    case 0 :
      return "[" + ditem.inlinedLocation + "]";
    case 1 :
      return getFullDitemPath(ditem.of) + ditem.p;
    case 2 :
      return ditem.p;
  }
}

function getItemReversed(item) {
  switch (item.k) {
    case 1 :
      let schema = item.schema;
      let location = item.location;
      if (schema !== undefined) {
        return reverse(schema);
      }
      let targetReversed = getItemReversed(item.of);
      let items = targetReversed.items;
      let fields = targetReversed.fields;
      let maybeReversedItem = fields !== undefined ? fields[location] : items[location];
      if (maybeReversedItem === undefined) {
        let message = "Impossible to reverse the " + item.inlinedLocation + " access of '" + toExpression(targetReversed) + "' schema";
        throw new Error("[Schema] " + message);
      }
      return maybeReversedItem.schema;
    case 0 :
    case 2 :
      return reverse(item.schema);
  }
}

function definitionToOutput(b, definition, getItemOutput) {
  if (typeof definition !== "object" || definition === null) {
    return {
      b: b,
      v: _var,
      i: embed(b, definition),
      a: false
    };
  }
  let item = definition[itemSymbol];
  if (item !== undefined) {
    return getItemOutput(item);
  }
  let isArray = Array.isArray(definition);
  let keys = Object.keys(definition);
  let objectVal = make(b, isArray);
  for (let idx = 0, idx_finish = keys.length; idx < idx_finish; ++idx) {
    let key = keys[idx];
    add(objectVal, isArray ? "\"" + key + "\"" : fromString(key), definitionToOutput(b, definition[key], getItemOutput));
  }
  return complete(objectVal, isArray);
}

function objectStrictModeCheck(b, input, items, selfSchema, path) {
  if (!(selfSchema.type === "object" && selfSchema.additionalItems === "strict" && b.g.o & 1)) {
    return;
  }
  let key = allocateVal(b);
  let keyVar = key.i;
  b.c = b.c + ("for(" + keyVar + " in " + input.i + "){if(");
  if (items.length !== 0) {
    for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
      let match = items[idx];
      if (idx !== 0) {
        b.c = b.c + "&&";
      }
      b.c = b.c + (keyVar + "!==" + match.inlinedLocation);
    }
  } else {
    b.c = b.c + "true";
  }
  b.c = b.c + ("){" + failWithArg(b, path, exccessFieldName => ({
    TAG: "ExcessField",
    _0: exccessFieldName
  }), keyVar) + "}}");
}

function proxify(item) {
  return new Proxy(immutableEmpty, {
    get: (param, prop) => {
      if (prop === itemSymbol) {
        return item;
      }
      let inlinedLocation = fromString(prop);
      return proxify({
        k: 1,
        inlinedLocation: inlinedLocation,
        location: prop,
        of: item,
        p: "[" + inlinedLocation + "]"
      });
    }
  });
}

function builder$3(parentB, input, selfSchema, path) {
  let additionalItems = selfSchema.additionalItems;
  let items = selfSchema.items;
  let isArray = selfSchema.type === "array";
  if (parentB.g.o & 64) {
    let objectVal = make(parentB, isArray);
    for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
      let match = items[idx];
      let inlinedLocation = match.inlinedLocation;
      add(objectVal, inlinedLocation, input[inlinedLocation]);
    }
    return complete(objectVal, isArray);
  }
  let b = {
    c: "",
    l: "",
    a: initialAllocate,
    g: parentB.g
  };
  let objectVal$1 = make(b, isArray);
  for (let idx$1 = 0, idx_finish$1 = items.length; idx$1 < idx_finish$1; ++idx$1) {
    let match$1 = items[idx$1];
    let inlinedLocation$1 = match$1.inlinedLocation;
    let schema = match$1.schema;
    let itemPath = "[" + inlinedLocation$1 + "]";
    let itemInput = get(b, input, inlinedLocation$1);
    let path$1 = path + itemPath;
    if (b.g.o & 1 ? !(c in schema) : c in schema && (itemInput.v !== _var || itemInput.i[0] !== "e")) {
      b.c = b.c + typeFilterCode(b, schema, itemInput, path$1);
    }
    add(objectVal$1, inlinedLocation$1, schema.b(b, itemInput, schema, path$1));
  }
  objectStrictModeCheck(b, input, items, selfSchema, path);
  parentB.c = parentB.c + allocateScope(b);
  if ((additionalItems !== "strip" || b.g.o & 32) && selfSchema === reverse(selfSchema)) {
    objectVal$1.v = input.v;
    objectVal$1.i = input.i;
    objectVal$1.a = input.a;
    return objectVal$1;
  } else {
    return complete(objectVal$1, isArray);
  }
}

function output$2() {
  let items = this.items;
  let reversedFields = {};
  let reversedItems = [];
  let isTransformed = false;
  for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
    let match = items[idx];
    let location = match.location;
    let schema = match.schema;
    let reversed = reverse(schema);
    let item_inlinedLocation = match.inlinedLocation;
    let item = {
      schema: reversed,
      location: location,
      inlinedLocation: item_inlinedLocation
    };
    reversedFields[location] = item;
    reversedItems.push(item);
    if (schema !== reversed) {
      isTransformed = true;
    }
    
  }
  if (isTransformed) {
    return {
      type: "object",
      b: builder$3,
      additionalItems: globalConfig.a,
      items: reversedItems,
      fields: reversedFields
    };
  } else {
    return this;
  }
}

function definitionToRitem(definition, path, ritems, ritemsByItemPath) {
  if (typeof definition !== "object" || definition === null) {
    return {
      k: 1,
      p: path,
      s: parse(definition)
    };
  }
  let item = definition[itemSymbol];
  if (item !== undefined) {
    let ritem_2 = getItemReversed(item);
    let ritem = {
      k: 0,
      p: path,
      i: item,
      s: ritem_2
    };
    item.r = ritem;
    ritemsByItemPath[getFullDitemPath(item)] = ritem;
    return ritem;
  }
  if (Array.isArray(definition)) {
    let items = [];
    for (let idx = 0, idx_finish = definition.length; idx < idx_finish; ++idx) {
      let location = idx.toString();
      let inlinedLocation = "\"" + location + "\"";
      let ritem$1 = definitionToRitem(definition[idx], path + ("[" + inlinedLocation + "]"), ritems, ritemsByItemPath);
      ritems.push(ritem$1);
      let item_schema = ritem$1.s;
      let item$1 = {
        schema: item_schema,
        location: location,
        inlinedLocation: inlinedLocation
      };
      items[idx] = item$1;
    }
    return {
      k: 2,
      p: path,
      s: {
        type: "array",
        b: builder,
        additionalItems: "strict",
        items: items,
        output: output$2
      },
      a: true
    };
  }
  let fieldNames = Object.keys(definition);
  let fields = {};
  let items$1 = [];
  for (let idx$1 = 0, idx_finish$1 = fieldNames.length; idx$1 < idx_finish$1; ++idx$1) {
    let location$1 = fieldNames[idx$1];
    let inlinedLocation$1 = fromString(location$1);
    let ritem$2 = definitionToRitem(definition[location$1], path + ("[" + inlinedLocation$1 + "]"), ritems, ritemsByItemPath);
    ritems.push(ritem$2);
    let item_schema$1 = ritem$2.s;
    let item$2 = {
      schema: item_schema$1,
      location: location$1,
      inlinedLocation: inlinedLocation$1
    };
    items$1[idx$1] = item$2;
    fields[location$1] = item$2;
  }
  return {
    k: 2,
    p: path,
    s: {
      type: "object",
      b: builder,
      advanced: true,
      additionalItems: globalConfig.a,
      items: items$1,
      fields: fields,
      output: output$2
    },
    a: false
  };
}

function definitionToSchema(definition) {
  if (typeof definition !== "object" || definition === null) {
    return parse(definition);
  }
  if (definition["~standard"]) {
    return definition;
  }
  if (Array.isArray(definition)) {
    let reversedItems = [];
    let isTransformed = false;
    for (let idx = 0, idx_finish = definition.length; idx < idx_finish; ++idx) {
      let schema = definitionToSchema(definition[idx]);
      let reversed = reverse(schema);
      let location = idx.toString();
      let inlinedLocation = "\"" + location + "\"";
      definition[idx] = {
        schema: schema,
        location: location,
        inlinedLocation: inlinedLocation
      };
      reversedItems[idx] = {
        schema: reversed,
        location: location,
        inlinedLocation: inlinedLocation
      };
      if (schema !== reversed) {
        isTransformed = true;
      }
      
    }
    return {
      type: "array",
      b: builder$3,
      additionalItems: "strict",
      items: definition,
      output: isTransformed ? () => ({
          type: "array",
          b: builder$3,
          additionalItems: "strict",
          items: reversedItems
        }) : undefined
    };
  }
  let fieldNames = Object.keys(definition);
  let length = fieldNames.length;
  let items = [];
  for (let idx$1 = 0; idx$1 < length; ++idx$1) {
    let location$1 = fieldNames[idx$1];
    let inlinedLocation$1 = fromString(location$1);
    let schema$1 = definitionToSchema(definition[location$1]);
    let item = {
      schema: schema$1,
      location: location$1,
      inlinedLocation: inlinedLocation$1
    };
    definition[location$1] = item;
    items[idx$1] = item;
  }
  return {
    type: "object",
    b: builder$3,
    additionalItems: globalConfig.a,
    items: items,
    fields: definition,
    output: output$2
  };
}

function nested(fieldName) {
  let parentCtx = this;
  let cacheId = "~" + fieldName;
  let ctx = parentCtx[cacheId];
  if (ctx !== undefined) {
    return Primitive_option.valFromOption(ctx);
  }
  let schemas = [];
  let fields = {};
  let items = [];
  let schema = toStandard({
    type: "object",
    b: builder$3,
    additionalItems: globalConfig.a,
    items: items,
    fields: fields,
    output: output$2
  });
  let target = parentCtx.f(fieldName, schema)[itemSymbol];
  let field = (fieldName, schema) => {
    let inlinedLocation = fromString(fieldName);
    if (fieldName in fields) {
      throw new Error("[Schema] " + ("The field " + inlinedLocation + " defined twice"));
    }
    let ditem_2 = schema;
    let ditem_4 = "[" + inlinedLocation + "]";
    let ditem = {
      k: 1,
      inlinedLocation: inlinedLocation,
      location: fieldName,
      schema: ditem_2,
      of: target,
      p: ditem_4
    };
    fields[fieldName] = ditem;
    items.push(ditem);
    schemas.push(schema);
    return proxify(ditem);
  };
  let tag = (tag$1, asValue) => {
    field(tag$1, definitionToSchema(asValue));
  };
  let fieldOr = (fieldName, schema, or) => {
    let schema$1 = factory$1(schema, undefined);
    return field(fieldName, getWithDefault(schema$1, {
      TAG: "Value",
      _0: or
    }));
  };
  let flatten = schema => {
    let match = schema.type;
    if (match === "object") {
      let flattenedItems = schema.items;
      if (schema.advanced) {
        let message = "Unsupported nested flatten for advanced object schema '" + toExpression(schema) + "'";
        throw new Error("[Schema] " + message);
      }
      let match$1 = reverse(schema);
      let match$2 = match$1.type;
      if (match$2 === "object" && match$1.advanced !== true) {
        let result = {};
        for (let idx = 0, idx_finish = flattenedItems.length; idx < idx_finish; ++idx) {
          let item = flattenedItems[idx];
          result[item.location] = field(item.location, item.schema);
        }
        return result;
      }
      let message$1 = "Unsupported nested flatten for transformed schema '" + toExpression(schema) + "'";
      throw new Error("[Schema] " + message$1);
    }
    let message$2 = "The '" + toExpression(schema) + "' schema can't be flattened";
    throw new Error("[Schema] " + message$2);
  };
  let ctx$1 = {
    field: field,
    f: field,
    fieldOr: fieldOr,
    tag: tag,
    nested: nested,
    flatten: flatten
  };
  parentCtx[cacheId] = ctx$1;
  return ctx$1;
}

function advancedReverse(definition, to, flattened) {
  return function () {
    let originalSchema = this;
    let ritemsByItemPath = {};
    let ritems = [];
    let ritem = definitionToRitem(definition, "", ritems, ritemsByItemPath);
    let mut;
    switch (ritem.k) {
      case 0 :
      case 1 :
        mut = copy(ritem.s);
        break;
      case 2 :
        mut = ritem.s;
        break;
    }
    mut.b = (b, input, selfSchema, path) => {
      let hasTypeValidation = b.g.o & 1;
      for (let idx = 0, idx_finish = ritems.length; idx < idx_finish; ++idx) {
        let match = ritems[idx];
        switch (match.k) {
          case 0 :
            break;
          case 1 :
            if (!hasTypeValidation) {
              let rpath = match.p;
              let itemInput = {
                b: b,
                v: _notVar,
                i: input.v(b) + rpath,
                a: false
              };
              let path$1 = path + rpath;
              b.c = b.c + typeFilterCode(b, match.s, itemInput, path$1);
            }
            break;
          case 2 :
            if (hasTypeValidation) {
              invalidOperation(b, path, "Type validation mode is not supported");
            }
            break;
        }
      }
      let getRitemInput = ritem => {
        if (ritem.p === "") {
          return input;
        } else {
          return {
            b: b,
            v: _notVar,
            i: input.v(b) + ritem.p,
            a: false
          };
        }
      };
      let reversedToInput = (reversed, originalPath) => {
        if (c in reversed) {
          return {
            b: b,
            v: _var,
            i: embed(b, reversed.const),
            a: false
          };
        }
        let tag = reversed.type;
        let additionalItems = reversed.additionalItems;
        let items = reversed.items;
        if (items !== undefined && typeof additionalItems === "string") {
          let isArray = tag === "array";
          let objectVal = make(b, isArray);
          for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
            let item = items[idx];
            let itemPath = originalPath + ("[" + item.inlinedLocation + "]");
            let ritem = ritemsByItemPath[itemPath];
            let itemInput = ritem !== undefined ? getRitemInput(ritem) : reversedToInput(item.schema, itemPath);
            add(objectVal, item.inlinedLocation, itemInput);
          }
          return complete(objectVal, isArray);
        }
        let tmp = originalPath === "" ? "Schema isn't registered" : "Schema for " + originalPath + " isn't registered";
        return invalidOperation(b, path, tmp);
      };
      let getItemOutput = (item, itemPath) => {
        let ritem = item.r;
        if (ritem !== undefined) {
          let reversed = ritem.s;
          let itemInput = getRitemInput(ritem);
          let path$2 = path + ritem.p;
          if (ritem.p !== "" && (
              hasTypeValidation ? !(c in reversed) : c in reversed
            )) {
            b.c = b.c + typeFilterCode(b, reversed, itemInput, path$2);
          }
          return reversed.b(b, itemInput, reversed, path$2);
        }
        let reversed$1 = reverse(item.schema);
        let input = reversedToInput(reversed$1, itemPath);
        let prevFlag = b.g.o;
        b.g.o = (prevFlag | 1) ^ 1;
        let output = reversed$1.b(b, input, reversed$1, path);
        b.g.o = prevFlag;
        return output;
      };
      if (to !== undefined) {
        return getItemOutput(to, "");
      }
      objectStrictModeCheck(b, input, selfSchema.items, selfSchema, path);
      let isArray = originalSchema.type === "array";
      let items = originalSchema.items;
      let objectVal = make(b, isArray);
      if (flattened !== undefined) {
        for (let idx$1 = 0, idx_finish$1 = flattened.length; idx$1 < idx_finish$1; ++idx$1) {
          merge(objectVal, getItemOutput(flattened[idx$1], ""));
        }
      }
      for (let idx$2 = 0, idx_finish$2 = items.length; idx$2 < idx_finish$2; ++idx$2) {
        let item = items[idx$2];
        if (!(item.inlinedLocation in objectVal)) {
          add(objectVal, item.inlinedLocation, getItemOutput(item, "[" + item.inlinedLocation + "]"));
        }
        
      }
      return complete(objectVal, isArray);
    };
    return mut;
  };
}

function advancedBuilder(definition, flattened) {
  return (parentB, input, selfSchema, path) => {
    let isFlatten = parentB.g.o & 64;
    let outputs = isFlatten ? input : ({});
    let b = {
      c: "",
      l: "",
      a: initialAllocate,
      g: parentB.g
    };
    if (!isFlatten) {
      let items = selfSchema.items;
      let inputVar = input.v(b);
      for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
        let match = items[idx];
        let inlinedLocation = match.inlinedLocation;
        let schema = match.schema;
        let itemPath = "[" + inlinedLocation + "]";
        let itemInput = {
          b: b,
          v: _notVar,
          i: inputVar + itemPath,
          a: false
        };
        let path$1 = path + itemPath;
        if (b.g.o & 1 ? !(c in schema) : c in schema) {
          b.c = b.c + typeFilterCode(b, schema, itemInput, path$1);
        }
        outputs[inlinedLocation] = schema.b(b, itemInput, schema, path$1);
      }
      objectStrictModeCheck(b, input, items, selfSchema, path);
    }
    if (flattened !== undefined) {
      let prevFlag = b.g.o;
      b.g.o = prevFlag | 64;
      for (let idx$1 = 0, idx_finish$1 = flattened.length; idx$1 < idx_finish$1; ++idx$1) {
        let item = flattened[idx$1];
        let schema$1 = item.schema;
        outputs[item.i] = schema$1.b(b, outputs, schema$1, path);
      }
      b.g.o = prevFlag;
    }
    let getItemOutput = item => {
      switch (item.k) {
        case 0 :
          return outputs[item.inlinedLocation];
        case 1 :
          return get(b, getItemOutput(item.of), item.inlinedLocation);
        case 2 :
          return outputs[item.i];
      }
    };
    let output = definitionToOutput(b, definition, getItemOutput);
    parentB.c = parentB.c + allocateScope(b);
    return output;
  };
}

function shape(schema, definer) {
  let mut = copy(schema);
  let item = {
    k: 2,
    schema: schema,
    p: "",
    i: 0
  };
  let definition = definer(proxify(item));
  mut.b = (b, input, param, path) => {
    let itemOutput = schema.b(b, input, schema, path);
    let bb = {
      c: "",
      l: "",
      a: initialAllocate,
      g: b.g
    };
    let getItemOutput = item => {
      switch (item.k) {
        case 1 :
          return get(bb, getItemOutput(item.of), item.inlinedLocation);
        case 0 :
        case 2 :
          return itemOutput;
      }
    };
    let output = definitionToOutput(bb, definition, getItemOutput);
    b.c = b.c + allocateScope(bb);
    return output;
  };
  mut.output = advancedReverse(definition, item, undefined);
  return toStandard(mut);
}

function object(definer) {
  let flattened = (void 0);
  let items = [];
  let fields = {};
  let flatten = schema => {
    let match = schema.type;
    if (match === "object") {
      let flattenedItems = schema.items;
      for (let idx = 0, idx_finish = flattenedItems.length; idx < idx_finish; ++idx) {
        let match$1 = flattenedItems[idx];
        let inlinedLocation = match$1.inlinedLocation;
        let location = match$1.location;
        let flattenedSchema = match$1.schema;
        let item = fields[location];
        if (item !== undefined) {
          if (item.schema !== flattenedSchema) {
            throw new Error("[Schema] " + ("The field " + inlinedLocation + " defined twice with incompatible schemas"));
          }
          
        } else {
          let item$1 = {
            k: 0,
            schema: flattenedSchema,
            inlinedLocation: inlinedLocation,
            location: location
          };
          items.push(item$1);
          fields[location] = item$1;
        }
      }
      let f = (flattened || (flattened = []));
      let item_2 = f.length;
      let item$2 = {
        k: 2,
        schema: schema,
        p: "",
        i: item_2
      };
      f.push(item$2);
      return proxify(item$2);
    }
    let message = "The '" + toExpression(schema) + "' schema can't be flattened";
    throw new Error("[Schema] " + message);
  };
  let field = (fieldName, schema) => {
    let inlinedLocation = fromString(fieldName);
    if (fieldName in fields) {
      throw new Error("[Schema] " + ("The field " + inlinedLocation + " defined twice with incompatible schemas"));
    }
    let ditem = {
      k: 0,
      schema: schema,
      inlinedLocation: inlinedLocation,
      location: fieldName
    };
    fields[fieldName] = ditem;
    items.push(ditem);
    return proxify(ditem);
  };
  let tag = (tag$1, asValue) => {
    field(tag$1, definitionToSchema(asValue));
  };
  let fieldOr = (fieldName, schema, or) => {
    let schema$1 = factory$1(schema, undefined);
    return field(fieldName, getWithDefault(schema$1, {
      TAG: "Value",
      _0: or
    }));
  };
  let ctx = {
    field: field,
    f: field,
    fieldOr: fieldOr,
    tag: tag,
    nested: nested,
    flatten: flatten
  };
  let definition = definer(ctx);
  return toStandard({
    type: "object",
    b: advancedBuilder(definition, flattened),
    advanced: true,
    additionalItems: globalConfig.a,
    items: items,
    fields: fields,
    output: advancedReverse(definition, undefined, flattened)
  });
}

function tuple(definer) {
  let items = [];
  let item = (idx, schema) => {
    let location = idx.toString();
    let inlinedLocation = "\"" + location + "\"";
    if (items[idx]) {
      throw new Error("[Schema] " + ("The item [" + inlinedLocation + "] is defined multiple times"));
    }
    let ditem = {
      k: 0,
      schema: schema,
      inlinedLocation: inlinedLocation,
      location: location
    };
    items[idx] = ditem;
    return proxify(ditem);
  };
  let tag = (idx, asValue) => {
    item(idx, definitionToSchema(asValue));
  };
  let ctx = {
    item: item,
    tag: tag
  };
  let definition = definer(ctx);
  for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
    if (!items[idx]) {
      let location = idx.toString();
      let inlinedLocation = "\"" + location + "\"";
      let ditem = {
        schema: unit,
        location: location,
        inlinedLocation: inlinedLocation
      };
      items[idx] = ditem;
    }
    
  }
  return toStandard({
    type: "array",
    b: advancedBuilder(definition, undefined),
    additionalItems: "strict",
    items: items,
    output: advancedReverse(definition, undefined, undefined)
  });
}

function matches(schema) {
  return schema;
}

let ctx = {
  m: matches
};

function factory$5(definer) {
  return toStandard(definitionToSchema(definer(ctx)));
}

function factory$6(item) {
  return factory$1(item, nullAsUnit);
}

function js_schema(definition) {
  return toStandard(definitionToSchema(definition));
}

function $$enum(values) {
  return factory(values.map(js_schema));
}

function unnest(schema) {
  if (schema.type === "object") {
    let items = schema.items;
    if (items.length === 0) {
      throw new Error("[Schema] Invalid empty object for S.unnest schema.");
    }
    return toStandard({
      type: "array",
      b: (b, input, param, path) => {
        let inputVar = input.v(b);
        let iteratorVar = varWithoutAllocation(b.g);
        let bb = {
          c: "",
          l: "",
          a: initialAllocate,
          g: b.g
        };
        let itemInput = make(bb, false);
        let lengthCode = "";
        for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
          let item = items[idx];
          add(itemInput, item.inlinedLocation, {
            b: bb,
            v: _notVar,
            i: inputVar + "[" + idx + "][" + iteratorVar + "]",
            a: false
          });
          lengthCode = lengthCode + (inputVar + "[" + idx + "].length,");
        }
        let output = {
          b: b,
          v: _notVar,
          i: "new Array(Math.max(" + lengthCode + "))",
          a: false
        };
        let outputVar = output.v(b);
        let itemOutput = withPathPrepend(bb, complete(itemInput, false), path, iteratorVar, (bb, itemOutput) => {
          bb.c = bb.c + addKey(bb, output, iteratorVar, itemOutput) + ";";
        }, (b, input, path) => schema.b(b, input, schema, path));
        let itemCode = allocateScope(bb);
        b.c = b.c + ("for(let " + iteratorVar + "=0;" + iteratorVar + "<" + outputVar + ".length;++" + iteratorVar + "){" + itemCode + "}");
        if (itemOutput.a) {
          return {
            b: output.b,
            v: _notVar,
            i: "Promise.all(" + output.i + ")",
            a: true
          };
        } else {
          return output;
        }
      },
      additionalItems: "strict",
      items: items.map((item, idx) => {
        let location = idx.toString();
        return {
          schema: factory$2(item.schema),
          location: location,
          inlinedLocation: "\"" + location + "\""
        };
      }),
      unnest: true,
      output: () => {
        let schema$1 = reverse(schema);
        return {
          type: "array",
          b: (b, input, param, path) => {
            let inputVar = input.v(b);
            let iteratorVar = varWithoutAllocation(b.g);
            let outputVar = varWithoutAllocation(b.g);
            let bb = {
              c: "",
              l: "",
              a: initialAllocate,
              g: b.g
            };
            let itemInput = {
              b: bb,
              v: _notVar,
              i: inputVar + "[" + iteratorVar + "]",
              a: false
            };
            let itemOutput = withPathPrepend(bb, itemInput, path, iteratorVar, (bb, output) => {
              let initialArraysCode = "";
              let settingCode = "";
              for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
                let item = items[idx];
                initialArraysCode = initialArraysCode + ("new Array(" + inputVar + ".length),");
                settingCode = settingCode + (outputVar + "[" + idx + "][" + iteratorVar + "]=" + get(b, output, item.inlinedLocation).i + ";");
              }
              b.a(outputVar + "=[" + initialArraysCode + "]");
              bb.c = bb.c + settingCode;
            }, (b, input, path) => parseWithTypeValidation(b, schema$1, input, path));
            let itemCode = allocateScope(bb);
            b.c = b.c + ("for(let " + iteratorVar + "=0;" + iteratorVar + "<" + inputVar + ".length;++" + iteratorVar + "){" + itemCode + "}");
            if (itemOutput.a) {
              return {
                b: b,
                v: _notVar,
                i: "Promise.all(" + outputVar + ")",
                a: true
              };
            } else {
              return {
                b: b,
                v: _var,
                i: outputVar,
                a: false
              };
            }
          },
          additionalItems: schema$1,
          items: immutableEmpty$1
        };
      }
    });
  }
  throw new Error("[Schema] S.unnest supports only object schemas.");
}

function tuple1(v0) {
  return tuple(s => s.item(0, v0));
}

function tuple2(v0, v1) {
  return toStandard(definitionToSchema([
    v0,
    v1
  ]));
}

function tuple3(v0, v1, v2) {
  return toStandard(definitionToSchema([
    v0,
    v1,
    v2
  ]));
}

function port(schema, messageOpt) {
  let message = messageOpt !== undefined ? messageOpt : "Invalid port";
  return addRefinement(schema, metadataId$2, {
    kind: "Port",
    message: message
  }, (b, inputVar, param, path) => "if(" + inputVar + "<1||" + inputVar + ">65535){" + fail(b, message, path) + "}");
}

function floatMin(schema, minValue, maybeMessage) {
  let message = maybeMessage !== undefined ? maybeMessage : "Number must be greater than or equal to " + minValue;
  return addRefinement(schema, metadataId$3, {
    kind: {
      TAG: "Min",
      value: minValue
    },
    message: message
  }, (b, inputVar, param, path) => "if(" + inputVar + "<" + embed(b, minValue) + "){" + fail(b, message, path) + "}");
}

function floatMax(schema, maxValue, maybeMessage) {
  let message = maybeMessage !== undefined ? maybeMessage : "Number must be lower than or equal to " + maxValue;
  return addRefinement(schema, metadataId$3, {
    kind: {
      TAG: "Max",
      value: maxValue
    },
    message: message
  }, (b, inputVar, param, path) => "if(" + inputVar + ">" + embed(b, maxValue) + "){" + fail(b, message, path) + "}");
}

function email(schema, messageOpt) {
  let message = messageOpt !== undefined ? messageOpt : "Invalid email address";
  return addRefinement(schema, metadataId$1, {
    kind: "Email",
    message: message
  }, (b, inputVar, param, path) => "if(!" + embed(b, emailRegex) + ".test(" + inputVar + ")){" + fail(b, message, path) + "}");
}

function uuid(schema, messageOpt) {
  let message = messageOpt !== undefined ? messageOpt : "Invalid UUID";
  return addRefinement(schema, metadataId$1, {
    kind: "Uuid",
    message: message
  }, (b, inputVar, param, path) => "if(!" + embed(b, uuidRegex) + ".test(" + inputVar + ")){" + fail(b, message, path) + "}");
}

function cuid(schema, messageOpt) {
  let message = messageOpt !== undefined ? messageOpt : "Invalid CUID";
  return addRefinement(schema, metadataId$1, {
    kind: "Cuid",
    message: message
  }, (b, inputVar, param, path) => "if(!" + embed(b, cuidRegex) + ".test(" + inputVar + ")){" + fail(b, message, path) + "}");
}

function url(schema, messageOpt) {
  let message = messageOpt !== undefined ? messageOpt : "Invalid url";
  return addRefinement(schema, metadataId$1, {
    kind: "Url",
    message: message
  }, (b, inputVar, param, path) => "try{new URL(" + inputVar + ")}catch(_){" + fail(b, message, path) + "}");
}

function pattern(schema, re, messageOpt) {
  let message = messageOpt !== undefined ? messageOpt : "Invalid";
  return addRefinement(schema, metadataId$1, {
    kind: {
      TAG: "Pattern",
      re: re
    },
    message: message
  }, (b, inputVar, param, path) => {
    let reVal = {
      b: b,
      v: _var,
      i: embed(b, re),
      a: false
    };
    return reVal.i + ".lastIndex=0;if(!" + reVal.i + ".test(" + inputVar + ")){" + fail(b, message, path) + "}";
  });
}

function datetime(schema, messageOpt) {
  let message = messageOpt !== undefined ? messageOpt : "Invalid datetime string! Expected UTC";
  let refinement = {
    kind: "Datetime",
    message: message
  };
  let refinements = schema[metadataId$1];
  return transform$1(set$1(schema, metadataId$1, refinements !== undefined ? refinements.concat(refinement) : [refinement]), s => ({
    p: string => {
      if (!datetimeRe.test(string)) {
        s.fail(message, undefined);
      }
      return new Date(string);
    },
    s: date => date.toISOString()
  }));
}

function trim(schema) {
  let transformer = string => string.trim();
  return transform$1(schema, param => ({
    p: transformer,
    s: transformer
  }));
}

function nullish(schema) {
  return factory([
    schema,
    unit,
    $$null
  ]);
}

function js_union(values) {
  return factory(values.map(definitionToSchema));
}

function js_transform(schema, maybeParser, maybeSerializer) {
  return transform$1(schema, s => ({
    p: maybeParser !== undefined ? v => maybeParser(v, s) : undefined,
    s: maybeSerializer !== undefined ? v => maybeSerializer(v, s) : undefined
  }));
}

function js_refine(schema, refiner) {
  return refine(schema, s => (v => refiner(v, s)));
}

function noop$1(a) {
  return a;
}

function js_asyncParserRefine(schema, refine) {
  return transform$1(schema, s => ({
    a: v => refine(v, s).then(() => v),
    s: noop$1
  }));
}

function js_optional(schema, maybeOr) {
  let schema$1 = factory([
    schema,
    unit
  ]);
  if (maybeOr === undefined) {
    return schema$1;
  }
  let or = Primitive_option.valFromOption(maybeOr);
  if (typeof or === "function") {
    return getWithDefault(schema$1, {
      TAG: "Callback",
      _0: or
    });
  } else {
    return getWithDefault(schema$1, {
      TAG: "Value",
      _0: or
    });
  }
}

function js_nullable(schema, maybeOr) {
  let schema$1 = factory([
    schema,
    nullAsUnit
  ]);
  if (maybeOr === undefined) {
    return schema$1;
  }
  let or = Primitive_option.valFromOption(maybeOr);
  if (typeof or === "function") {
    return getWithDefault(schema$1, {
      TAG: "Callback",
      _0: or
    });
  } else {
    return getWithDefault(schema$1, {
      TAG: "Value",
      _0: or
    });
  }
}

function js_custom(name, maybeParser, maybeSerializer, param) {
  return custom(name, s => ({
    p: maybeParser !== undefined ? v => maybeParser(v, s) : undefined,
    s: maybeSerializer !== undefined ? v => maybeSerializer(v, s) : undefined
  }));
}

function js_merge(s1, s2) {
  if (s1.type === "object") {
    if (s2.type === "object") {
      let items2 = s2.items;
      let items = [].concat(s1.items);
      let fields = Object.assign({}, s1.fields);
      for (let idx = 0, idx_finish = items2.length; idx < idx_finish; ++idx) {
        let item = items2[idx];
        if (item.location in fields) {
          throw new Error("[Schema] " + ("The field " + item.inlinedLocation + " is defined multiple times"));
        }
        items.push(item);
        fields[item.location] = item;
      }
      return toStandard({
        type: "object",
        b: (b, input, param, path) => {
          let s1Result = s1.b(b, input, s1, path);
          let s2Result = s2.b(b, input, s2, path);
          return {
            b: b,
            v: _notVar,
            i: "{..." + s1Result.i + ", ..." + s2Result.i + "}",
            a: false
          };
        },
        advanced: true,
        additionalItems: s2.additionalItems,
        items: items,
        fields: fields,
        output: () => ({
          type: "unknown",
          b: (b, param, param$1, path) => invalidOperation(b, path, "The S.merge serializing is not supported yet")
        })
      });
    }
    throw new Error("[Schema] The merge supports only Object schemas");
  }
  throw new Error("[Schema] The merge supports only Object schemas");
}

function setGlobalConfig(override) {
  globalConfig.r = 0;
  let defaultAdditionalItems = override.defaultAdditionalItems;
  globalConfig.a = defaultAdditionalItems !== undefined ? defaultAdditionalItems : "strip";
  let prevDisableNanNumberCheck = globalConfig.n;
  let disableNanNumberValidation = override.disableNanNumberValidation;
  globalConfig.n = disableNanNumberValidation !== undefined ? disableNanNumberValidation : false;
  if (prevDisableNanNumberCheck !== globalConfig.n) {
    return resetOperationsCache(schema$4);
  }
  
}

let jsonSchemaMetadataId = "m:JSONSchema";

function internalToJSONSchema(schema) {
  let jsonSchema = {};
  switch (schema.type) {
    case "never" :
      jsonSchema.not = {};
      break;
    case "string" :
      let $$const = schema.const;
      jsonSchema.type = "string";
      refinements$1(schema).forEach(refinement => {
        let match = refinement.kind;
        if (typeof match !== "object") {
          switch (match) {
            case "Email" :
              jsonSchema.format = "email";
              return;
            case "Uuid" :
              jsonSchema.format = "uuid";
              return;
            case "Cuid" :
              return;
            case "Url" :
              jsonSchema.format = "uri";
              return;
            case "Datetime" :
              jsonSchema.format = "date-time";
              return;
          }
        } else {
          switch (match.TAG) {
            case "Min" :
              jsonSchema.minLength = match.length;
              return;
            case "Max" :
              jsonSchema.maxLength = match.length;
              return;
            case "Length" :
              let length = match.length;
              jsonSchema.minLength = length;
              jsonSchema.maxLength = length;
              return;
            case "Pattern" :
              jsonSchema.pattern = String(match.re);
              return;
          }
        }
      });
      if ($$const !== undefined) {
        jsonSchema.const = $$const;
      }
      break;
    case "number" :
      let $$const$1 = schema.const;
      if (schema.format !== undefined) {
        jsonSchema.type = "integer";
        refinements$2(schema).forEach(refinement => {
          let match = refinement.kind;
          if (typeof match !== "object") {
            return;
          } else {
            if (match.TAG === "Min") {
              jsonSchema.minimum = match.value;
            } else {
              jsonSchema.maximum = match.value;
            }
            return;
          }
        });
      } else {
        jsonSchema.type = "number";
        refinements$3(schema).forEach(refinement => {
          let match = refinement.kind;
          if (match.TAG === "Min") {
            jsonSchema.minimum = match.value;
          } else {
            jsonSchema.maximum = match.value;
          }
        });
      }
      if ($$const$1 !== undefined) {
        jsonSchema.const = $$const$1;
      }
      break;
    case "boolean" :
      let $$const$2 = schema.const;
      jsonSchema.type = "boolean";
      if ($$const$2 !== undefined) {
        jsonSchema.const = $$const$2;
      }
      break;
    case "null" :
      jsonSchema.type = "null";
      break;
    case "array" :
      let additionalItems = schema.additionalItems;
      let exit = 0;
      if (additionalItems === "strip" || additionalItems === "strict") {
        exit = 1;
      } else {
        jsonSchema.items = Primitive_option.some(internalToJSONSchema(additionalItems));
        jsonSchema.type = "array";
        refinements(schema).forEach(refinement => {
          let match = refinement.kind;
          switch (match.TAG) {
            case "Min" :
              jsonSchema.minItems = match.length;
              return;
            case "Max" :
              jsonSchema.maxItems = match.length;
              return;
            case "Length" :
              let length = match.length;
              jsonSchema.maxItems = length;
              jsonSchema.minItems = length;
              return;
          }
        });
      }
      if (exit === 1) {
        let items = schema.items.map(item => internalToJSONSchema(item.schema));
        let itemsNumber = items.length;
        jsonSchema.items = Primitive_option.some(items);
        jsonSchema.type = "array";
        jsonSchema.minItems = itemsNumber;
        jsonSchema.maxItems = itemsNumber;
      }
      break;
    case "object" :
      let additionalItems$1 = schema.additionalItems;
      let exit$1 = 0;
      if (additionalItems$1 === "strip" || additionalItems$1 === "strict") {
        exit$1 = 1;
      } else {
        jsonSchema.type = "object";
        jsonSchema.additionalProperties = Primitive_option.some(internalToJSONSchema(additionalItems$1));
      }
      if (exit$1 === 1) {
        let properties = {};
        let required = [];
        schema.items.forEach(item => {
          let fieldSchema = internalToJSONSchema(item.schema);
          if (!isOptional(item.schema)) {
            required.push(item.location);
          }
          properties[item.location] = fieldSchema;
        });
        let additionalProperties;
        additionalProperties = additionalItems$1 === "strip" || additionalItems$1 === "strict" ? additionalItems$1 === "strip" : true;
        jsonSchema.type = "object";
        jsonSchema.properties = properties;
        jsonSchema.additionalProperties = Primitive_option.some(additionalProperties);
        if (required.length !== 0) {
          jsonSchema.required = required;
        }
        
      }
      break;
    case "union" :
      let literals = [];
      let items$1 = [];
      schema.anyOf.forEach(childSchema => {
        if (childSchema.type === "undefined") {
          return;
        }
        items$1.push(internalToJSONSchema(childSchema));
        if (c in childSchema) {
          literals.push(childSchema.const);
          return;
        }
        
      });
      let itemsNumber$1 = items$1.length;
      if (itemsNumber$1 === 1) {
        Object.assign(jsonSchema, items$1[0]);
      } else if (literals.length === itemsNumber$1) {
        jsonSchema.enum = literals;
      } else {
        jsonSchema.anyOf = items$1;
      }
      break;
    case "unknown" :
    case "json" :
      break;
    default:
      throw new Error("[Schema] Unexpected schema type");
  }
  let m = schema.description;
  if (m !== undefined) {
    jsonSchema.description = m;
  }
  let deprecated = schema.deprecated;
  if (deprecated !== undefined) {
    jsonSchema.deprecated = deprecated;
  }
  let metadataRawSchema = schema[jsonSchemaMetadataId];
  if (metadataRawSchema !== undefined) {
    Object.assign(jsonSchema, metadataRawSchema);
  }
  return jsonSchema;
}

function toJSONSchema(schema) {
  jsonableValidation(schema, schema, "", 8);
  return internalToJSONSchema(schema);
}

function extendJSONSchema(schema, jsonSchema) {
  let existingSchemaExtend = schema[jsonSchemaMetadataId];
  return set$1(schema, jsonSchemaMetadataId, existingSchemaExtend !== undefined ? Object.assign({}, existingSchemaExtend, jsonSchema) : jsonSchema);
}

function min(schema, minValue, maybeMessage) {
  switch (schema.type) {
    case "string" :
      let message = maybeMessage !== undefined ? maybeMessage : "String must be " + minValue + " or more characters long";
      return addRefinement(schema, metadataId$1, {
        kind: {
          TAG: "Min",
          length: minValue
        },
        message: message
      }, (b, inputVar, param, path) => "if(" + inputVar + ".length<" + embed(b, minValue) + "){" + fail(b, message, path) + "}");
    case "number" :
      if (schema.format !== undefined) {
        let message$1 = maybeMessage !== undefined ? maybeMessage : "Number must be greater than or equal to " + minValue;
        return addRefinement(schema, metadataId$2, {
          kind: {
            TAG: "Min",
            value: minValue
          },
          message: message$1
        }, (b, inputVar, param, path) => "if(" + inputVar + "<" + embed(b, minValue) + "){" + fail(b, message$1, path) + "}");
      } else {
        return floatMin(schema, minValue, maybeMessage);
      }
    case "array" :
      let message$2 = maybeMessage !== undefined ? maybeMessage : "Array must be " + minValue + " or more items long";
      return addRefinement(schema, metadataId, {
        kind: {
          TAG: "Min",
          length: minValue
        },
        message: message$2
      }, (b, inputVar, param, path) => "if(" + inputVar + ".length<" + embed(b, minValue) + "){" + fail(b, message$2, path) + "}");
    default:
      let message$3 = "S.min is not supported for " + toExpression(schema) + " schema. Coerce the schema to string, number or array using S.to first.";
      throw new Error("[Schema] " + message$3);
  }
}

function max(schema, maxValue, maybeMessage) {
  switch (schema.type) {
    case "string" :
      let message = maybeMessage !== undefined ? maybeMessage : "String must be " + maxValue + " or fewer characters long";
      return addRefinement(schema, metadataId$1, {
        kind: {
          TAG: "Max",
          length: maxValue
        },
        message: message
      }, (b, inputVar, param, path) => "if(" + inputVar + ".length>" + embed(b, maxValue) + "){" + fail(b, message, path) + "}");
    case "number" :
      if (schema.format !== undefined) {
        let message$1 = maybeMessage !== undefined ? maybeMessage : "Number must be lower than or equal to " + maxValue;
        return addRefinement(schema, metadataId$2, {
          kind: {
            TAG: "Max",
            value: maxValue
          },
          message: message$1
        }, (b, inputVar, param, path) => "if(" + inputVar + ">" + embed(b, maxValue) + "){" + fail(b, message$1, path) + "}");
      } else {
        return floatMax(schema, maxValue, maybeMessage);
      }
    case "array" :
      let message$2 = maybeMessage !== undefined ? maybeMessage : "Array must be " + maxValue + " or fewer items long";
      return addRefinement(schema, metadataId, {
        kind: {
          TAG: "Max",
          length: maxValue
        },
        message: message$2
      }, (b, inputVar, param, path) => "if(" + inputVar + ".length>" + embed(b, maxValue) + "){" + fail(b, message$2, path) + "}");
    default:
      let message$3 = "S.max is not supported for " + toExpression(schema) + " schema. Coerce the schema to string, number or array using S.to first.";
      throw new Error("[Schema] " + message$3);
  }
}

function length(schema, length$1, maybeMessage) {
  switch (schema.type) {
    case "string" :
      let message = maybeMessage !== undefined ? maybeMessage : "String must be exactly " + length$1 + " characters long";
      return addRefinement(schema, metadataId$1, {
        kind: {
          TAG: "Length",
          length: length$1
        },
        message: message
      }, (b, inputVar, param, path) => "if(" + inputVar + ".length!==" + embed(b, length$1) + "){" + fail(b, message, path) + "}");
    case "array" :
      let message$1 = maybeMessage !== undefined ? maybeMessage : "Array must be exactly " + length$1 + " items long";
      return addRefinement(schema, metadataId, {
        kind: {
          TAG: "Length",
          length: length$1
        },
        message: message$1
      }, (b, inputVar, param, path) => "if(" + inputVar + ".length!==" + embed(b, length$1) + "){" + fail(b, message$1, path) + "}");
    default:
      let message$2 = "S.length is not supported for " + toExpression(schema) + " schema. Coerce the schema to string or array using S.to first.";
      throw new Error("[Schema] " + message$2);
  }
}

let Path = {
  empty: "",
  dynamic: "[]",
  toArray: toArray,
  fromArray: fromArray,
  fromLocation: fromLocation,
  concat: concat
};

let Flag = {
  none: 0,
  typeValidation: 1,
  async: 2,
  assertOutput: 4,
  jsonableOutput: 8,
  jsonStringOutput: 16,
  reverse: 32,
  has: has
};

let never = schema;

let string = schema$1;

let bool = schema$2;

let int = schema$3;

let float = schema$4;

let bigint = schema$5;

let literal = js_schema;

let array = factory$2;

let dict = factory$3;

let option = factory$1;

let $$null$1 = factory$6;

let jsonString = factory$4;

let union = factory;

let parseJsonOrThrow = parseOrThrow;

let Schema = {};

let schema$6 = factory$5;

let $$Object = {};

let Option = {
  $$default: $$default,
  getOr: getOr,
  getOrWith: getOrWith
};

let String_Refinement = {};

let $$String$1 = {
  Refinement: String_Refinement,
  refinements: refinements$1
};

let Int_Refinement = {};

let Int = {
  Refinement: Int_Refinement,
  refinements: refinements$2
};

let Float_Refinement = {};

let Float = {
  Refinement: Float_Refinement,
  refinements: refinements$3
};

let Array_Refinement = {};

let $$Array = {
  Refinement: Array_Refinement,
  refinements: refinements
};

let Metadata = {
  Id: Id,
  get: get$1,
  set: set$1
};

export {
  Path,
  $$Error,
  Flag,
  never,
  unknown,
  unit,
  nullAsUnit,
  string,
  bool,
  int,
  float,
  bigint,
  json,
  literal,
  array,
  unnest,
  list,
  dict,
  option,
  $$null$1 as $$null,
  nullish,
  jsonString,
  union,
  $$enum,
  meta,
  Catch,
  $$catch,
  transform$1 as transform,
  custom,
  refine,
  shape,
  to,
  compile,
  parseOrThrow,
  parseJsonOrThrow,
  parseJsonStringOrThrow,
  parseAsyncOrThrow,
  convertOrThrow,
  convertToJsonOrThrow,
  convertToJsonStringOrThrow,
  convertAsyncOrThrow,
  reverseConvertOrThrow,
  reverseConvertToJsonOrThrow,
  reverseConvertToJsonStringOrThrow,
  assertOrThrow,
  isAsync,
  recursive,
  noValidation,
  toExpression,
  Schema,
  schema$6 as schema,
  $$Object,
  object,
  strip,
  deepStrip,
  strict,
  deepStrict,
  Tuple,
  tuple,
  tuple1,
  tuple2,
  tuple3,
  Option,
  $$String$1 as $$String,
  Int,
  Float,
  $$Array,
  Metadata,
  reverse,
  ErrorClass,
  min,
  floatMin,
  max,
  floatMax,
  length,
  port,
  email,
  uuid,
  cuid,
  url,
  pattern,
  datetime,
  trim,
  toJSONSchema,
  extendJSONSchema,
  setGlobalConfig,
  js_safe,
  js_safeAsync,
  js_union,
  js_optional,
  js_nullable,
  js_custom,
  js_asyncParserRefine,
  js_refine,
  js_transform,
  js_schema,
  js_merge,
}
/* symbol Not a pure module */
